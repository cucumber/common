package Cucumber::Messages;

# DO NOT CHANGE THIS FILE!!

# The code was auto-generated by this script:
# https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb

=head1 NAME

Cucumber::Messages - Library of classes to encapsulate Cucumber messages

=head1 SYNOPSIS

  use Cucumber::Messages;

  my $loc = Cucumber::Messages::Location->new(
     line => 12, column => 26
  );
  my $loc_json = $loc->to_json;

  my $envelope = Cucumber::Messages::Envelope->from_json($serialized_envelope);

=head1 DESCRIPTION

L<Cucumber messages|https://github.com/cucumber/common/tree/main/messages>
define the central protocol in the Cucumber ecosystem by which the various
components communicate. Messages are serialized to NDJSON.

This library provides both serialization/deserialization to/from NDJSON as
well as the in-memory representation of the messages for Perl applications.

Each serialized message should be wrapped in a C<Cucumber::Messages::Envelope>
and can thereby be deserialized by calling the C<from_json> class message
with the serialized representation as its argument, like shown in the SYNOPSIS.

=cut

use strict;
use warnings;

use Cucumber::Messages::Message;

=head1 MESSAGE CLASSES

=cut

<%- @schemas.sort.each do |key, schema| %>

package Cucumber::Messages::<%= class_name(key) %> {

=head2 Cucumber::Messages::<%= class_name(key) %>

=head3 DESCRIPTION

Represents the <%= class_name(key) %> message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

<%= format_description(schema['description']) %>

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
<%- schema['properties'].each do |property_name, property| -%>
   <%= underscore(property_name) %> => '<%= type_for(class_name(key), property_name, property) %>',
<%- end -%>
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}


<%- schema['properties'].each do |property_name, property| -%>

=head4 <%= underscore(property_name) %>

<%- if property['description'] -%>
<%= format_description(property['description']) %>
<%- end -%>

<% if property['enum'] -%>

Available constants for valid values of this field:

=over

<%- property['enum'].to_a.each_with_index do |value, index| -%>
=item * <%= property_name.upcase %>_<%= enum_constant(value) %>

<%- end -%>
=back

<% end -%>
=cut

<% if property['enum'] -%>

use constant
<%- property['enum'].to_a.each_with_index do |value, index| -%>
   <%= property_name.upcase %>_<%= enum_constant(value) %> => '<%= value %>',
<%- end -%>
   ;

<% end -%>
has <%= underscore(property_name) %> =>
    (is => 'ro',
     <%- if (schema['required'] || []).index(property_name) -%>
     required => 1,
     <%- if default_value(class_name(key), property_name, property) -%>
     default => sub { <%= default_value(class_name(key), property_name, property) %> },
     <%- end -%>
     <%- end -%>
    );

<%- end %>
}<%- end -%>


1;

__END__

=head1 LICENSE

Please see the included LICENSE for the canonical version. In summary:

The MIT License (MIT)

  Copyright (c) 2021 Erik Huelsmann
  Copyright (c) 2021 Cucumber Ltd

This work is loosely derived from prior work of the same library for Ruby,
called C<cucumber-messages>.

=cut


