<?php declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use \JsonSerializable;

/**
 * Represents the Attachment message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * //// Attachments (parse errors, execution errors, screenshots, links...)
 * 
 * An attachment represents any kind of data associated with a line in a
 * [Source](#io.cucumber.messages.Source) file. It can be used for:
 * 
 * * Syntax errors during parse time
 * * Screenshots captured and attached during execution
 * * Logs captured and attached during execution
 * 
 * It is not to be used for runtime errors raised/thrown during execution. This
 * is captured in `TestResult`. */
final class Attachment implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The body of the attachment. If `contentEncoding` is `IDENTITY`, the attachment
         * is simply the string. If it's `BASE64`, the string should be Base64 decoded to
         * obtain the attachment.
         */
        public readonly string $body,

        /**
	     * Whether to interpret `body` "as-is" (IDENTITY) or if it needs to be Base64-decoded (BASE64).
         * 
         * Content encoding is *not* determined by the media type, but rather by the type
         * of the object being attached:
         * 
         * - string => IDENTITY
         * - byte array => BASE64
         * - stream => BASE64
         */
        public readonly Attachment\ContentEncoding $contentEncoding,

        /**
	     * Suggested file name of the attachment. (Provided by the user as an argument to `attach`)
         */
        public readonly ?string $fileName,

        /**
	     * The media type of the data. This can be any valid
         * [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
         * as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
         * and `text/x.cucumber.stacktrace+plain`
         */
        public readonly string $mediaType,

        public readonly ?Source $source,

        public readonly ?string $testCaseStartedId,

        public readonly ?string $testStepId,

        /**
	     * A URL where the attachment can be retrieved. This field should not be set by Cucumber.
         * It should be set by a program that reads a message stream and does the following for
         * each Attachment message:
         * 
         * - Writes the body (after base64 decoding if necessary) to a new file.
         * - Sets `body` and `contentEncoding` to `null`
         * - Writes out the new attachment message
         * 
         * This will result in a smaller message stream, which can improve performance and
         * reduce bandwidth of message consumers. It also makes it easier to process and download attachments
         * separately from reports.
         */
        public readonly ?string $url,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['body'],
			Attachment\ContentEncoding::from((string) $arr['contentEncoding']),
			isset($arr['fileName']) ? (string) $arr['fileName'] : null,
			(string) $arr['mediaType'],
			isset($arr['source']) ? Source::fromArray($arr['source']) : null,
			isset($arr['testCaseStartedId']) ? (string) $arr['testCaseStartedId'] : null,
			isset($arr['testStepId']) ? (string) $arr['testStepId'] : null,
			isset($arr['url']) ? (string) $arr['url'] : null,
    	);
    }
}


/**
 * Represents the Duration message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * The structure is pretty close of the Timestamp one. For clarity, a second type
 * of message is used. */
final class Duration implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly int $seconds,

        /**
	     * Non-negative fractions of a second at nanosecond resolution. Negative
         * second values with fractions must still have non-negative nanos values
         * that count forward in time. Must be from 0 to 999,999,999
         * inclusive.
         */
        public readonly int $nanos,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(int) $arr['seconds'],
			(int) $arr['nanos'],
    	);
    }
}


/**
 * Represents the Envelope message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * When removing a field, replace it with reserved, rather than deleting the line.
 * When adding a field, add it to the end and increment the number by one.
 * See https://developers.google.com/protocol-buffers/docs/proto#updating for details
 * 
 * All the messages that are passed between different components/processes are Envelope
 * messages. */
final class Envelope implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly ?Attachment $attachment,

        public readonly ?GherkinDocument $gherkinDocument,

        public readonly ?Hook $hook,

        public readonly ?Meta $meta,

        public readonly ?ParameterType $parameterType,

        public readonly ?ParseError $parseError,

        public readonly ?Pickle $pickle,

        public readonly ?Source $source,

        public readonly ?StepDefinition $stepDefinition,

        public readonly ?TestCase $testCase,

        public readonly ?TestCaseFinished $testCaseFinished,

        public readonly ?TestCaseStarted $testCaseStarted,

        public readonly ?TestRunFinished $testRunFinished,

        public readonly ?TestRunStarted $testRunStarted,

        public readonly ?TestStepFinished $testStepFinished,

        public readonly ?TestStepStarted $testStepStarted,

        public readonly ?UndefinedParameterType $undefinedParameterType,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			isset($arr['attachment']) ? Attachment::fromArray($arr['attachment']) : null,
			isset($arr['gherkinDocument']) ? GherkinDocument::fromArray($arr['gherkinDocument']) : null,
			isset($arr['hook']) ? Hook::fromArray($arr['hook']) : null,
			isset($arr['meta']) ? Meta::fromArray($arr['meta']) : null,
			isset($arr['parameterType']) ? ParameterType::fromArray($arr['parameterType']) : null,
			isset($arr['parseError']) ? ParseError::fromArray($arr['parseError']) : null,
			isset($arr['pickle']) ? Pickle::fromArray($arr['pickle']) : null,
			isset($arr['source']) ? Source::fromArray($arr['source']) : null,
			isset($arr['stepDefinition']) ? StepDefinition::fromArray($arr['stepDefinition']) : null,
			isset($arr['testCase']) ? TestCase::fromArray($arr['testCase']) : null,
			isset($arr['testCaseFinished']) ? TestCaseFinished::fromArray($arr['testCaseFinished']) : null,
			isset($arr['testCaseStarted']) ? TestCaseStarted::fromArray($arr['testCaseStarted']) : null,
			isset($arr['testRunFinished']) ? TestRunFinished::fromArray($arr['testRunFinished']) : null,
			isset($arr['testRunStarted']) ? TestRunStarted::fromArray($arr['testRunStarted']) : null,
			isset($arr['testStepFinished']) ? TestStepFinished::fromArray($arr['testStepFinished']) : null,
			isset($arr['testStepStarted']) ? TestStepStarted::fromArray($arr['testStepStarted']) : null,
			isset($arr['undefinedParameterType']) ? UndefinedParameterType::fromArray($arr['undefinedParameterType']) : null,
    	);
    }
}


/**
 * Represents the GherkinDocument message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * The [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) of a Gherkin document.
 * Cucumber implementations should *not* depend on `GherkinDocument` or any of its
 * children for execution - use [Pickle](#io.cucumber.messages.Pickle) instead.
 * 
 * The only consumers of `GherkinDocument` should only be formatters that produce
 * "rich" output, resembling the original Gherkin document. */
final class GherkinDocument implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
         * of the source, typically a file path relative to the root directory
         */
        public readonly ?string $uri,

        public readonly ?Feature $feature,

        /**
	     * All the comments in the Gherkin document
         * @param list<Comment> $comments
         */
        public readonly array $comments,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			isset($arr['uri']) ? (string) $arr['uri'] : null,
			isset($arr['feature']) ? Feature::fromArray($arr['feature']) : null,
			array_map(fn(mixed $member) => Comment::fromArray($member) , $arr['comments']),
    	);
    }
}


/**
 * Represents the Background message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Background implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The location of the `Background` keyword
         */
        public readonly Location $location,

        public readonly string $keyword,

        public readonly string $name,

        public readonly string $description,

        /**
         * @param list<Step> $steps
         */
        public readonly array $steps,

        public readonly string $id,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			(string) $arr['keyword'],
			(string) $arr['name'],
			(string) $arr['description'],
			array_map(fn(mixed $member) => Step::fromArray($member) , $arr['steps']),
			(string) $arr['id'],
    	);
    }
}


/**
 * Represents the Comment message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A comment in a Gherkin document */
final class Comment implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The location of the comment
         */
        public readonly Location $location,

        /**
	     * The text of the comment
         */
        public readonly string $text,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			(string) $arr['text'],
    	);
    }
}


/**
 * Represents the DataTable message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class DataTable implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly Location $location,

        /**
         * @param list<TableRow> $rows
         */
        public readonly array $rows,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			array_map(fn(mixed $member) => TableRow::fromArray($member) , $arr['rows']),
    	);
    }
}


/**
 * Represents the DocString message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class DocString implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly Location $location,

        public readonly ?string $mediaType,

        public readonly string $content,

        public readonly string $delimiter,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			isset($arr['mediaType']) ? (string) $arr['mediaType'] : null,
			(string) $arr['content'],
			(string) $arr['delimiter'],
    	);
    }
}


/**
 * Represents the Examples message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Examples implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The location of the `Examples` keyword
         */
        public readonly Location $location,

        /**
         * @param list<Tag> $tags
         */
        public readonly array $tags,

        public readonly string $keyword,

        public readonly string $name,

        public readonly string $description,

        public readonly ?TableRow $tableHeader,

        /**
         * @param list<TableRow> $tableBody
         */
        public readonly array $tableBody,

        public readonly string $id,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			array_map(fn(mixed $member) => Tag::fromArray($member) , $arr['tags']),
			(string) $arr['keyword'],
			(string) $arr['name'],
			(string) $arr['description'],
			isset($arr['tableHeader']) ? TableRow::fromArray($arr['tableHeader']) : null,
			array_map(fn(mixed $member) => TableRow::fromArray($member) , $arr['tableBody']),
			(string) $arr['id'],
    	);
    }
}


/**
 * Represents the Feature message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Feature implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The location of the `Feature` keyword
         */
        public readonly Location $location,

        /**
	     * All the tags placed above the `Feature` keyword
         * @param list<Tag> $tags
         */
        public readonly array $tags,

        /**
	     * The [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code of the Gherkin document
         */
        public readonly string $language,

        /**
	     * The text of the `Feature` keyword (in the language specified by `language`)
         */
        public readonly string $keyword,

        /**
	     * The name of the feature (the text following the `keyword`)
         */
        public readonly string $name,

        /**
	     * The line(s) underneath the line with the `keyword` that are used as description
         */
        public readonly string $description,

        /**
	     * Zero or more children
         * @param list<FeatureChild> $children
         */
        public readonly array $children,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			array_map(fn(mixed $member) => Tag::fromArray($member) , $arr['tags']),
			(string) $arr['language'],
			(string) $arr['keyword'],
			(string) $arr['name'],
			(string) $arr['description'],
			array_map(fn(mixed $member) => FeatureChild::fromArray($member) , $arr['children']),
    	);
    }
}


/**
 * Represents the FeatureChild message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A child node of a `Feature` node */
final class FeatureChild implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly ?Rule $rule,

        public readonly ?Background $background,

        public readonly ?Scenario $scenario,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			isset($arr['rule']) ? Rule::fromArray($arr['rule']) : null,
			isset($arr['background']) ? Background::fromArray($arr['background']) : null,
			isset($arr['scenario']) ? Scenario::fromArray($arr['scenario']) : null,
    	);
    }
}


/**
 * Represents the Rule message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Rule implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The location of the `Rule` keyword
         */
        public readonly Location $location,

        /**
	     * All the tags placed above the `Rule` keyword
         * @param list<Tag> $tags
         */
        public readonly array $tags,

        public readonly string $keyword,

        public readonly string $name,

        public readonly string $description,

        /**
         * @param list<RuleChild> $children
         */
        public readonly array $children,

        public readonly string $id,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			array_map(fn(mixed $member) => Tag::fromArray($member) , $arr['tags']),
			(string) $arr['keyword'],
			(string) $arr['name'],
			(string) $arr['description'],
			array_map(fn(mixed $member) => RuleChild::fromArray($member) , $arr['children']),
			(string) $arr['id'],
    	);
    }
}


/**
 * Represents the RuleChild message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A child node of a `Rule` node */
final class RuleChild implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly ?Background $background,

        public readonly ?Scenario $scenario,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			isset($arr['background']) ? Background::fromArray($arr['background']) : null,
			isset($arr['scenario']) ? Scenario::fromArray($arr['scenario']) : null,
    	);
    }
}


/**
 * Represents the Scenario message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Scenario implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The location of the `Scenario` keyword
         */
        public readonly Location $location,

        /**
         * @param list<Tag> $tags
         */
        public readonly array $tags,

        public readonly string $keyword,

        public readonly string $name,

        public readonly string $description,

        /**
         * @param list<Step> $steps
         */
        public readonly array $steps,

        /**
         * @param list<Examples> $examples
         */
        public readonly array $examples,

        public readonly string $id,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			array_map(fn(mixed $member) => Tag::fromArray($member) , $arr['tags']),
			(string) $arr['keyword'],
			(string) $arr['name'],
			(string) $arr['description'],
			array_map(fn(mixed $member) => Step::fromArray($member) , $arr['steps']),
			array_map(fn(mixed $member) => Examples::fromArray($member) , $arr['examples']),
			(string) $arr['id'],
    	);
    }
}


/**
 * Represents the Step message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A step */
final class Step implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The location of the steps' `keyword`
         */
        public readonly Location $location,

        public readonly string $keyword,

        public readonly string $text,

        public readonly ?DocString $docString,

        public readonly ?DataTable $dataTable,

        /**
	     * Unique ID to be able to reference the Step from PickleStep
         */
        public readonly string $id,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			(string) $arr['keyword'],
			(string) $arr['text'],
			isset($arr['docString']) ? DocString::fromArray($arr['docString']) : null,
			isset($arr['dataTable']) ? DataTable::fromArray($arr['dataTable']) : null,
			(string) $arr['id'],
    	);
    }
}


/**
 * Represents the TableCell message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A cell in a `TableRow` */
final class TableCell implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The location of the cell
         */
        public readonly Location $location,

        /**
	     * The value of the cell
         */
        public readonly string $value,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			(string) $arr['value'],
    	);
    }
}


/**
 * Represents the TableRow message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A row in a table */
final class TableRow implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The location of the first cell in the row
         */
        public readonly Location $location,

        /**
	     * Cells in the row
         * @param list<TableCell> $cells
         */
        public readonly array $cells,

        public readonly string $id,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			array_map(fn(mixed $member) => TableCell::fromArray($member) , $arr['cells']),
			(string) $arr['id'],
    	);
    }
}


/**
 * Represents the Tag message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A tag */
final class Tag implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * Location of the tag
         */
        public readonly Location $location,

        /**
	     * The name of the tag (including the leading `@`)
         */
        public readonly string $name,

        /**
	     * Unique ID to be able to reference the Tag from PickleTag
         */
        public readonly string $id,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Location::fromArray($arr['location']),
			(string) $arr['name'],
			(string) $arr['id'],
    	);
    }
}


/**
 * Represents the Hook message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Hook implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $id,

        public readonly SourceReference $sourceReference,

        public readonly ?string $tagExpression,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['id'],
			SourceReference::fromArray($arr['sourceReference']),
			isset($arr['tagExpression']) ? (string) $arr['tagExpression'] : null,
    	);
    }
}


/**
 * Represents the Location message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * Points to a line and a column in a text file */
final class Location implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly int $line,

        public readonly ?int $column,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(int) $arr['line'],
			isset($arr['column']) ? (int) $arr['column'] : null,
    	);
    }
}


/**
 * Represents the Meta message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * This message contains meta information about the environment. Consumers can use
 * this for various purposes. */
final class Meta implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The [SEMVER](https://semver.org/) version number of the protocol
         */
        public readonly string $protocolVersion,

        /**
	     * SpecFlow, Cucumber-JVM, Cucumber.js, Cucumber-Ruby, Behat etc.
         */
        public readonly Product $implementation,

        /**
	     * Java, Ruby, Node.js etc
         */
        public readonly Product $runtime,

        /**
	     * Windows, Linux, MacOS etc
         */
        public readonly Product $os,

        /**
	     * 386, arm, amd64 etc
         */
        public readonly Product $cpu,

        public readonly ?Ci $ci,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['protocolVersion'],
			Product::fromArray($arr['implementation']),
			Product::fromArray($arr['runtime']),
			Product::fromArray($arr['os']),
			Product::fromArray($arr['cpu']),
			isset($arr['ci']) ? Ci::fromArray($arr['ci']) : null,
    	);
    }
}


/**
 * Represents the Ci message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * CI environment */
final class Ci implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * Name of the CI product, e.g. "Jenkins", "CircleCI" etc.
         */
        public readonly string $name,

        /**
	     * Link to the build
         */
        public readonly ?string $url,

        /**
	     * The build number. Some CI servers use non-numeric build numbers, which is why this is a string
         */
        public readonly ?string $buildNumber,

        public readonly ?Git $git,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['name'],
			isset($arr['url']) ? (string) $arr['url'] : null,
			isset($arr['buildNumber']) ? (string) $arr['buildNumber'] : null,
			isset($arr['git']) ? Git::fromArray($arr['git']) : null,
    	);
    }
}


/**
 * Represents the Git message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * Information about Git, provided by the Build/CI server as environment
 * variables. */
final class Git implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $remote,

        public readonly string $revision,

        public readonly ?string $branch,

        public readonly ?string $tag,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['remote'],
			(string) $arr['revision'],
			isset($arr['branch']) ? (string) $arr['branch'] : null,
			isset($arr['tag']) ? (string) $arr['tag'] : null,
    	);
    }
}


/**
 * Represents the Product message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * Used to describe various properties of Meta */
final class Product implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The product name
         */
        public readonly string $name,

        /**
	     * The product version
         */
        public readonly ?string $version,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['name'],
			isset($arr['version']) ? (string) $arr['version'] : null,
    	);
    }
}


/**
 * Represents the ParameterType message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class ParameterType implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The name is unique, so we don't need an id.
         */
        public readonly string $name,

        /**
         * @param list<string> $regularExpressions
         */
        public readonly array $regularExpressions,

        public readonly bool $preferForRegularExpressionMatch,

        public readonly bool $useForSnippets,

        public readonly string $id,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['name'],
			array_map(fn(mixed $member) => (string) $member , $arr['regularExpressions']),
			(bool) $arr['preferForRegularExpressionMatch'],
			(bool) $arr['useForSnippets'],
			(string) $arr['id'],
    	);
    }
}


/**
 * Represents the ParseError message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class ParseError implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly SourceReference $source,

        public readonly string $message,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			SourceReference::fromArray($arr['source']),
			(string) $arr['message'],
    	);
    }
}


/**
 * Represents the Pickle message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * //// Pickles
 * 
 * A `Pickle` represents a template for a `TestCase`. It is typically derived
 * from another format, such as [GherkinDocument](#io.cucumber.messages.GherkinDocument).
 * In the future a `Pickle` may be derived from other formats such as Markdown or
 * Excel files.
 * 
 * By making `Pickle` the main data structure Cucumber uses for execution, the
 * implementation of Cucumber itself becomes simpler, as it doesn't have to deal
 * with the complex structure of a [GherkinDocument](#io.cucumber.messages.GherkinDocument).
 * 
 * Each `PickleStep` of a `Pickle` is matched with a `StepDefinition` to create a `TestCase` */
final class Pickle implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * A unique id for the pickle. This is a [SHA1](https://en.wikipedia.org/wiki/SHA-1) hash
         * from the source data and the `locations` of the pickle.
         * This ID will change if source the file is modified.
         */
        public readonly string $id,

        /**
	     * The uri of the source file
         */
        public readonly string $uri,

        /**
	     * The name of the pickle
         */
        public readonly string $name,

        /**
	     * The language of the pickle
         */
        public readonly string $language,

        /**
	     * One or more steps
         * @param list<PickleStep> $steps
         */
        public readonly array $steps,

        /**
	     * One or more tags. If this pickle is constructed from a Gherkin document,
         * It includes inherited tags from the `Feature` as well.
         * @param list<PickleTag> $tags
         */
        public readonly array $tags,

        /**
	     * Points to the AST node locations of the pickle. The last one represents the unique
         * id of the pickle. A pickle constructed from `Examples` will have the first
         * id originating from the `Scenario` AST node, and the second from the `TableRow` AST node.
         * @param list<string> $astNodeIds
         */
        public readonly array $astNodeIds,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['id'],
			(string) $arr['uri'],
			(string) $arr['name'],
			(string) $arr['language'],
			array_map(fn(mixed $member) => PickleStep::fromArray($member) , $arr['steps']),
			array_map(fn(mixed $member) => PickleTag::fromArray($member) , $arr['tags']),
			array_map(fn(mixed $member) => (string) $member , $arr['astNodeIds']),
    	);
    }
}


/**
 * Represents the PickleDocString message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class PickleDocString implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly ?string $mediaType,

        public readonly string $content,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			isset($arr['mediaType']) ? (string) $arr['mediaType'] : null,
			(string) $arr['content'],
    	);
    }
}


/**
 * Represents the PickleStep message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * An executable step */
final class PickleStep implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly ?PickleStepArgument $argument,

        /**
	     * References the IDs of the source of the step. For Gherkin, this can be
         * the ID of a Step, and possibly also the ID of a TableRow
         * @param list<string> $astNodeIds
         */
        public readonly array $astNodeIds,

        /**
	     * A unique ID for the PickleStep
         */
        public readonly string $id,

        public readonly string $text,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			isset($arr['argument']) ? PickleStepArgument::fromArray($arr['argument']) : null,
			array_map(fn(mixed $member) => (string) $member , $arr['astNodeIds']),
			(string) $arr['id'],
			(string) $arr['text'],
    	);
    }
}


/**
 * Represents the PickleStepArgument message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * An optional argument */
final class PickleStepArgument implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly ?PickleDocString $docString,

        public readonly ?PickleTable $dataTable,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			isset($arr['docString']) ? PickleDocString::fromArray($arr['docString']) : null,
			isset($arr['dataTable']) ? PickleTable::fromArray($arr['dataTable']) : null,
    	);
    }
}


/**
 * Represents the PickleTable message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class PickleTable implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
         * @param list<PickleTableRow> $rows
         */
        public readonly array $rows,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			array_map(fn(mixed $member) => PickleTableRow::fromArray($member) , $arr['rows']),
    	);
    }
}


/**
 * Represents the PickleTableCell message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class PickleTableCell implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $value,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['value'],
    	);
    }
}


/**
 * Represents the PickleTableRow message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class PickleTableRow implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
         * @param list<PickleTableCell> $cells
         */
        public readonly array $cells,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			array_map(fn(mixed $member) => PickleTableCell::fromArray($member) , $arr['cells']),
    	);
    }
}


/**
 * Represents the PickleTag message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A tag */
final class PickleTag implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $name,

        /**
	     * Points to the AST node this was created from
         */
        public readonly string $astNodeId,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['name'],
			(string) $arr['astNodeId'],
    	);
    }
}


/**
 * Represents the Source message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * //// Source
 * 
 * A source file, typically a Gherkin document or Java/Ruby/JavaScript source code */
final class Source implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
         * of the source, typically a file path relative to the root directory
         */
        public readonly string $uri,

        /**
	     * The contents of the file
         */
        public readonly string $data,

        /**
	     * The media type of the file. Can be used to specify custom types, such as
         * text/x.cucumber.gherkin+plain
         */
        public readonly Source\MediaType $mediaType,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['uri'],
			(string) $arr['data'],
			Source\MediaType::from((string) $arr['mediaType']),
    	);
    }
}


/**
 * Represents the SourceReference message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * Points to a [Source](#io.cucumber.messages.Source) identified by `uri` and a
 * [Location](#io.cucumber.messages.Location) within that file. */
final class SourceReference implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly ?string $uri,

        public readonly ?JavaMethod $javaMethod,

        public readonly ?JavaStackTraceElement $javaStackTraceElement,

        public readonly ?Location $location,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			isset($arr['uri']) ? (string) $arr['uri'] : null,
			isset($arr['javaMethod']) ? JavaMethod::fromArray($arr['javaMethod']) : null,
			isset($arr['javaStackTraceElement']) ? JavaStackTraceElement::fromArray($arr['javaStackTraceElement']) : null,
			isset($arr['location']) ? Location::fromArray($arr['location']) : null,
    	);
    }
}


/**
 * Represents the JavaMethod message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class JavaMethod implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $className,

        public readonly string $methodName,

        /**
         * @param list<string> $methodParameterTypes
         */
        public readonly array $methodParameterTypes,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['className'],
			(string) $arr['methodName'],
			array_map(fn(mixed $member) => (string) $member , $arr['methodParameterTypes']),
    	);
    }
}


/**
 * Represents the JavaStackTraceElement message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class JavaStackTraceElement implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $className,

        public readonly string $fileName,

        public readonly string $methodName,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['className'],
			(string) $arr['fileName'],
			(string) $arr['methodName'],
    	);
    }
}


/**
 * Represents the StepDefinition message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class StepDefinition implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $id,

        public readonly StepDefinitionPattern $pattern,

        public readonly SourceReference $sourceReference,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['id'],
			StepDefinitionPattern::fromArray($arr['pattern']),
			SourceReference::fromArray($arr['sourceReference']),
    	);
    }
}


/**
 * Represents the StepDefinitionPattern message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class StepDefinitionPattern implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $source,

        public readonly StepDefinitionPattern\Type $type,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['source'],
			StepDefinitionPattern\Type::from((string) $arr['type']),
    	);
    }
}


/**
 * Represents the TestCase message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * //// TestCases
 * 
 * A `TestCase` contains a sequence of `TestStep`s. */
final class TestCase implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $id,

        /**
	     * The ID of the `Pickle` this `TestCase` is derived from.
         */
        public readonly string $pickleId,

        /**
         * @param list<TestStep> $testSteps
         */
        public readonly array $testSteps,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['id'],
			(string) $arr['pickleId'],
			array_map(fn(mixed $member) => TestStep::fromArray($member) , $arr['testSteps']),
    	);
    }
}


/**
 * Represents the Group message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Group implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
         * @param list<Group> $children
         */
        public readonly array $children,

        public readonly ?int $start,

        public readonly ?string $value,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			array_map(fn(mixed $member) => Group::fromArray($member) , $arr['children']),
			isset($arr['start']) ? (int) $arr['start'] : null,
			isset($arr['value']) ? (string) $arr['value'] : null,
    	);
    }
}


/**
 * Represents the StepMatchArgument message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * Represents a single argument extracted from a step match and passed to a step definition.
 * This is used for the following purposes:
 * - Construct an argument to pass to a step definition (possibly through a parameter type transform)
 * - Highlight the matched parameter in rich formatters such as the HTML formatter
 * 
 * This message closely matches the `Argument` class in the `cucumber-expressions` library. */
final class StepMatchArgument implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * Represents the outermost capture group of an argument. This message closely matches the
         * `Group` class in the `cucumber-expressions` library.
         */
        public readonly Group $group,

        public readonly ?string $parameterTypeName,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Group::fromArray($arr['group']),
			isset($arr['parameterTypeName']) ? (string) $arr['parameterTypeName'] : null,
    	);
    }
}


/**
 * Represents the StepMatchArgumentsList message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class StepMatchArgumentsList implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
         * @param list<StepMatchArgument> $stepMatchArguments
         */
        public readonly array $stepMatchArguments,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			array_map(fn(mixed $member) => StepMatchArgument::fromArray($member) , $arr['stepMatchArguments']),
    	);
    }
}


/**
 * Represents the TestStep message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A `TestStep` is derived from either a `PickleStep`
 * combined with a `StepDefinition`, or from a `Hook`. */
final class TestStep implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * Pointer to the `Hook` (if derived from a Hook)
         */
        public readonly ?string $hookId,

        public readonly string $id,

        /**
	     * Pointer to the `PickleStep` (if derived from a `PickleStep`)
         */
        public readonly ?string $pickleStepId,

        /**
	     * Pointer to all the matching `StepDefinition`s (if derived from a `PickleStep`)
         * @param ?list<string> $stepDefinitionIds
         */
        public readonly ?array $stepDefinitionIds,

        /**
	     * A list of list of StepMatchArgument (if derived from a `PickleStep`).
         * Each element represents a matching step definition. A size of 0 means `UNDEFINED`,
         * and a size of 2+ means `AMBIGUOUS`
         * @param ?list<StepMatchArgumentsList> $stepMatchArgumentsLists
         */
        public readonly ?array $stepMatchArgumentsLists,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			isset($arr['hookId']) ? (string) $arr['hookId'] : null,
			(string) $arr['id'],
			isset($arr['pickleStepId']) ? (string) $arr['pickleStepId'] : null,
			isset($arr['stepDefinitionIds']) ? array_map(fn(mixed $member) => (string) $member , $arr['stepDefinitionIds']) : null,
			isset($arr['stepMatchArgumentsLists']) ? array_map(fn(mixed $member) => StepMatchArgumentsList::fromArray($member) , $arr['stepMatchArgumentsLists']) : null,
    	);
    }
}


/**
 * Represents the TestCaseFinished message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestCaseFinished implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $testCaseStartedId,

        public readonly Timestamp $timestamp,

        public readonly bool $willBeRetried,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['testCaseStartedId'],
			Timestamp::fromArray($arr['timestamp']),
			(bool) $arr['willBeRetried'],
    	);
    }
}


/**
 * Represents the TestCaseStarted message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestCaseStarted implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * The first attempt should have value 0, and for each retry the value
         * should increase by 1.
         */
        public readonly int $attempt,

        /**
	     * Because a `TestCase` can be run multiple times (in case of a retry),
         * we use this field to group messages relating to the same attempt.
         */
        public readonly string $id,

        public readonly string $testCaseId,

        public readonly Timestamp $timestamp,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(int) $arr['attempt'],
			(string) $arr['id'],
			(string) $arr['testCaseId'],
			Timestamp::fromArray($arr['timestamp']),
    	);
    }
}


/**
 * Represents the TestRunFinished message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestRunFinished implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * Error message. Can be a stack trace from a failed `BeforeAll` or `AfterAll`.
         * If there are undefined parameter types, the message is simply
         * "The following parameter type(s() are not defined: xxx, yyy".
         * The independent `UndefinedParameterType` messages can be used to generate
         * snippets for those parameter types.
         */
        public readonly ?string $message,

        /**
	     * success = StrictModeEnabled ? (failed_count == 0 && ambiguous_count == 0 && undefined_count == 0 && pending_count == 0) : (failed_count == 0 && ambiguous_count == 0)
         */
        public readonly bool $success,

        /**
	     * Timestamp when the TestRun is finished
         */
        public readonly Timestamp $timestamp,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			isset($arr['message']) ? (string) $arr['message'] : null,
			(bool) $arr['success'],
			Timestamp::fromArray($arr['timestamp']),
    	);
    }
}


/**
 * Represents the TestRunStarted message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestRunStarted implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly Timestamp $timestamp,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Timestamp::fromArray($arr['timestamp']),
    	);
    }
}


/**
 * Represents the TestStepFinished message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestStepFinished implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $testCaseStartedId,

        public readonly string $testStepId,

        public readonly TestStepResult $testStepResult,

        public readonly Timestamp $timestamp,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['testCaseStartedId'],
			(string) $arr['testStepId'],
			TestStepResult::fromArray($arr['testStepResult']),
			Timestamp::fromArray($arr['timestamp']),
    	);
    }
}


/**
 * Represents the TestStepResult message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestStepResult implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly Duration $duration,

        public readonly ?string $message,

        public readonly TestStepResult\Status $status,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			Duration::fromArray($arr['duration']),
			isset($arr['message']) ? (string) $arr['message'] : null,
			TestStepResult\Status::from((string) $arr['status']),
    	);
    }
}


/**
 * Represents the TestStepStarted message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestStepStarted implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $testCaseStartedId,

        public readonly string $testStepId,

        public readonly Timestamp $timestamp,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['testCaseStartedId'],
			(string) $arr['testStepId'],
			Timestamp::fromArray($arr['timestamp']),
    	);
    }
}


/**
 * Represents the Timestamp message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Timestamp implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        /**
	     * Represents seconds of UTC time since Unix epoch
         * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
         * 9999-12-31T23:59:59Z inclusive.
         */
        public readonly int $seconds,

        /**
	     * Non-negative fractions of a second at nanosecond resolution. Negative
         * second values with fractions must still have non-negative nanos values
         * that count forward in time. Must be from 0 to 999,999,999
         * inclusive.
         */
        public readonly int $nanos,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(int) $arr['seconds'],
			(int) $arr['nanos'],
    	);
    }
}


/**
 * Represents the UndefinedParameterType message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class UndefinedParameterType implements JsonSerializable
{
	use JsonEncodingTrait;

    private function __construct(

        public readonly string $expression,

        public readonly string $name,

    ){}

    public static function fromArray(array $arr) : self
    {
    	return new self(
			(string) $arr['expression'],
			(string) $arr['name'],
    	);
    }
}


namespace Cucumber\Messages\Attachment;

enum ContentEncoding : string
{
  case IDENTITY = 'IDENTITY';
  case BASE64 = 'BASE64';
}


namespace Cucumber\Messages\Source;

enum MediaType : string
{
  case TEXT_X_CUCUMBER_GHERKIN_PLAIN = 'text/x.cucumber.gherkin+plain';
  case TEXT_X_CUCUMBER_GHERKIN_MARKDOWN = 'text/x.cucumber.gherkin+markdown';
}


namespace Cucumber\Messages\StepDefinitionPattern;

enum Type : string
{
  case CUCUMBER_EXPRESSION = 'CUCUMBER_EXPRESSION';
  case REGULAR_EXPRESSION = 'REGULAR_EXPRESSION';
}


namespace Cucumber\Messages\TestStepResult;

enum Status : string
{
  case UNKNOWN = 'UNKNOWN';
  case PASSED = 'PASSED';
  case SKIPPED = 'SKIPPED';
  case PENDING = 'PENDING';
  case UNDEFINED = 'UNDEFINED';
  case AMBIGUOUS = 'AMBIGUOUS';
  case FAILED = 'FAILED';
}


