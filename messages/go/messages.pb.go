// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: messages.proto

package messages

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Attachment_ContentEncoding int32

const (
	Attachment_IDENTITY Attachment_ContentEncoding = 0
	// When this is used, the data field is a single line base64 string
	Attachment_BASE64 Attachment_ContentEncoding = 1
)

var Attachment_ContentEncoding_name = map[int32]string{
	0: "IDENTITY",
	1: "BASE64",
}

var Attachment_ContentEncoding_value = map[string]int32{
	"IDENTITY": 0,
	"BASE64":   1,
}

func (x Attachment_ContentEncoding) String() string {
	return proto.EnumName(Attachment_ContentEncoding_name, int32(x))
}

func (Attachment_ContentEncoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{8, 0}
}

//*
// Status of a `TestStep`.
//
// The ordinal values of statuses are significant. The status of a TestCase
// is computed by picking the status with the highest value for all of its steps.
//
// For example, if a TestCase has steps with statuses passed, undefined and skipped,
// then the pickle's status is undefined.
type TestStepFinished_TestStepResult_Status int32

const (
	// The step hasn't been matched or executed.
	TestStepFinished_TestStepResult_UNKNOWN TestStepFinished_TestStepResult_Status = 0
	// The step matched one step definition and passed execution.
	TestStepFinished_TestStepResult_PASSED TestStepFinished_TestStepResult_Status = 1
	// The step matched one step definition but was not executed because the
	// previous step was not PASSED.
	TestStepFinished_TestStepResult_SKIPPED TestStepFinished_TestStepResult_Status = 2
	// The step matched one step definition and signalled pending during execution.
	// This is the default behaviour of generated step definitions, which either
	// throw a special PendingException, or return a special value indicating that it's
	// pending. How to signal the pending status depends on the Cucumber implementation.
	TestStepFinished_TestStepResult_PENDING TestStepFinished_TestStepResult_Status = 3
	// The step matched no step definitions.
	TestStepFinished_TestStepResult_UNDEFINED TestStepFinished_TestStepResult_Status = 4
	// The step matched two or more step definitions.
	TestStepFinished_TestStepResult_AMBIGUOUS TestStepFinished_TestStepResult_Status = 5
	// The step matched one step definition and failed execution.
	TestStepFinished_TestStepResult_FAILED TestStepFinished_TestStepResult_Status = 6
)

var TestStepFinished_TestStepResult_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "PASSED",
	2: "SKIPPED",
	3: "PENDING",
	4: "UNDEFINED",
	5: "AMBIGUOUS",
	6: "FAILED",
}

var TestStepFinished_TestStepResult_Status_value = map[string]int32{
	"UNKNOWN":   0,
	"PASSED":    1,
	"SKIPPED":   2,
	"PENDING":   3,
	"UNDEFINED": 4,
	"AMBIGUOUS": 5,
	"FAILED":    6,
}

func (x TestStepFinished_TestStepResult_Status) String() string {
	return proto.EnumName(TestStepFinished_TestStepResult_Status_name, int32(x))
}

func (TestStepFinished_TestStepResult_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{16, 0, 0}
}

type StepDefinition_StepDefinitionPattern_StepDefinitionPatternType int32

const (
	StepDefinition_StepDefinitionPattern_CUCUMBER_EXPRESSION StepDefinition_StepDefinitionPattern_StepDefinitionPatternType = 0
	StepDefinition_StepDefinitionPattern_REGULAR_EXPRESSION  StepDefinition_StepDefinitionPattern_StepDefinitionPatternType = 1
)

var StepDefinition_StepDefinitionPattern_StepDefinitionPatternType_name = map[int32]string{
	0: "CUCUMBER_EXPRESSION",
	1: "REGULAR_EXPRESSION",
}

var StepDefinition_StepDefinitionPattern_StepDefinitionPatternType_value = map[string]int32{
	"CUCUMBER_EXPRESSION": 0,
	"REGULAR_EXPRESSION":  1,
}

func (x StepDefinition_StepDefinitionPattern_StepDefinitionPatternType) String() string {
	return proto.EnumName(StepDefinition_StepDefinitionPattern_StepDefinitionPatternType_name, int32(x))
}

func (StepDefinition_StepDefinitionPattern_StepDefinitionPatternType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{19, 0, 0}
}

//*
// All the messages that are passed between different components/processes are Envelope
// messages.
type Envelope struct {
	// Types that are valid to be assigned to Message:
	//	*Envelope_Source
	//	*Envelope_GherkinDocument
	//	*Envelope_Pickle
	//	*Envelope_StepDefinition
	//	*Envelope_Hook
	//	*Envelope_ParameterType
	//	*Envelope_TestCase
	//	*Envelope_UndefinedParameterType
	//	*Envelope_TestRunStarted
	//	*Envelope_TestCaseStarted
	//	*Envelope_TestStepStarted
	//	*Envelope_Attachment
	//	*Envelope_TestStepFinished
	//	*Envelope_TestCaseFinished
	//	*Envelope_TestRunFinished
	//	*Envelope_ParseError
	//	*Envelope_Meta
	Message isEnvelope_Message `protobuf_oneof:"message"`
}

func (m *Envelope) Reset()         { *m = Envelope{} }
func (m *Envelope) String() string { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()    {}
func (*Envelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{0}
}
func (m *Envelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Envelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Envelope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Envelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Envelope.Merge(m, src)
}
func (m *Envelope) XXX_Size() int {
	return m.Size()
}
func (m *Envelope) XXX_DiscardUnknown() {
	xxx_messageInfo_Envelope.DiscardUnknown(m)
}

var xxx_messageInfo_Envelope proto.InternalMessageInfo

type isEnvelope_Message interface {
	isEnvelope_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Envelope_Source struct {
	Source *Source `protobuf:"bytes,1,opt,name=source,proto3,oneof" json:"source,omitempty"`
}
type Envelope_GherkinDocument struct {
	GherkinDocument *GherkinDocument `protobuf:"bytes,2,opt,name=gherkin_document,json=gherkinDocument,proto3,oneof" json:"gherkin_document,omitempty"`
}
type Envelope_Pickle struct {
	Pickle *Pickle `protobuf:"bytes,3,opt,name=pickle,proto3,oneof" json:"pickle,omitempty"`
}
type Envelope_StepDefinition struct {
	StepDefinition *StepDefinition `protobuf:"bytes,4,opt,name=step_definition,json=stepDefinition,proto3,oneof" json:"step_definition,omitempty"`
}
type Envelope_Hook struct {
	Hook *Hook `protobuf:"bytes,5,opt,name=hook,proto3,oneof" json:"hook,omitempty"`
}
type Envelope_ParameterType struct {
	ParameterType *ParameterType `protobuf:"bytes,6,opt,name=parameter_type,json=parameterType,proto3,oneof" json:"parameter_type,omitempty"`
}
type Envelope_TestCase struct {
	TestCase *TestCase `protobuf:"bytes,7,opt,name=test_case,json=testCase,proto3,oneof" json:"test_case,omitempty"`
}
type Envelope_UndefinedParameterType struct {
	UndefinedParameterType *UndefinedParameterType `protobuf:"bytes,8,opt,name=undefined_parameter_type,json=undefinedParameterType,proto3,oneof" json:"undefined_parameter_type,omitempty"`
}
type Envelope_TestRunStarted struct {
	TestRunStarted *TestRunStarted `protobuf:"bytes,9,opt,name=test_run_started,json=testRunStarted,proto3,oneof" json:"test_run_started,omitempty"`
}
type Envelope_TestCaseStarted struct {
	TestCaseStarted *TestCaseStarted `protobuf:"bytes,10,opt,name=test_case_started,json=testCaseStarted,proto3,oneof" json:"test_case_started,omitempty"`
}
type Envelope_TestStepStarted struct {
	TestStepStarted *TestStepStarted `protobuf:"bytes,11,opt,name=test_step_started,json=testStepStarted,proto3,oneof" json:"test_step_started,omitempty"`
}
type Envelope_Attachment struct {
	Attachment *Attachment `protobuf:"bytes,12,opt,name=attachment,proto3,oneof" json:"attachment,omitempty"`
}
type Envelope_TestStepFinished struct {
	TestStepFinished *TestStepFinished `protobuf:"bytes,13,opt,name=test_step_finished,json=testStepFinished,proto3,oneof" json:"test_step_finished,omitempty"`
}
type Envelope_TestCaseFinished struct {
	TestCaseFinished *TestCaseFinished `protobuf:"bytes,14,opt,name=test_case_finished,json=testCaseFinished,proto3,oneof" json:"test_case_finished,omitempty"`
}
type Envelope_TestRunFinished struct {
	TestRunFinished *TestRunFinished `protobuf:"bytes,15,opt,name=test_run_finished,json=testRunFinished,proto3,oneof" json:"test_run_finished,omitempty"`
}
type Envelope_ParseError struct {
	ParseError *ParseError `protobuf:"bytes,16,opt,name=parse_error,json=parseError,proto3,oneof" json:"parse_error,omitempty"`
}
type Envelope_Meta struct {
	Meta *Meta `protobuf:"bytes,17,opt,name=meta,proto3,oneof" json:"meta,omitempty"`
}

func (*Envelope_Source) isEnvelope_Message()                 {}
func (*Envelope_GherkinDocument) isEnvelope_Message()        {}
func (*Envelope_Pickle) isEnvelope_Message()                 {}
func (*Envelope_StepDefinition) isEnvelope_Message()         {}
func (*Envelope_Hook) isEnvelope_Message()                   {}
func (*Envelope_ParameterType) isEnvelope_Message()          {}
func (*Envelope_TestCase) isEnvelope_Message()               {}
func (*Envelope_UndefinedParameterType) isEnvelope_Message() {}
func (*Envelope_TestRunStarted) isEnvelope_Message()         {}
func (*Envelope_TestCaseStarted) isEnvelope_Message()        {}
func (*Envelope_TestStepStarted) isEnvelope_Message()        {}
func (*Envelope_Attachment) isEnvelope_Message()             {}
func (*Envelope_TestStepFinished) isEnvelope_Message()       {}
func (*Envelope_TestCaseFinished) isEnvelope_Message()       {}
func (*Envelope_TestRunFinished) isEnvelope_Message()        {}
func (*Envelope_ParseError) isEnvelope_Message()             {}
func (*Envelope_Meta) isEnvelope_Message()                   {}

func (m *Envelope) GetMessage() isEnvelope_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Envelope) GetSource() *Source {
	if x, ok := m.GetMessage().(*Envelope_Source); ok {
		return x.Source
	}
	return nil
}

func (m *Envelope) GetGherkinDocument() *GherkinDocument {
	if x, ok := m.GetMessage().(*Envelope_GherkinDocument); ok {
		return x.GherkinDocument
	}
	return nil
}

func (m *Envelope) GetPickle() *Pickle {
	if x, ok := m.GetMessage().(*Envelope_Pickle); ok {
		return x.Pickle
	}
	return nil
}

func (m *Envelope) GetStepDefinition() *StepDefinition {
	if x, ok := m.GetMessage().(*Envelope_StepDefinition); ok {
		return x.StepDefinition
	}
	return nil
}

func (m *Envelope) GetHook() *Hook {
	if x, ok := m.GetMessage().(*Envelope_Hook); ok {
		return x.Hook
	}
	return nil
}

func (m *Envelope) GetParameterType() *ParameterType {
	if x, ok := m.GetMessage().(*Envelope_ParameterType); ok {
		return x.ParameterType
	}
	return nil
}

func (m *Envelope) GetTestCase() *TestCase {
	if x, ok := m.GetMessage().(*Envelope_TestCase); ok {
		return x.TestCase
	}
	return nil
}

func (m *Envelope) GetUndefinedParameterType() *UndefinedParameterType {
	if x, ok := m.GetMessage().(*Envelope_UndefinedParameterType); ok {
		return x.UndefinedParameterType
	}
	return nil
}

func (m *Envelope) GetTestRunStarted() *TestRunStarted {
	if x, ok := m.GetMessage().(*Envelope_TestRunStarted); ok {
		return x.TestRunStarted
	}
	return nil
}

func (m *Envelope) GetTestCaseStarted() *TestCaseStarted {
	if x, ok := m.GetMessage().(*Envelope_TestCaseStarted); ok {
		return x.TestCaseStarted
	}
	return nil
}

func (m *Envelope) GetTestStepStarted() *TestStepStarted {
	if x, ok := m.GetMessage().(*Envelope_TestStepStarted); ok {
		return x.TestStepStarted
	}
	return nil
}

func (m *Envelope) GetAttachment() *Attachment {
	if x, ok := m.GetMessage().(*Envelope_Attachment); ok {
		return x.Attachment
	}
	return nil
}

func (m *Envelope) GetTestStepFinished() *TestStepFinished {
	if x, ok := m.GetMessage().(*Envelope_TestStepFinished); ok {
		return x.TestStepFinished
	}
	return nil
}

func (m *Envelope) GetTestCaseFinished() *TestCaseFinished {
	if x, ok := m.GetMessage().(*Envelope_TestCaseFinished); ok {
		return x.TestCaseFinished
	}
	return nil
}

func (m *Envelope) GetTestRunFinished() *TestRunFinished {
	if x, ok := m.GetMessage().(*Envelope_TestRunFinished); ok {
		return x.TestRunFinished
	}
	return nil
}

func (m *Envelope) GetParseError() *ParseError {
	if x, ok := m.GetMessage().(*Envelope_ParseError); ok {
		return x.ParseError
	}
	return nil
}

func (m *Envelope) GetMeta() *Meta {
	if x, ok := m.GetMessage().(*Envelope_Meta); ok {
		return x.Meta
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Envelope) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Envelope_Source)(nil),
		(*Envelope_GherkinDocument)(nil),
		(*Envelope_Pickle)(nil),
		(*Envelope_StepDefinition)(nil),
		(*Envelope_Hook)(nil),
		(*Envelope_ParameterType)(nil),
		(*Envelope_TestCase)(nil),
		(*Envelope_UndefinedParameterType)(nil),
		(*Envelope_TestRunStarted)(nil),
		(*Envelope_TestCaseStarted)(nil),
		(*Envelope_TestStepStarted)(nil),
		(*Envelope_Attachment)(nil),
		(*Envelope_TestStepFinished)(nil),
		(*Envelope_TestCaseFinished)(nil),
		(*Envelope_TestRunFinished)(nil),
		(*Envelope_ParseError)(nil),
		(*Envelope_Meta)(nil),
	}
}

//*
// This message contains meta information about the environment. Consumers can use
// this for various purposes.
type Meta struct {
	//*
	// The [SEMVER](https://semver.org/) version number of the protocol
	ProtocolVersion string `protobuf:"bytes,1,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	// SpecFlow, Cucumber-JVM, Cucumber.js, Cucumber-Ruby, Behat etc.
	Implementation *Meta_Product `protobuf:"bytes,2,opt,name=implementation,proto3" json:"implementation,omitempty"`
	// Java, Ruby, Node.js etc
	Runtime *Meta_Product `protobuf:"bytes,3,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// Windows, Linux, MacOS etc
	Os *Meta_Product `protobuf:"bytes,4,opt,name=os,proto3" json:"os,omitempty"`
	// 386, arm, amd64 etc
	Cpu *Meta_Product `protobuf:"bytes,5,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// CI environment
	Ci *Meta_CI `protobuf:"bytes,6,opt,name=ci,proto3" json:"ci,omitempty"`
}

func (m *Meta) Reset()         { *m = Meta{} }
func (m *Meta) String() string { return proto.CompactTextString(m) }
func (*Meta) ProtoMessage()    {}
func (*Meta) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{1}
}
func (m *Meta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Meta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Meta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Meta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Meta.Merge(m, src)
}
func (m *Meta) XXX_Size() int {
	return m.Size()
}
func (m *Meta) XXX_DiscardUnknown() {
	xxx_messageInfo_Meta.DiscardUnknown(m)
}

var xxx_messageInfo_Meta proto.InternalMessageInfo

func (m *Meta) GetProtocolVersion() string {
	if m != nil {
		return m.ProtocolVersion
	}
	return ""
}

func (m *Meta) GetImplementation() *Meta_Product {
	if m != nil {
		return m.Implementation
	}
	return nil
}

func (m *Meta) GetRuntime() *Meta_Product {
	if m != nil {
		return m.Runtime
	}
	return nil
}

func (m *Meta) GetOs() *Meta_Product {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *Meta) GetCpu() *Meta_Product {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *Meta) GetCi() *Meta_CI {
	if m != nil {
		return m.Ci
	}
	return nil
}

// A product has a name and a version
type Meta_Product struct {
	// The product name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The product version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *Meta_Product) Reset()         { *m = Meta_Product{} }
func (m *Meta_Product) String() string { return proto.CompactTextString(m) }
func (*Meta_Product) ProtoMessage()    {}
func (*Meta_Product) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{1, 0}
}
func (m *Meta_Product) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Meta_Product) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Meta_Product.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Meta_Product) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Meta_Product.Merge(m, src)
}
func (m *Meta_Product) XXX_Size() int {
	return m.Size()
}
func (m *Meta_Product) XXX_DiscardUnknown() {
	xxx_messageInfo_Meta_Product.DiscardUnknown(m)
}

var xxx_messageInfo_Meta_Product proto.InternalMessageInfo

func (m *Meta_Product) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Meta_Product) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type Meta_CI struct {
	// Name of the CI product, e.g. "Jenkins", "CircleCI" etc.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Link to the build
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Information about Git, provided by the Build/CI server as environment
	// variables.
	Git *Meta_CI_Git `protobuf:"bytes,3,opt,name=git,proto3" json:"git,omitempty"`
}

func (m *Meta_CI) Reset()         { *m = Meta_CI{} }
func (m *Meta_CI) String() string { return proto.CompactTextString(m) }
func (*Meta_CI) ProtoMessage()    {}
func (*Meta_CI) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{1, 1}
}
func (m *Meta_CI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Meta_CI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Meta_CI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Meta_CI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Meta_CI.Merge(m, src)
}
func (m *Meta_CI) XXX_Size() int {
	return m.Size()
}
func (m *Meta_CI) XXX_DiscardUnknown() {
	xxx_messageInfo_Meta_CI.DiscardUnknown(m)
}

var xxx_messageInfo_Meta_CI proto.InternalMessageInfo

func (m *Meta_CI) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Meta_CI) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Meta_CI) GetGit() *Meta_CI_Git {
	if m != nil {
		return m.Git
	}
	return nil
}

type Meta_CI_Git struct {
	Remote   string `protobuf:"bytes,1,opt,name=remote,proto3" json:"remote,omitempty"`
	Revision string `protobuf:"bytes,2,opt,name=revision,proto3" json:"revision,omitempty"`
	Branch   string `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Tag      string `protobuf:"bytes,4,opt,name=tag,proto3" json:"tag,omitempty"`
}

func (m *Meta_CI_Git) Reset()         { *m = Meta_CI_Git{} }
func (m *Meta_CI_Git) String() string { return proto.CompactTextString(m) }
func (*Meta_CI_Git) ProtoMessage()    {}
func (*Meta_CI_Git) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{1, 1, 0}
}
func (m *Meta_CI_Git) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Meta_CI_Git) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Meta_CI_Git.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Meta_CI_Git) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Meta_CI_Git.Merge(m, src)
}
func (m *Meta_CI_Git) XXX_Size() int {
	return m.Size()
}
func (m *Meta_CI_Git) XXX_DiscardUnknown() {
	xxx_messageInfo_Meta_CI_Git.DiscardUnknown(m)
}

var xxx_messageInfo_Meta_CI_Git proto.InternalMessageInfo

func (m *Meta_CI_Git) GetRemote() string {
	if m != nil {
		return m.Remote
	}
	return ""
}

func (m *Meta_CI_Git) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *Meta_CI_Git) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *Meta_CI_Git) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

// From https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/timestamp.proto
type Timestamp struct {
	// Represents seconds of UTC time since Unix epoch
	// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	// 9999-12-31T23:59:59Z inclusive.
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive.
	Nanos int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
}

func (m *Timestamp) Reset()         { *m = Timestamp{} }
func (m *Timestamp) String() string { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()    {}
func (*Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{2}
}
func (m *Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timestamp.Merge(m, src)
}
func (m *Timestamp) XXX_Size() int {
	return m.Size()
}
func (m *Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Timestamp proto.InternalMessageInfo

func (m *Timestamp) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Timestamp) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

// The structure is pretty close of the Timestamp one. For clarity, a second type
// of message is used.
type Duration struct {
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive.
	Nanos int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
}

func (m *Duration) Reset()         { *m = Duration{} }
func (m *Duration) String() string { return proto.CompactTextString(m) }
func (*Duration) ProtoMessage()    {}
func (*Duration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{3}
}
func (m *Duration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Duration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Duration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Duration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Duration.Merge(m, src)
}
func (m *Duration) XXX_Size() int {
	return m.Size()
}
func (m *Duration) XXX_DiscardUnknown() {
	xxx_messageInfo_Duration.DiscardUnknown(m)
}

var xxx_messageInfo_Duration proto.InternalMessageInfo

func (m *Duration) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Duration) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

//*
// Points to a line and a column in a text file
type Location struct {
	Line   uint32 `protobuf:"varint,1,opt,name=line,proto3" json:"line,omitempty"`
	Column uint32 `protobuf:"varint,2,opt,name=column,proto3" json:"column,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{4}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetLine() uint32 {
	if m != nil {
		return m.Line
	}
	return 0
}

func (m *Location) GetColumn() uint32 {
	if m != nil {
		return m.Column
	}
	return 0
}

//*
// Points to a [Source](#io.cucumber.messages.Source) identified by `uri` and a
// [Location](#io.cucumber.messages.Location) within that file.
type SourceReference struct {
	// Types that are valid to be assigned to Reference:
	//	*SourceReference_Uri
	//	*SourceReference_JavaMethod_
	//	*SourceReference_JavaStackTraceElement_
	Reference isSourceReference_Reference `protobuf_oneof:"reference"`
	Location  *Location                   `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *SourceReference) Reset()         { *m = SourceReference{} }
func (m *SourceReference) String() string { return proto.CompactTextString(m) }
func (*SourceReference) ProtoMessage()    {}
func (*SourceReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{5}
}
func (m *SourceReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceReference.Merge(m, src)
}
func (m *SourceReference) XXX_Size() int {
	return m.Size()
}
func (m *SourceReference) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceReference.DiscardUnknown(m)
}

var xxx_messageInfo_SourceReference proto.InternalMessageInfo

type isSourceReference_Reference interface {
	isSourceReference_Reference()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SourceReference_Uri struct {
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3,oneof" json:"uri,omitempty"`
}
type SourceReference_JavaMethod_ struct {
	JavaMethod *SourceReference_JavaMethod `protobuf:"bytes,3,opt,name=java_method,json=javaMethod,proto3,oneof" json:"java_method,omitempty"`
}
type SourceReference_JavaStackTraceElement_ struct {
	JavaStackTraceElement *SourceReference_JavaStackTraceElement `protobuf:"bytes,4,opt,name=java_stack_trace_element,json=javaStackTraceElement,proto3,oneof" json:"java_stack_trace_element,omitempty"`
}

func (*SourceReference_Uri) isSourceReference_Reference()                    {}
func (*SourceReference_JavaMethod_) isSourceReference_Reference()            {}
func (*SourceReference_JavaStackTraceElement_) isSourceReference_Reference() {}

func (m *SourceReference) GetReference() isSourceReference_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *SourceReference) GetUri() string {
	if x, ok := m.GetReference().(*SourceReference_Uri); ok {
		return x.Uri
	}
	return ""
}

func (m *SourceReference) GetJavaMethod() *SourceReference_JavaMethod {
	if x, ok := m.GetReference().(*SourceReference_JavaMethod_); ok {
		return x.JavaMethod
	}
	return nil
}

func (m *SourceReference) GetJavaStackTraceElement() *SourceReference_JavaStackTraceElement {
	if x, ok := m.GetReference().(*SourceReference_JavaStackTraceElement_); ok {
		return x.JavaStackTraceElement
	}
	return nil
}

func (m *SourceReference) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SourceReference) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SourceReference_Uri)(nil),
		(*SourceReference_JavaMethod_)(nil),
		(*SourceReference_JavaStackTraceElement_)(nil),
	}
}

type SourceReference_JavaMethod struct {
	ClassName            string   `protobuf:"bytes,1,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	MethodName           string   `protobuf:"bytes,2,opt,name=method_name,json=methodName,proto3" json:"method_name,omitempty"`
	MethodParameterTypes []string `protobuf:"bytes,3,rep,name=method_parameter_types,json=methodParameterTypes,proto3" json:"method_parameter_types,omitempty"`
}

func (m *SourceReference_JavaMethod) Reset()         { *m = SourceReference_JavaMethod{} }
func (m *SourceReference_JavaMethod) String() string { return proto.CompactTextString(m) }
func (*SourceReference_JavaMethod) ProtoMessage()    {}
func (*SourceReference_JavaMethod) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{5, 0}
}
func (m *SourceReference_JavaMethod) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceReference_JavaMethod) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceReference_JavaMethod.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceReference_JavaMethod) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceReference_JavaMethod.Merge(m, src)
}
func (m *SourceReference_JavaMethod) XXX_Size() int {
	return m.Size()
}
func (m *SourceReference_JavaMethod) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceReference_JavaMethod.DiscardUnknown(m)
}

var xxx_messageInfo_SourceReference_JavaMethod proto.InternalMessageInfo

func (m *SourceReference_JavaMethod) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *SourceReference_JavaMethod) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

func (m *SourceReference_JavaMethod) GetMethodParameterTypes() []string {
	if m != nil {
		return m.MethodParameterTypes
	}
	return nil
}

type SourceReference_JavaStackTraceElement struct {
	ClassName  string `protobuf:"bytes,1,opt,name=class_name,json=className,proto3" json:"class_name,omitempty"`
	MethodName string `protobuf:"bytes,2,opt,name=method_name,json=methodName,proto3" json:"method_name,omitempty"`
	FileName   string `protobuf:"bytes,3,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
}

func (m *SourceReference_JavaStackTraceElement) Reset()         { *m = SourceReference_JavaStackTraceElement{} }
func (m *SourceReference_JavaStackTraceElement) String() string { return proto.CompactTextString(m) }
func (*SourceReference_JavaStackTraceElement) ProtoMessage()    {}
func (*SourceReference_JavaStackTraceElement) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{5, 1}
}
func (m *SourceReference_JavaStackTraceElement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceReference_JavaStackTraceElement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceReference_JavaStackTraceElement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceReference_JavaStackTraceElement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceReference_JavaStackTraceElement.Merge(m, src)
}
func (m *SourceReference_JavaStackTraceElement) XXX_Size() int {
	return m.Size()
}
func (m *SourceReference_JavaStackTraceElement) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceReference_JavaStackTraceElement.DiscardUnknown(m)
}

var xxx_messageInfo_SourceReference_JavaStackTraceElement proto.InternalMessageInfo

func (m *SourceReference_JavaStackTraceElement) GetClassName() string {
	if m != nil {
		return m.ClassName
	}
	return ""
}

func (m *SourceReference_JavaStackTraceElement) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

func (m *SourceReference_JavaStackTraceElement) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

//*
// A source file, typically a Gherkin document or Java/Ruby/JavaScript source code
type Source struct {
	//*
	// The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
	// of the source, typically a file path relative to the root directory
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// The contents of the file
	Data string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// The media type of the file. Can be used to specify custom types, such as
	// text/x.cucumber.gherkin+plain
	MediaType string `protobuf:"bytes,3,opt,name=media_type,json=mediaType,proto3" json:"media_type,omitempty"`
}

func (m *Source) Reset()         { *m = Source{} }
func (m *Source) String() string { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()    {}
func (*Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{6}
}
func (m *Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Source.Merge(m, src)
}
func (m *Source) XXX_Size() int {
	return m.Size()
}
func (m *Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Source proto.InternalMessageInfo

func (m *Source) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Source) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Source) GetMediaType() string {
	if m != nil {
		return m.MediaType
	}
	return ""
}

//*
// The [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) of a Gherkin document.
// Cucumber implementations should *not* depend on `GherkinDocument` or any of its
// children for execution - use [Pickle](#io.cucumber.messages.Pickle) instead.
//
// The only consumers of `GherkinDocument` should only be formatters that produce
// "rich" output, resembling the original Gherkin document.
type GherkinDocument struct {
	//*
	// The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
	// of the source, typically a file path relative to the root directory
	Uri     string                   `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Feature *GherkinDocument_Feature `protobuf:"bytes,2,opt,name=feature,proto3" json:"feature,omitempty"`
	// All the comments in the Gherkin document
	Comments []*GherkinDocument_Comment `protobuf:"bytes,3,rep,name=comments,proto3" json:"comments,omitempty"`
}

func (m *GherkinDocument) Reset()         { *m = GherkinDocument{} }
func (m *GherkinDocument) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument) ProtoMessage()    {}
func (*GherkinDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7}
}
func (m *GherkinDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument.Merge(m, src)
}
func (m *GherkinDocument) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument proto.InternalMessageInfo

func (m *GherkinDocument) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *GherkinDocument) GetFeature() *GherkinDocument_Feature {
	if m != nil {
		return m.Feature
	}
	return nil
}

func (m *GherkinDocument) GetComments() []*GherkinDocument_Comment {
	if m != nil {
		return m.Comments
	}
	return nil
}

//*
// A comment in a Gherkin document
type GherkinDocument_Comment struct {
	// The location of the comment
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// The text of the comment
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *GherkinDocument_Comment) Reset()         { *m = GherkinDocument_Comment{} }
func (m *GherkinDocument_Comment) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Comment) ProtoMessage()    {}
func (*GherkinDocument_Comment) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 0}
}
func (m *GherkinDocument_Comment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Comment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Comment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Comment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Comment.Merge(m, src)
}
func (m *GherkinDocument_Comment) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Comment) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Comment.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Comment proto.InternalMessageInfo

func (m *GherkinDocument_Comment) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Comment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

//*
// The top level node in the AST
type GherkinDocument_Feature struct {
	// The location of the `Feature` keyword
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// All the tags placed above the `Feature` keyword
	Tags []*GherkinDocument_Feature_Tag `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	// The [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code of the Gherkin document
	Language string `protobuf:"bytes,3,opt,name=language,proto3" json:"language,omitempty"`
	// The text of the `Feature` keyword (in the language specified by `language`)
	Keyword string `protobuf:"bytes,4,opt,name=keyword,proto3" json:"keyword,omitempty"`
	// The name of the feature (the text following the `keyword`)
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// The line(s) underneath the line with the `keyword` that are used as description
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// Zero or more children
	Children []*GherkinDocument_Feature_FeatureChild `protobuf:"bytes,7,rep,name=children,proto3" json:"children,omitempty"`
}

func (m *GherkinDocument_Feature) Reset()         { *m = GherkinDocument_Feature{} }
func (m *GherkinDocument_Feature) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature) ProtoMessage()    {}
func (*GherkinDocument_Feature) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1}
}
func (m *GherkinDocument_Feature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature.Merge(m, src)
}
func (m *GherkinDocument_Feature) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature proto.InternalMessageInfo

func (m *GherkinDocument_Feature) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature) GetTags() []*GherkinDocument_Feature_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GherkinDocument_Feature) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *GherkinDocument_Feature) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature) GetChildren() []*GherkinDocument_Feature_FeatureChild {
	if m != nil {
		return m.Children
	}
	return nil
}

//*
// A tag
type GherkinDocument_Feature_Tag struct {
	// Location of the tag
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// The name of the tag (including the leading `@`)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Unique ID to be able to reference the Tag from PickleTag
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GherkinDocument_Feature_Tag) Reset()         { *m = GherkinDocument_Feature_Tag{} }
func (m *GherkinDocument_Feature_Tag) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Tag) ProtoMessage()    {}
func (*GherkinDocument_Feature_Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 0}
}
func (m *GherkinDocument_Feature_Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Tag.Merge(m, src)
}
func (m *GherkinDocument_Feature_Tag) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Tag proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Tag) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Tag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_Tag) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

//*
// A child node of a `Feature` node
type GherkinDocument_Feature_FeatureChild struct {
	// Types that are valid to be assigned to Value:
	//	*GherkinDocument_Feature_FeatureChild_Rule_
	//	*GherkinDocument_Feature_FeatureChild_Background
	//	*GherkinDocument_Feature_FeatureChild_Scenario
	Value isGherkinDocument_Feature_FeatureChild_Value `protobuf_oneof:"value"`
}

func (m *GherkinDocument_Feature_FeatureChild) Reset()         { *m = GherkinDocument_Feature_FeatureChild{} }
func (m *GherkinDocument_Feature_FeatureChild) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_FeatureChild) ProtoMessage()    {}
func (*GherkinDocument_Feature_FeatureChild) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 1}
}
func (m *GherkinDocument_Feature_FeatureChild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_FeatureChild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_FeatureChild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_FeatureChild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild.Merge(m, src)
}
func (m *GherkinDocument_Feature_FeatureChild) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_FeatureChild) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_FeatureChild proto.InternalMessageInfo

type isGherkinDocument_Feature_FeatureChild_Value interface {
	isGherkinDocument_Feature_FeatureChild_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GherkinDocument_Feature_FeatureChild_Rule_ struct {
	Rule *GherkinDocument_Feature_FeatureChild_Rule `protobuf:"bytes,1,opt,name=rule,proto3,oneof" json:"rule,omitempty"`
}
type GherkinDocument_Feature_FeatureChild_Background struct {
	Background *GherkinDocument_Feature_Background `protobuf:"bytes,2,opt,name=background,proto3,oneof" json:"background,omitempty"`
}
type GherkinDocument_Feature_FeatureChild_Scenario struct {
	Scenario *GherkinDocument_Feature_Scenario `protobuf:"bytes,3,opt,name=scenario,proto3,oneof" json:"scenario,omitempty"`
}

func (*GherkinDocument_Feature_FeatureChild_Rule_) isGherkinDocument_Feature_FeatureChild_Value() {}
func (*GherkinDocument_Feature_FeatureChild_Background) isGherkinDocument_Feature_FeatureChild_Value() {
}
func (*GherkinDocument_Feature_FeatureChild_Scenario) isGherkinDocument_Feature_FeatureChild_Value() {}

func (m *GherkinDocument_Feature_FeatureChild) GetValue() isGherkinDocument_Feature_FeatureChild_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild) GetRule() *GherkinDocument_Feature_FeatureChild_Rule {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_Rule_); ok {
		return x.Rule
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild) GetBackground() *GherkinDocument_Feature_Background {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_Background); ok {
		return x.Background
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild) GetScenario() *GherkinDocument_Feature_Scenario {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_Scenario); ok {
		return x.Scenario
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GherkinDocument_Feature_FeatureChild) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GherkinDocument_Feature_FeatureChild_Rule_)(nil),
		(*GherkinDocument_Feature_FeatureChild_Background)(nil),
		(*GherkinDocument_Feature_FeatureChild_Scenario)(nil),
	}
}

//*
// A `Rule` node
type GherkinDocument_Feature_FeatureChild_Rule struct {
	// The location of the `Rule` keyword
	Location    *Location                                         `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Keyword     string                                            `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                                            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description string                                            `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Children    []*GherkinDocument_Feature_FeatureChild_RuleChild `protobuf:"bytes,5,rep,name=children,proto3" json:"children,omitempty"`
	Id          string                                            `protobuf:"bytes,6,opt,name=id,proto3" json:"id,omitempty"`
	Tags        []*GherkinDocument_Feature_Tag                    `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) Reset() {
	*m = GherkinDocument_Feature_FeatureChild_Rule{}
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_FeatureChild_Rule) ProtoMessage()    {}
func (*GherkinDocument_Feature_FeatureChild_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 1, 0}
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_FeatureChild_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild_Rule.Merge(m, src)
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_FeatureChild_Rule proto.InternalMessageInfo

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetChildren() []*GherkinDocument_Feature_FeatureChild_RuleChild {
	if m != nil {
		return m.Children
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetTags() []*GherkinDocument_Feature_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

type GherkinDocument_Feature_FeatureChild_RuleChild struct {
	// Types that are valid to be assigned to Value:
	//	*GherkinDocument_Feature_FeatureChild_RuleChild_Background
	//	*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario
	Value isGherkinDocument_Feature_FeatureChild_RuleChild_Value `protobuf_oneof:"value"`
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Reset() {
	*m = GherkinDocument_Feature_FeatureChild_RuleChild{}
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) String() string {
	return proto.CompactTextString(m)
}
func (*GherkinDocument_Feature_FeatureChild_RuleChild) ProtoMessage() {}
func (*GherkinDocument_Feature_FeatureChild_RuleChild) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 1, 1}
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_FeatureChild_RuleChild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild_RuleChild.Merge(m, src)
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild_RuleChild.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_FeatureChild_RuleChild proto.InternalMessageInfo

type isGherkinDocument_Feature_FeatureChild_RuleChild_Value interface {
	isGherkinDocument_Feature_FeatureChild_RuleChild_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GherkinDocument_Feature_FeatureChild_RuleChild_Background struct {
	Background *GherkinDocument_Feature_Background `protobuf:"bytes,1,opt,name=background,proto3,oneof" json:"background,omitempty"`
}
type GherkinDocument_Feature_FeatureChild_RuleChild_Scenario struct {
	Scenario *GherkinDocument_Feature_Scenario `protobuf:"bytes,2,opt,name=scenario,proto3,oneof" json:"scenario,omitempty"`
}

func (*GherkinDocument_Feature_FeatureChild_RuleChild_Background) isGherkinDocument_Feature_FeatureChild_RuleChild_Value() {
}
func (*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) isGherkinDocument_Feature_FeatureChild_RuleChild_Value() {
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) GetValue() isGherkinDocument_Feature_FeatureChild_RuleChild_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) GetBackground() *GherkinDocument_Feature_Background {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_RuleChild_Background); ok {
		return x.Background
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) GetScenario() *GherkinDocument_Feature_Scenario {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario); ok {
		return x.Scenario
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GherkinDocument_Feature_FeatureChild_RuleChild) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GherkinDocument_Feature_FeatureChild_RuleChild_Background)(nil),
		(*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario)(nil),
	}
}

type GherkinDocument_Feature_Background struct {
	// The location of the `Background` keyword
	Location    *Location                       `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Keyword     string                          `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                          `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description string                          `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Steps       []*GherkinDocument_Feature_Step `protobuf:"bytes,5,rep,name=steps,proto3" json:"steps,omitempty"`
	Id          string                          `protobuf:"bytes,6,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GherkinDocument_Feature_Background) Reset()         { *m = GherkinDocument_Feature_Background{} }
func (m *GherkinDocument_Feature_Background) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Background) ProtoMessage()    {}
func (*GherkinDocument_Feature_Background) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 2}
}
func (m *GherkinDocument_Feature_Background) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Background) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Background.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Background) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Background.Merge(m, src)
}
func (m *GherkinDocument_Feature_Background) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Background) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Background.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Background proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Background) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Background) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Background) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_Background) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_Background) GetSteps() []*GherkinDocument_Feature_Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *GherkinDocument_Feature_Background) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type GherkinDocument_Feature_Scenario struct {
	// The location of the `Scenario` keyword
	Location    *Location                                    `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Tags        []*GherkinDocument_Feature_Tag               `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	Keyword     string                                       `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                                       `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Description string                                       `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Steps       []*GherkinDocument_Feature_Step              `protobuf:"bytes,6,rep,name=steps,proto3" json:"steps,omitempty"`
	Examples    []*GherkinDocument_Feature_Scenario_Examples `protobuf:"bytes,7,rep,name=examples,proto3" json:"examples,omitempty"`
	Id          string                                       `protobuf:"bytes,8,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GherkinDocument_Feature_Scenario) Reset()         { *m = GherkinDocument_Feature_Scenario{} }
func (m *GherkinDocument_Feature_Scenario) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Scenario) ProtoMessage()    {}
func (*GherkinDocument_Feature_Scenario) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 3}
}
func (m *GherkinDocument_Feature_Scenario) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Scenario) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Scenario.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Scenario) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Scenario.Merge(m, src)
}
func (m *GherkinDocument_Feature_Scenario) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Scenario) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Scenario.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Scenario proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Scenario) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetTags() []*GherkinDocument_Feature_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario) GetSteps() []*GherkinDocument_Feature_Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetExamples() []*GherkinDocument_Feature_Scenario_Examples {
	if m != nil {
		return m.Examples
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type GherkinDocument_Feature_Scenario_Examples struct {
	// The location of the `Examples` keyword
	Location    *Location                           `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Tags        []*GherkinDocument_Feature_Tag      `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	Keyword     string                              `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                              `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Description string                              `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	TableHeader *GherkinDocument_Feature_TableRow   `protobuf:"bytes,6,opt,name=table_header,json=tableHeader,proto3" json:"table_header,omitempty"`
	TableBody   []*GherkinDocument_Feature_TableRow `protobuf:"bytes,7,rep,name=table_body,json=tableBody,proto3" json:"table_body,omitempty"`
	Id          string                              `protobuf:"bytes,8,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GherkinDocument_Feature_Scenario_Examples) Reset() {
	*m = GherkinDocument_Feature_Scenario_Examples{}
}
func (m *GherkinDocument_Feature_Scenario_Examples) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Scenario_Examples) ProtoMessage()    {}
func (*GherkinDocument_Feature_Scenario_Examples) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 3, 0}
}
func (m *GherkinDocument_Feature_Scenario_Examples) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Scenario_Examples) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Scenario_Examples.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Scenario_Examples) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Scenario_Examples.Merge(m, src)
}
func (m *GherkinDocument_Feature_Scenario_Examples) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Scenario_Examples) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Scenario_Examples.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Scenario_Examples proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Scenario_Examples) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetTags() []*GherkinDocument_Feature_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetTableHeader() *GherkinDocument_Feature_TableRow {
	if m != nil {
		return m.TableHeader
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetTableBody() []*GherkinDocument_Feature_TableRow {
	if m != nil {
		return m.TableBody
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// A row in a table
type GherkinDocument_Feature_TableRow struct {
	// The location of the first cell in the row
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// Cells in the row
	Cells []*GherkinDocument_Feature_TableRow_TableCell `protobuf:"bytes,2,rep,name=cells,proto3" json:"cells,omitempty"`
	Id    string                                        `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GherkinDocument_Feature_TableRow) Reset()         { *m = GherkinDocument_Feature_TableRow{} }
func (m *GherkinDocument_Feature_TableRow) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_TableRow) ProtoMessage()    {}
func (*GherkinDocument_Feature_TableRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 4}
}
func (m *GherkinDocument_Feature_TableRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_TableRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_TableRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_TableRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_TableRow.Merge(m, src)
}
func (m *GherkinDocument_Feature_TableRow) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_TableRow) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_TableRow.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_TableRow proto.InternalMessageInfo

func (m *GherkinDocument_Feature_TableRow) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_TableRow) GetCells() []*GherkinDocument_Feature_TableRow_TableCell {
	if m != nil {
		return m.Cells
	}
	return nil
}

func (m *GherkinDocument_Feature_TableRow) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// A cell in a `TableRow`
type GherkinDocument_Feature_TableRow_TableCell struct {
	// The location of the cell
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// The value of the cell
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GherkinDocument_Feature_TableRow_TableCell) Reset() {
	*m = GherkinDocument_Feature_TableRow_TableCell{}
}
func (m *GherkinDocument_Feature_TableRow_TableCell) String() string {
	return proto.CompactTextString(m)
}
func (*GherkinDocument_Feature_TableRow_TableCell) ProtoMessage() {}
func (*GherkinDocument_Feature_TableRow_TableCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 4, 0}
}
func (m *GherkinDocument_Feature_TableRow_TableCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_TableRow_TableCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_TableRow_TableCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_TableRow_TableCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_TableRow_TableCell.Merge(m, src)
}
func (m *GherkinDocument_Feature_TableRow_TableCell) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_TableRow_TableCell) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_TableRow_TableCell.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_TableRow_TableCell proto.InternalMessageInfo

func (m *GherkinDocument_Feature_TableRow_TableCell) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_TableRow_TableCell) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A step
type GherkinDocument_Feature_Step struct {
	// The location of the steps' `keyword`
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Keyword  string    `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Text     string    `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	// Types that are valid to be assigned to Argument:
	//	*GherkinDocument_Feature_Step_DocString_
	//	*GherkinDocument_Feature_Step_DataTable_
	Argument isGherkinDocument_Feature_Step_Argument `protobuf_oneof:"argument"`
	// Unique ID to be able to reference the Step from PickleStep
	Id string `protobuf:"bytes,6,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GherkinDocument_Feature_Step) Reset()         { *m = GherkinDocument_Feature_Step{} }
func (m *GherkinDocument_Feature_Step) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Step) ProtoMessage()    {}
func (*GherkinDocument_Feature_Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 5}
}
func (m *GherkinDocument_Feature_Step) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Step.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Step.Merge(m, src)
}
func (m *GherkinDocument_Feature_Step) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Step) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Step.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Step proto.InternalMessageInfo

type isGherkinDocument_Feature_Step_Argument interface {
	isGherkinDocument_Feature_Step_Argument()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GherkinDocument_Feature_Step_DocString_ struct {
	DocString *GherkinDocument_Feature_Step_DocString `protobuf:"bytes,4,opt,name=doc_string,json=docString,proto3,oneof" json:"doc_string,omitempty"`
}
type GherkinDocument_Feature_Step_DataTable_ struct {
	DataTable *GherkinDocument_Feature_Step_DataTable `protobuf:"bytes,5,opt,name=data_table,json=dataTable,proto3,oneof" json:"data_table,omitempty"`
}

func (*GherkinDocument_Feature_Step_DocString_) isGherkinDocument_Feature_Step_Argument() {}
func (*GherkinDocument_Feature_Step_DataTable_) isGherkinDocument_Feature_Step_Argument() {}

func (m *GherkinDocument_Feature_Step) GetArgument() isGherkinDocument_Feature_Step_Argument {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Step) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *GherkinDocument_Feature_Step) GetDocString() *GherkinDocument_Feature_Step_DocString {
	if x, ok := m.GetArgument().(*GherkinDocument_Feature_Step_DocString_); ok {
		return x.DocString
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetDataTable() *GherkinDocument_Feature_Step_DataTable {
	if x, ok := m.GetArgument().(*GherkinDocument_Feature_Step_DataTable_); ok {
		return x.DataTable
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GherkinDocument_Feature_Step) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GherkinDocument_Feature_Step_DocString_)(nil),
		(*GherkinDocument_Feature_Step_DataTable_)(nil),
	}
}

type GherkinDocument_Feature_Step_DataTable struct {
	Location *Location                           `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Rows     []*GherkinDocument_Feature_TableRow `protobuf:"bytes,2,rep,name=rows,proto3" json:"rows,omitempty"`
}

func (m *GherkinDocument_Feature_Step_DataTable) Reset() {
	*m = GherkinDocument_Feature_Step_DataTable{}
}
func (m *GherkinDocument_Feature_Step_DataTable) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Step_DataTable) ProtoMessage()    {}
func (*GherkinDocument_Feature_Step_DataTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 5, 0}
}
func (m *GherkinDocument_Feature_Step_DataTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Step_DataTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Step_DataTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Step_DataTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Step_DataTable.Merge(m, src)
}
func (m *GherkinDocument_Feature_Step_DataTable) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Step_DataTable) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Step_DataTable.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Step_DataTable proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Step_DataTable) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Step_DataTable) GetRows() []*GherkinDocument_Feature_TableRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

type GherkinDocument_Feature_Step_DocString struct {
	Location  *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	MediaType string    `protobuf:"bytes,2,opt,name=media_type,json=mediaType,proto3" json:"media_type,omitempty"`
	Content   string    `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	Delimiter string    `protobuf:"bytes,4,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
}

func (m *GherkinDocument_Feature_Step_DocString) Reset() {
	*m = GherkinDocument_Feature_Step_DocString{}
}
func (m *GherkinDocument_Feature_Step_DocString) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Step_DocString) ProtoMessage()    {}
func (*GherkinDocument_Feature_Step_DocString) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 5, 1}
}
func (m *GherkinDocument_Feature_Step_DocString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Step_DocString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Step_DocString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Step_DocString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Step_DocString.Merge(m, src)
}
func (m *GherkinDocument_Feature_Step_DocString) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Step_DocString) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Step_DocString.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Step_DocString proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Step_DocString) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Step_DocString) GetMediaType() string {
	if m != nil {
		return m.MediaType
	}
	return ""
}

func (m *GherkinDocument_Feature_Step_DocString) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *GherkinDocument_Feature_Step_DocString) GetDelimiter() string {
	if m != nil {
		return m.Delimiter
	}
	return ""
}

//*
// An attachment represents any kind of data associated with a line in a
// [Source](#io.cucumber.messages.Source) file. It can be used for:
//
// * Syntax errors during parse time
// * Screenshots captured and attached during execution
// * Logs captured and attached during execution
//
// It is not to be used for runtime errors raised/thrown during execution. This
// is captured in `TestResult`.
type Attachment struct {
	Source            *SourceReference `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	TestStepId        string           `protobuf:"bytes,2,opt,name=test_step_id,json=testStepId,proto3" json:"test_step_id,omitempty"`
	TestCaseStartedId string           `protobuf:"bytes,3,opt,name=test_case_started_id,json=testCaseStartedId,proto3" json:"test_case_started_id,omitempty"`
	//*
	// The body of the attachment. If `content_encoding` is `IDENTITY`, the attachment
	// is simply the string. If it's `BASE64`, the string should be Base64 decoded to
	// obtain the attachment.
	Body string `protobuf:"bytes,4,opt,name=body,proto3" json:"body,omitempty"`
	//*
	// The media type of the data. This can be any valid
	// [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
	// as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
	// and `text/x.cucumber.stacktrace+plain`
	MediaType string `protobuf:"bytes,5,opt,name=media_type,json=mediaType,proto3" json:"media_type,omitempty"`
	//*
	// Whether to interpret `body` "as-is" (IDENTITY) or if it needs to be Base64-decoded (BASE64).
	//
	// Content encoding is *not* determined by the media type, but rather by the type
	// of the object being attached:
	//
	// - string => IDENTITY
	// - byte array => BASE64
	// - stream => BASE64
	ContentEncoding Attachment_ContentEncoding `protobuf:"varint,6,opt,name=content_encoding,json=contentEncoding,proto3,enum=io.cucumber.messages.Attachment_ContentEncoding" json:"content_encoding,omitempty"`
	//*
	// Suggested file name of the attachment. (Provided by the user as an argument to `attach`)
	FileName string `protobuf:"bytes,7,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	//*
	// A URL where the attachment can be retrieved. This field should not be set by Cucumber.
	// It should be set by a program that reads a message stream and does the following for
	// each Attachment message:
	//
	// - Writes the body (after base64 decoding if necessary) to a new file.
	// - Sets `body` and `content_encoding` to `null`
	// - Writes out the new attachment message
	//
	// This will result in a smaller message stream, which can improve performance and
	// reduce bandwidth of message consumers. It also makes it easier to process and download attachments
	// separately from reports.
	Url string `protobuf:"bytes,8,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *Attachment) Reset()         { *m = Attachment{} }
func (m *Attachment) String() string { return proto.CompactTextString(m) }
func (*Attachment) ProtoMessage()    {}
func (*Attachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{8}
}
func (m *Attachment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Attachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Attachment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Attachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attachment.Merge(m, src)
}
func (m *Attachment) XXX_Size() int {
	return m.Size()
}
func (m *Attachment) XXX_DiscardUnknown() {
	xxx_messageInfo_Attachment.DiscardUnknown(m)
}

var xxx_messageInfo_Attachment proto.InternalMessageInfo

func (m *Attachment) GetSource() *SourceReference {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Attachment) GetTestStepId() string {
	if m != nil {
		return m.TestStepId
	}
	return ""
}

func (m *Attachment) GetTestCaseStartedId() string {
	if m != nil {
		return m.TestCaseStartedId
	}
	return ""
}

func (m *Attachment) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

func (m *Attachment) GetMediaType() string {
	if m != nil {
		return m.MediaType
	}
	return ""
}

func (m *Attachment) GetContentEncoding() Attachment_ContentEncoding {
	if m != nil {
		return m.ContentEncoding
	}
	return Attachment_IDENTITY
}

func (m *Attachment) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *Attachment) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

//*
// A `Pickle` represents a template for a `TestCase`. It is typically derived
// from another format, such as [GherkinDocument](#io.cucumber.messages.GherkinDocument).
// In the future a `Pickle` may be derived from other formats such as Markdown or
// Excel files.
//
// By making `Pickle` the main data structure Cucumber uses for execution, the
// implementation of Cucumber itself becomes simpler, as it doesn't have to deal
// with the complex structure of a [GherkinDocument](#io.cucumber.messages.GherkinDocument).
//
// Each `PickleStep` of a `Pickle` is matched with a `StepDefinition` to create a `TestCase`
type Pickle struct {
	//*
	// A unique id for the pickle. This is a [SHA1](https://en.wikipedia.org/wiki/SHA-1) hash
	// from the source data and the `locations` of the pickle.
	// This ID will change if source the file is modified.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The uri of the source file
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	// The name of the pickle
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The language of the pickle
	Language string `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	// One or more steps
	Steps []*Pickle_PickleStep `protobuf:"bytes,5,rep,name=steps,proto3" json:"steps,omitempty"`
	//*
	// One or more tags. If this pickle is constructed from a Gherkin document,
	// It includes inherited tags from the `Feature` as well.
	Tags []*Pickle_PickleTag `protobuf:"bytes,6,rep,name=tags,proto3" json:"tags,omitempty"`
	//*
	// Points to the AST node locations of the pickle. The last one represents the unique
	// id of the pickle. A pickle constructed from `Examples` will have the first
	// id originating from the `Scenario` AST node, and the second from the `TableRow` AST node.
	AstNodeIds []string `protobuf:"bytes,7,rep,name=ast_node_ids,json=astNodeIds,proto3" json:"ast_node_ids,omitempty"`
}

func (m *Pickle) Reset()         { *m = Pickle{} }
func (m *Pickle) String() string { return proto.CompactTextString(m) }
func (*Pickle) ProtoMessage()    {}
func (*Pickle) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{9}
}
func (m *Pickle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pickle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pickle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pickle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pickle.Merge(m, src)
}
func (m *Pickle) XXX_Size() int {
	return m.Size()
}
func (m *Pickle) XXX_DiscardUnknown() {
	xxx_messageInfo_Pickle.DiscardUnknown(m)
}

var xxx_messageInfo_Pickle proto.InternalMessageInfo

func (m *Pickle) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Pickle) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Pickle) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pickle) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Pickle) GetSteps() []*Pickle_PickleStep {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Pickle) GetTags() []*Pickle_PickleTag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Pickle) GetAstNodeIds() []string {
	if m != nil {
		return m.AstNodeIds
	}
	return nil
}

//*
// A tag
type Pickle_PickleTag struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Points to the AST node this was created from
	AstNodeId string `protobuf:"bytes,2,opt,name=ast_node_id,json=astNodeId,proto3" json:"ast_node_id,omitempty"`
}

func (m *Pickle_PickleTag) Reset()         { *m = Pickle_PickleTag{} }
func (m *Pickle_PickleTag) String() string { return proto.CompactTextString(m) }
func (*Pickle_PickleTag) ProtoMessage()    {}
func (*Pickle_PickleTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{9, 0}
}
func (m *Pickle_PickleTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pickle_PickleTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pickle_PickleTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pickle_PickleTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pickle_PickleTag.Merge(m, src)
}
func (m *Pickle_PickleTag) XXX_Size() int {
	return m.Size()
}
func (m *Pickle_PickleTag) XXX_DiscardUnknown() {
	xxx_messageInfo_Pickle_PickleTag.DiscardUnknown(m)
}

var xxx_messageInfo_Pickle_PickleTag proto.InternalMessageInfo

func (m *Pickle_PickleTag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pickle_PickleTag) GetAstNodeId() string {
	if m != nil {
		return m.AstNodeId
	}
	return ""
}

//*
// An executable step
type Pickle_PickleStep struct {
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// An optional argument
	Argument *PickleStepArgument `protobuf:"bytes,2,opt,name=argument,proto3" json:"argument,omitempty"`
	// A unique ID for the PickleStep
	Id string `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
	// References the IDs of the source of the step. For Gherkin, this can be
	// the ID of a Step, and possibly also the ID of a TableRow
	AstNodeIds []string `protobuf:"bytes,4,rep,name=ast_node_ids,json=astNodeIds,proto3" json:"ast_node_ids,omitempty"`
}

func (m *Pickle_PickleStep) Reset()         { *m = Pickle_PickleStep{} }
func (m *Pickle_PickleStep) String() string { return proto.CompactTextString(m) }
func (*Pickle_PickleStep) ProtoMessage()    {}
func (*Pickle_PickleStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{9, 1}
}
func (m *Pickle_PickleStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pickle_PickleStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pickle_PickleStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pickle_PickleStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pickle_PickleStep.Merge(m, src)
}
func (m *Pickle_PickleStep) XXX_Size() int {
	return m.Size()
}
func (m *Pickle_PickleStep) XXX_DiscardUnknown() {
	xxx_messageInfo_Pickle_PickleStep.DiscardUnknown(m)
}

var xxx_messageInfo_Pickle_PickleStep proto.InternalMessageInfo

func (m *Pickle_PickleStep) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Pickle_PickleStep) GetArgument() *PickleStepArgument {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *Pickle_PickleStep) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Pickle_PickleStep) GetAstNodeIds() []string {
	if m != nil {
		return m.AstNodeIds
	}
	return nil
}

//*
// A wrapper for either a doc string or a table.
type PickleStepArgument struct {
	// Types that are valid to be assigned to Message:
	//	*PickleStepArgument_DocString
	//	*PickleStepArgument_DataTable
	Message isPickleStepArgument_Message `protobuf_oneof:"message"`
}

func (m *PickleStepArgument) Reset()         { *m = PickleStepArgument{} }
func (m *PickleStepArgument) String() string { return proto.CompactTextString(m) }
func (*PickleStepArgument) ProtoMessage()    {}
func (*PickleStepArgument) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{10}
}
func (m *PickleStepArgument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStepArgument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStepArgument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleStepArgument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStepArgument.Merge(m, src)
}
func (m *PickleStepArgument) XXX_Size() int {
	return m.Size()
}
func (m *PickleStepArgument) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStepArgument.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStepArgument proto.InternalMessageInfo

type isPickleStepArgument_Message interface {
	isPickleStepArgument_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PickleStepArgument_DocString struct {
	DocString *PickleStepArgument_PickleDocString `protobuf:"bytes,1,opt,name=doc_string,json=docString,proto3,oneof" json:"doc_string,omitempty"`
}
type PickleStepArgument_DataTable struct {
	DataTable *PickleStepArgument_PickleTable `protobuf:"bytes,2,opt,name=data_table,json=dataTable,proto3,oneof" json:"data_table,omitempty"`
}

func (*PickleStepArgument_DocString) isPickleStepArgument_Message() {}
func (*PickleStepArgument_DataTable) isPickleStepArgument_Message() {}

func (m *PickleStepArgument) GetMessage() isPickleStepArgument_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *PickleStepArgument) GetDocString() *PickleStepArgument_PickleDocString {
	if x, ok := m.GetMessage().(*PickleStepArgument_DocString); ok {
		return x.DocString
	}
	return nil
}

func (m *PickleStepArgument) GetDataTable() *PickleStepArgument_PickleTable {
	if x, ok := m.GetMessage().(*PickleStepArgument_DataTable); ok {
		return x.DataTable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PickleStepArgument) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PickleStepArgument_DocString)(nil),
		(*PickleStepArgument_DataTable)(nil),
	}
}

type PickleStepArgument_PickleDocString struct {
	MediaType string `protobuf:"bytes,1,opt,name=media_type,json=mediaType,proto3" json:"media_type,omitempty"`
	Content   string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *PickleStepArgument_PickleDocString) Reset()         { *m = PickleStepArgument_PickleDocString{} }
func (m *PickleStepArgument_PickleDocString) String() string { return proto.CompactTextString(m) }
func (*PickleStepArgument_PickleDocString) ProtoMessage()    {}
func (*PickleStepArgument_PickleDocString) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{10, 0}
}
func (m *PickleStepArgument_PickleDocString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStepArgument_PickleDocString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStepArgument_PickleDocString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleStepArgument_PickleDocString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStepArgument_PickleDocString.Merge(m, src)
}
func (m *PickleStepArgument_PickleDocString) XXX_Size() int {
	return m.Size()
}
func (m *PickleStepArgument_PickleDocString) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStepArgument_PickleDocString.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStepArgument_PickleDocString proto.InternalMessageInfo

func (m *PickleStepArgument_PickleDocString) GetMediaType() string {
	if m != nil {
		return m.MediaType
	}
	return ""
}

func (m *PickleStepArgument_PickleDocString) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type PickleStepArgument_PickleTable struct {
	Rows []*PickleStepArgument_PickleTable_PickleTableRow `protobuf:"bytes,1,rep,name=rows,proto3" json:"rows,omitempty"`
}

func (m *PickleStepArgument_PickleTable) Reset()         { *m = PickleStepArgument_PickleTable{} }
func (m *PickleStepArgument_PickleTable) String() string { return proto.CompactTextString(m) }
func (*PickleStepArgument_PickleTable) ProtoMessage()    {}
func (*PickleStepArgument_PickleTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{10, 1}
}
func (m *PickleStepArgument_PickleTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStepArgument_PickleTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStepArgument_PickleTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleStepArgument_PickleTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStepArgument_PickleTable.Merge(m, src)
}
func (m *PickleStepArgument_PickleTable) XXX_Size() int {
	return m.Size()
}
func (m *PickleStepArgument_PickleTable) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStepArgument_PickleTable.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStepArgument_PickleTable proto.InternalMessageInfo

func (m *PickleStepArgument_PickleTable) GetRows() []*PickleStepArgument_PickleTable_PickleTableRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

type PickleStepArgument_PickleTable_PickleTableRow struct {
	Cells []*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell `protobuf:"bytes,1,rep,name=cells,proto3" json:"cells,omitempty"`
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) Reset() {
	*m = PickleStepArgument_PickleTable_PickleTableRow{}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) String() string {
	return proto.CompactTextString(m)
}
func (*PickleStepArgument_PickleTable_PickleTableRow) ProtoMessage() {}
func (*PickleStepArgument_PickleTable_PickleTableRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{10, 1, 0}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow.Merge(m, src)
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) XXX_Size() int {
	return m.Size()
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow proto.InternalMessageInfo

func (m *PickleStepArgument_PickleTable_PickleTableRow) GetCells() []*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell {
	if m != nil {
		return m.Cells
	}
	return nil
}

type PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Reset() {
	*m = PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell{}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) String() string {
	return proto.CompactTextString(m)
}
func (*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) ProtoMessage() {}
func (*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{10, 1, 0, 0}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell.Merge(m, src)
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) XXX_Size() int {
	return m.Size()
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell proto.InternalMessageInfo

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

//*
// A `TestCase` contains a sequence of `TestStep`s.
type TestCase struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The ID of the `Pickle` this `TestCase` is derived from.
	PickleId  string               `protobuf:"bytes,2,opt,name=pickle_id,json=pickleId,proto3" json:"pickle_id,omitempty"`
	TestSteps []*TestCase_TestStep `protobuf:"bytes,3,rep,name=test_steps,json=testSteps,proto3" json:"test_steps,omitempty"`
}

func (m *TestCase) Reset()         { *m = TestCase{} }
func (m *TestCase) String() string { return proto.CompactTextString(m) }
func (*TestCase) ProtoMessage()    {}
func (*TestCase) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{11}
}
func (m *TestCase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCase.Merge(m, src)
}
func (m *TestCase) XXX_Size() int {
	return m.Size()
}
func (m *TestCase) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCase.DiscardUnknown(m)
}

var xxx_messageInfo_TestCase proto.InternalMessageInfo

func (m *TestCase) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestCase) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestCase) GetTestSteps() []*TestCase_TestStep {
	if m != nil {
		return m.TestSteps
	}
	return nil
}

//*
// A `TestStep` is derived from either a `PickleStep`
// combined with a `StepDefinition`, or from a `Hook`.
type TestCase_TestStep struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Pointer to the `PickleStep` (if derived from a PickleStep)
	PickleStepId string `protobuf:"bytes,2,opt,name=pickle_step_id,json=pickleStepId,proto3" json:"pickle_step_id,omitempty"`
	// Pointer to all the matching `StepDefinition`s (if derived from a PickleStep)
	StepDefinitionIds []string `protobuf:"bytes,3,rep,name=step_definition_ids,json=stepDefinitionIds,proto3" json:"step_definition_ids,omitempty"`
	// A list of list of StepMatchArgument (if derived from a `StepDefinition`).
	// Each element represents a matching step definition. A size of 0 means `UNDEFINED`,
	// and a size of 2+ means `AMBIGUOUS`
	StepMatchArgumentsLists []*TestCase_TestStep_StepMatchArgumentsList `protobuf:"bytes,4,rep,name=step_match_arguments_lists,json=stepMatchArgumentsLists,proto3" json:"step_match_arguments_lists,omitempty"`
	// Pointer to the `Hook` (if derived from a Hook)
	HookId string `protobuf:"bytes,5,opt,name=hook_id,json=hookId,proto3" json:"hook_id,omitempty"`
}

func (m *TestCase_TestStep) Reset()         { *m = TestCase_TestStep{} }
func (m *TestCase_TestStep) String() string { return proto.CompactTextString(m) }
func (*TestCase_TestStep) ProtoMessage()    {}
func (*TestCase_TestStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{11, 0}
}
func (m *TestCase_TestStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCase_TestStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCase_TestStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCase_TestStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCase_TestStep.Merge(m, src)
}
func (m *TestCase_TestStep) XXX_Size() int {
	return m.Size()
}
func (m *TestCase_TestStep) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCase_TestStep.DiscardUnknown(m)
}

var xxx_messageInfo_TestCase_TestStep proto.InternalMessageInfo

func (m *TestCase_TestStep) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestCase_TestStep) GetPickleStepId() string {
	if m != nil {
		return m.PickleStepId
	}
	return ""
}

func (m *TestCase_TestStep) GetStepDefinitionIds() []string {
	if m != nil {
		return m.StepDefinitionIds
	}
	return nil
}

func (m *TestCase_TestStep) GetStepMatchArgumentsLists() []*TestCase_TestStep_StepMatchArgumentsList {
	if m != nil {
		return m.StepMatchArgumentsLists
	}
	return nil
}

func (m *TestCase_TestStep) GetHookId() string {
	if m != nil {
		return m.HookId
	}
	return ""
}

type TestCase_TestStep_StepMatchArgumentsList struct {
	StepMatchArguments []*TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument `protobuf:"bytes,1,rep,name=step_match_arguments,json=stepMatchArguments,proto3" json:"step_match_arguments,omitempty"`
}

func (m *TestCase_TestStep_StepMatchArgumentsList) Reset() {
	*m = TestCase_TestStep_StepMatchArgumentsList{}
}
func (m *TestCase_TestStep_StepMatchArgumentsList) String() string { return proto.CompactTextString(m) }
func (*TestCase_TestStep_StepMatchArgumentsList) ProtoMessage()    {}
func (*TestCase_TestStep_StepMatchArgumentsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{11, 0, 0}
}
func (m *TestCase_TestStep_StepMatchArgumentsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCase_TestStep_StepMatchArgumentsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCase_TestStep_StepMatchArgumentsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList.Merge(m, src)
}
func (m *TestCase_TestStep_StepMatchArgumentsList) XXX_Size() int {
	return m.Size()
}
func (m *TestCase_TestStep_StepMatchArgumentsList) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList.DiscardUnknown(m)
}

var xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList proto.InternalMessageInfo

func (m *TestCase_TestStep_StepMatchArgumentsList) GetStepMatchArguments() []*TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument {
	if m != nil {
		return m.StepMatchArguments
	}
	return nil
}

//*
// Represents a single argument extracted from a step match and passed to a step definition.
// This is used for the following purposes:
// - Construct an argument to pass to a step definition (possibly through a parameter type transform)
// - Highlight the matched parameter in rich formatters such as the HTML formatter
//
// This message closely matches the `Argument` class in the `cucumber-expressions` library.
type TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument struct {
	ParameterTypeName string `protobuf:"bytes,1,opt,name=parameter_type_name,json=parameterTypeName,proto3" json:"parameter_type_name,omitempty"`
	//*
	// Represents the outermost capture group of an argument. This message closely matches the
	// `Group` class in the `cucumber-expressions` library.
	Group *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) Reset() {
	*m = TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument{}
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) String() string {
	return proto.CompactTextString(m)
}
func (*TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) ProtoMessage() {}
func (*TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{11, 0, 0, 0}
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument.Merge(m, src)
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) XXX_Size() int {
	return m.Size()
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument.DiscardUnknown(m)
}

var xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument proto.InternalMessageInfo

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) GetParameterTypeName() string {
	if m != nil {
		return m.ParameterTypeName
	}
	return ""
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) GetGroup() *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group struct {
	Start    uint32                                                              `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	Value    string                                                              `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Children []*TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group `protobuf:"bytes,3,rep,name=children,proto3" json:"children,omitempty"`
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) Reset() {
	*m = TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group{}
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) String() string {
	return proto.CompactTextString(m)
}
func (*TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) ProtoMessage() {}
func (*TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{11, 0, 0, 0, 0}
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group.Merge(m, src)
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) XXX_Size() int {
	return m.Size()
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group.DiscardUnknown(m)
}

var xxx_messageInfo_TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group proto.InternalMessageInfo

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) GetChildren() []*TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group {
	if m != nil {
		return m.Children
	}
	return nil
}

type TestRunStarted struct {
	Timestamp *Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *TestRunStarted) Reset()         { *m = TestRunStarted{} }
func (m *TestRunStarted) String() string { return proto.CompactTextString(m) }
func (*TestRunStarted) ProtoMessage()    {}
func (*TestRunStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{12}
}
func (m *TestRunStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestRunStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestRunStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestRunStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestRunStarted.Merge(m, src)
}
func (m *TestRunStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestRunStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestRunStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestRunStarted proto.InternalMessageInfo

func (m *TestRunStarted) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestCaseStarted struct {
	Timestamp *Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	//*
	// The first attempt should have value 0, and for each retry the value
	// should increase by 1.
	Attempt    uint32 `protobuf:"varint,3,opt,name=attempt,proto3" json:"attempt,omitempty"`
	TestCaseId string `protobuf:"bytes,4,opt,name=test_case_id,json=testCaseId,proto3" json:"test_case_id,omitempty"`
	//*
	// Because a `TestCase` can be run multiple times (in case of a retry),
	// we use this field to group messages relating to the same attempt.
	Id string `protobuf:"bytes,5,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *TestCaseStarted) Reset()         { *m = TestCaseStarted{} }
func (m *TestCaseStarted) String() string { return proto.CompactTextString(m) }
func (*TestCaseStarted) ProtoMessage()    {}
func (*TestCaseStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{13}
}
func (m *TestCaseStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCaseStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCaseStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCaseStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCaseStarted.Merge(m, src)
}
func (m *TestCaseStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestCaseStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCaseStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestCaseStarted proto.InternalMessageInfo

func (m *TestCaseStarted) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestCaseStarted) GetAttempt() uint32 {
	if m != nil {
		return m.Attempt
	}
	return 0
}

func (m *TestCaseStarted) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

func (m *TestCaseStarted) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type TestCaseFinished struct {
	Timestamp         *Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TestCaseStartedId string     `protobuf:"bytes,3,opt,name=test_case_started_id,json=testCaseStartedId,proto3" json:"test_case_started_id,omitempty"`
}

func (m *TestCaseFinished) Reset()         { *m = TestCaseFinished{} }
func (m *TestCaseFinished) String() string { return proto.CompactTextString(m) }
func (*TestCaseFinished) ProtoMessage()    {}
func (*TestCaseFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{14}
}
func (m *TestCaseFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCaseFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCaseFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCaseFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCaseFinished.Merge(m, src)
}
func (m *TestCaseFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestCaseFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCaseFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestCaseFinished proto.InternalMessageInfo

func (m *TestCaseFinished) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestCaseFinished) GetTestCaseStartedId() string {
	if m != nil {
		return m.TestCaseStartedId
	}
	return ""
}

type TestStepStarted struct {
	Timestamp         *Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TestStepId        string     `protobuf:"bytes,2,opt,name=test_step_id,json=testStepId,proto3" json:"test_step_id,omitempty"`
	TestCaseStartedId string     `protobuf:"bytes,3,opt,name=test_case_started_id,json=testCaseStartedId,proto3" json:"test_case_started_id,omitempty"`
}

func (m *TestStepStarted) Reset()         { *m = TestStepStarted{} }
func (m *TestStepStarted) String() string { return proto.CompactTextString(m) }
func (*TestStepStarted) ProtoMessage()    {}
func (*TestStepStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{15}
}
func (m *TestStepStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestStepStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestStepStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestStepStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestStepStarted.Merge(m, src)
}
func (m *TestStepStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestStepStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestStepStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestStepStarted proto.InternalMessageInfo

func (m *TestStepStarted) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestStepStarted) GetTestStepId() string {
	if m != nil {
		return m.TestStepId
	}
	return ""
}

func (m *TestStepStarted) GetTestCaseStartedId() string {
	if m != nil {
		return m.TestCaseStartedId
	}
	return ""
}

type TestStepFinished struct {
	TestStepResult    *TestStepFinished_TestStepResult `protobuf:"bytes,1,opt,name=test_step_result,json=testStepResult,proto3" json:"test_step_result,omitempty"`
	Timestamp         *Timestamp                       `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TestStepId        string                           `protobuf:"bytes,3,opt,name=test_step_id,json=testStepId,proto3" json:"test_step_id,omitempty"`
	TestCaseStartedId string                           `protobuf:"bytes,4,opt,name=test_case_started_id,json=testCaseStartedId,proto3" json:"test_case_started_id,omitempty"`
}

func (m *TestStepFinished) Reset()         { *m = TestStepFinished{} }
func (m *TestStepFinished) String() string { return proto.CompactTextString(m) }
func (*TestStepFinished) ProtoMessage()    {}
func (*TestStepFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{16}
}
func (m *TestStepFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestStepFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestStepFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestStepFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestStepFinished.Merge(m, src)
}
func (m *TestStepFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestStepFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestStepFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestStepFinished proto.InternalMessageInfo

func (m *TestStepFinished) GetTestStepResult() *TestStepFinished_TestStepResult {
	if m != nil {
		return m.TestStepResult
	}
	return nil
}

func (m *TestStepFinished) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestStepFinished) GetTestStepId() string {
	if m != nil {
		return m.TestStepId
	}
	return ""
}

func (m *TestStepFinished) GetTestCaseStartedId() string {
	if m != nil {
		return m.TestCaseStartedId
	}
	return ""
}

type TestStepFinished_TestStepResult struct {
	Status        TestStepFinished_TestStepResult_Status `protobuf:"varint,1,opt,name=status,proto3,enum=io.cucumber.messages.TestStepFinished_TestStepResult_Status" json:"status,omitempty"`
	Message       string                                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Duration      *Duration                              `protobuf:"bytes,3,opt,name=duration,proto3" json:"duration,omitempty"`
	WillBeRetried bool                                   `protobuf:"varint,4,opt,name=will_be_retried,json=willBeRetried,proto3" json:"will_be_retried,omitempty"`
}

func (m *TestStepFinished_TestStepResult) Reset()         { *m = TestStepFinished_TestStepResult{} }
func (m *TestStepFinished_TestStepResult) String() string { return proto.CompactTextString(m) }
func (*TestStepFinished_TestStepResult) ProtoMessage()    {}
func (*TestStepFinished_TestStepResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{16, 0}
}
func (m *TestStepFinished_TestStepResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestStepFinished_TestStepResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestStepFinished_TestStepResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestStepFinished_TestStepResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestStepFinished_TestStepResult.Merge(m, src)
}
func (m *TestStepFinished_TestStepResult) XXX_Size() int {
	return m.Size()
}
func (m *TestStepFinished_TestStepResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TestStepFinished_TestStepResult.DiscardUnknown(m)
}

var xxx_messageInfo_TestStepFinished_TestStepResult proto.InternalMessageInfo

func (m *TestStepFinished_TestStepResult) GetStatus() TestStepFinished_TestStepResult_Status {
	if m != nil {
		return m.Status
	}
	return TestStepFinished_TestStepResult_UNKNOWN
}

func (m *TestStepFinished_TestStepResult) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TestStepFinished_TestStepResult) GetDuration() *Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *TestStepFinished_TestStepResult) GetWillBeRetried() bool {
	if m != nil {
		return m.WillBeRetried
	}
	return false
}

type TestRunFinished struct {
	// success = StrictModeEnabled ? (failed_count == 0 && ambiguous_count == 0 && undefined_count == 0 && pending_count == 0) : (failed_count == 0 && ambiguous_count == 0)
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Timestamp when the TestRun is finished
	Timestamp *Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Error message. Can be a stack trace from a failed `BeforeAll` or `AfterAll`.
	// If there are undefined parameter types, the message is simply
	// "The following parameter type(s() are not defined: xxx, yyy".
	// The independent `UndefinedParameterType` messages can be used to generate
	// snippets for those parameter types.
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TestRunFinished) Reset()         { *m = TestRunFinished{} }
func (m *TestRunFinished) String() string { return proto.CompactTextString(m) }
func (*TestRunFinished) ProtoMessage()    {}
func (*TestRunFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{17}
}
func (m *TestRunFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestRunFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestRunFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestRunFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestRunFinished.Merge(m, src)
}
func (m *TestRunFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestRunFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestRunFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestRunFinished proto.InternalMessageInfo

func (m *TestRunFinished) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *TestRunFinished) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestRunFinished) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type Hook struct {
	Id              string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	TagExpression   string           `protobuf:"bytes,2,opt,name=tag_expression,json=tagExpression,proto3" json:"tag_expression,omitempty"`
	SourceReference *SourceReference `protobuf:"bytes,3,opt,name=source_reference,json=sourceReference,proto3" json:"source_reference,omitempty"`
}

func (m *Hook) Reset()         { *m = Hook{} }
func (m *Hook) String() string { return proto.CompactTextString(m) }
func (*Hook) ProtoMessage()    {}
func (*Hook) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{18}
}
func (m *Hook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Hook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Hook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Hook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Hook.Merge(m, src)
}
func (m *Hook) XXX_Size() int {
	return m.Size()
}
func (m *Hook) XXX_DiscardUnknown() {
	xxx_messageInfo_Hook.DiscardUnknown(m)
}

var xxx_messageInfo_Hook proto.InternalMessageInfo

func (m *Hook) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Hook) GetTagExpression() string {
	if m != nil {
		return m.TagExpression
	}
	return ""
}

func (m *Hook) GetSourceReference() *SourceReference {
	if m != nil {
		return m.SourceReference
	}
	return nil
}

type StepDefinition struct {
	Id              string                                `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Pattern         *StepDefinition_StepDefinitionPattern `protobuf:"bytes,2,opt,name=pattern,proto3" json:"pattern,omitempty"`
	SourceReference *SourceReference                      `protobuf:"bytes,3,opt,name=source_reference,json=sourceReference,proto3" json:"source_reference,omitempty"`
}

func (m *StepDefinition) Reset()         { *m = StepDefinition{} }
func (m *StepDefinition) String() string { return proto.CompactTextString(m) }
func (*StepDefinition) ProtoMessage()    {}
func (*StepDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{19}
}
func (m *StepDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepDefinition.Merge(m, src)
}
func (m *StepDefinition) XXX_Size() int {
	return m.Size()
}
func (m *StepDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_StepDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_StepDefinition proto.InternalMessageInfo

func (m *StepDefinition) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StepDefinition) GetPattern() *StepDefinition_StepDefinitionPattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *StepDefinition) GetSourceReference() *SourceReference {
	if m != nil {
		return m.SourceReference
	}
	return nil
}

type StepDefinition_StepDefinitionPattern struct {
	Source string                                                         `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type   StepDefinition_StepDefinitionPattern_StepDefinitionPatternType `protobuf:"varint,2,opt,name=type,proto3,enum=io.cucumber.messages.StepDefinition_StepDefinitionPattern_StepDefinitionPatternType" json:"type,omitempty"`
}

func (m *StepDefinition_StepDefinitionPattern) Reset()         { *m = StepDefinition_StepDefinitionPattern{} }
func (m *StepDefinition_StepDefinitionPattern) String() string { return proto.CompactTextString(m) }
func (*StepDefinition_StepDefinitionPattern) ProtoMessage()    {}
func (*StepDefinition_StepDefinitionPattern) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{19, 0}
}
func (m *StepDefinition_StepDefinitionPattern) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepDefinition_StepDefinitionPattern) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepDefinition_StepDefinitionPattern.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepDefinition_StepDefinitionPattern) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepDefinition_StepDefinitionPattern.Merge(m, src)
}
func (m *StepDefinition_StepDefinitionPattern) XXX_Size() int {
	return m.Size()
}
func (m *StepDefinition_StepDefinitionPattern) XXX_DiscardUnknown() {
	xxx_messageInfo_StepDefinition_StepDefinitionPattern.DiscardUnknown(m)
}

var xxx_messageInfo_StepDefinition_StepDefinitionPattern proto.InternalMessageInfo

func (m *StepDefinition_StepDefinitionPattern) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *StepDefinition_StepDefinitionPattern) GetType() StepDefinition_StepDefinitionPattern_StepDefinitionPatternType {
	if m != nil {
		return m.Type
	}
	return StepDefinition_StepDefinitionPattern_CUCUMBER_EXPRESSION
}

type ParameterType struct {
	// The name is unique, so we don't need an id.
	Name                            string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	RegularExpressions              []string `protobuf:"bytes,2,rep,name=regular_expressions,json=regularExpressions,proto3" json:"regular_expressions,omitempty"`
	PreferForRegularExpressionMatch bool     `protobuf:"varint,3,opt,name=prefer_for_regular_expression_match,json=preferForRegularExpressionMatch,proto3" json:"prefer_for_regular_expression_match,omitempty"`
	UseForSnippets                  bool     `protobuf:"varint,4,opt,name=use_for_snippets,json=useForSnippets,proto3" json:"use_for_snippets,omitempty"`
	Id                              string   `protobuf:"bytes,5,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ParameterType) Reset()         { *m = ParameterType{} }
func (m *ParameterType) String() string { return proto.CompactTextString(m) }
func (*ParameterType) ProtoMessage()    {}
func (*ParameterType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{20}
}
func (m *ParameterType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParameterType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParameterType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParameterType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParameterType.Merge(m, src)
}
func (m *ParameterType) XXX_Size() int {
	return m.Size()
}
func (m *ParameterType) XXX_DiscardUnknown() {
	xxx_messageInfo_ParameterType.DiscardUnknown(m)
}

var xxx_messageInfo_ParameterType proto.InternalMessageInfo

func (m *ParameterType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ParameterType) GetRegularExpressions() []string {
	if m != nil {
		return m.RegularExpressions
	}
	return nil
}

func (m *ParameterType) GetPreferForRegularExpressionMatch() bool {
	if m != nil {
		return m.PreferForRegularExpressionMatch
	}
	return false
}

func (m *ParameterType) GetUseForSnippets() bool {
	if m != nil {
		return m.UseForSnippets
	}
	return false
}

func (m *ParameterType) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type UndefinedParameterType struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Expression string `protobuf:"bytes,2,opt,name=expression,proto3" json:"expression,omitempty"`
}

func (m *UndefinedParameterType) Reset()         { *m = UndefinedParameterType{} }
func (m *UndefinedParameterType) String() string { return proto.CompactTextString(m) }
func (*UndefinedParameterType) ProtoMessage()    {}
func (*UndefinedParameterType) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{21}
}
func (m *UndefinedParameterType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UndefinedParameterType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UndefinedParameterType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UndefinedParameterType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UndefinedParameterType.Merge(m, src)
}
func (m *UndefinedParameterType) XXX_Size() int {
	return m.Size()
}
func (m *UndefinedParameterType) XXX_DiscardUnknown() {
	xxx_messageInfo_UndefinedParameterType.DiscardUnknown(m)
}

var xxx_messageInfo_UndefinedParameterType proto.InternalMessageInfo

func (m *UndefinedParameterType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UndefinedParameterType) GetExpression() string {
	if m != nil {
		return m.Expression
	}
	return ""
}

type ParseError struct {
	Source  *SourceReference `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Message string           `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ParseError) Reset()         { *m = ParseError{} }
func (m *ParseError) String() string { return proto.CompactTextString(m) }
func (*ParseError) ProtoMessage()    {}
func (*ParseError) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{22}
}
func (m *ParseError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParseError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParseError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParseError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParseError.Merge(m, src)
}
func (m *ParseError) XXX_Size() int {
	return m.Size()
}
func (m *ParseError) XXX_DiscardUnknown() {
	xxx_messageInfo_ParseError.DiscardUnknown(m)
}

var xxx_messageInfo_ParseError proto.InternalMessageInfo

func (m *ParseError) GetSource() *SourceReference {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *ParseError) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("io.cucumber.messages.Attachment_ContentEncoding", Attachment_ContentEncoding_name, Attachment_ContentEncoding_value)
	proto.RegisterEnum("io.cucumber.messages.TestStepFinished_TestStepResult_Status", TestStepFinished_TestStepResult_Status_name, TestStepFinished_TestStepResult_Status_value)
	proto.RegisterEnum("io.cucumber.messages.StepDefinition_StepDefinitionPattern_StepDefinitionPatternType", StepDefinition_StepDefinitionPattern_StepDefinitionPatternType_name, StepDefinition_StepDefinitionPattern_StepDefinitionPatternType_value)
	proto.RegisterType((*Envelope)(nil), "io.cucumber.messages.Envelope")
	proto.RegisterType((*Meta)(nil), "io.cucumber.messages.Meta")
	proto.RegisterType((*Meta_Product)(nil), "io.cucumber.messages.Meta.Product")
	proto.RegisterType((*Meta_CI)(nil), "io.cucumber.messages.Meta.CI")
	proto.RegisterType((*Meta_CI_Git)(nil), "io.cucumber.messages.Meta.CI.Git")
	proto.RegisterType((*Timestamp)(nil), "io.cucumber.messages.Timestamp")
	proto.RegisterType((*Duration)(nil), "io.cucumber.messages.Duration")
	proto.RegisterType((*Location)(nil), "io.cucumber.messages.Location")
	proto.RegisterType((*SourceReference)(nil), "io.cucumber.messages.SourceReference")
	proto.RegisterType((*SourceReference_JavaMethod)(nil), "io.cucumber.messages.SourceReference.JavaMethod")
	proto.RegisterType((*SourceReference_JavaStackTraceElement)(nil), "io.cucumber.messages.SourceReference.JavaStackTraceElement")
	proto.RegisterType((*Source)(nil), "io.cucumber.messages.Source")
	proto.RegisterType((*GherkinDocument)(nil), "io.cucumber.messages.GherkinDocument")
	proto.RegisterType((*GherkinDocument_Comment)(nil), "io.cucumber.messages.GherkinDocument.Comment")
	proto.RegisterType((*GherkinDocument_Feature)(nil), "io.cucumber.messages.GherkinDocument.Feature")
	proto.RegisterType((*GherkinDocument_Feature_Tag)(nil), "io.cucumber.messages.GherkinDocument.Feature.Tag")
	proto.RegisterType((*GherkinDocument_Feature_FeatureChild)(nil), "io.cucumber.messages.GherkinDocument.Feature.FeatureChild")
	proto.RegisterType((*GherkinDocument_Feature_FeatureChild_Rule)(nil), "io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule")
	proto.RegisterType((*GherkinDocument_Feature_FeatureChild_RuleChild)(nil), "io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild")
	proto.RegisterType((*GherkinDocument_Feature_Background)(nil), "io.cucumber.messages.GherkinDocument.Feature.Background")
	proto.RegisterType((*GherkinDocument_Feature_Scenario)(nil), "io.cucumber.messages.GherkinDocument.Feature.Scenario")
	proto.RegisterType((*GherkinDocument_Feature_Scenario_Examples)(nil), "io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples")
	proto.RegisterType((*GherkinDocument_Feature_TableRow)(nil), "io.cucumber.messages.GherkinDocument.Feature.TableRow")
	proto.RegisterType((*GherkinDocument_Feature_TableRow_TableCell)(nil), "io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell")
	proto.RegisterType((*GherkinDocument_Feature_Step)(nil), "io.cucumber.messages.GherkinDocument.Feature.Step")
	proto.RegisterType((*GherkinDocument_Feature_Step_DataTable)(nil), "io.cucumber.messages.GherkinDocument.Feature.Step.DataTable")
	proto.RegisterType((*GherkinDocument_Feature_Step_DocString)(nil), "io.cucumber.messages.GherkinDocument.Feature.Step.DocString")
	proto.RegisterType((*Attachment)(nil), "io.cucumber.messages.Attachment")
	proto.RegisterType((*Pickle)(nil), "io.cucumber.messages.Pickle")
	proto.RegisterType((*Pickle_PickleTag)(nil), "io.cucumber.messages.Pickle.PickleTag")
	proto.RegisterType((*Pickle_PickleStep)(nil), "io.cucumber.messages.Pickle.PickleStep")
	proto.RegisterType((*PickleStepArgument)(nil), "io.cucumber.messages.PickleStepArgument")
	proto.RegisterType((*PickleStepArgument_PickleDocString)(nil), "io.cucumber.messages.PickleStepArgument.PickleDocString")
	proto.RegisterType((*PickleStepArgument_PickleTable)(nil), "io.cucumber.messages.PickleStepArgument.PickleTable")
	proto.RegisterType((*PickleStepArgument_PickleTable_PickleTableRow)(nil), "io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow")
	proto.RegisterType((*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell)(nil), "io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell")
	proto.RegisterType((*TestCase)(nil), "io.cucumber.messages.TestCase")
	proto.RegisterType((*TestCase_TestStep)(nil), "io.cucumber.messages.TestCase.TestStep")
	proto.RegisterType((*TestCase_TestStep_StepMatchArgumentsList)(nil), "io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList")
	proto.RegisterType((*TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument)(nil), "io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument")
	proto.RegisterType((*TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group)(nil), "io.cucumber.messages.TestCase.TestStep.StepMatchArgumentsList.StepMatchArgument.Group")
	proto.RegisterType((*TestRunStarted)(nil), "io.cucumber.messages.TestRunStarted")
	proto.RegisterType((*TestCaseStarted)(nil), "io.cucumber.messages.TestCaseStarted")
	proto.RegisterType((*TestCaseFinished)(nil), "io.cucumber.messages.TestCaseFinished")
	proto.RegisterType((*TestStepStarted)(nil), "io.cucumber.messages.TestStepStarted")
	proto.RegisterType((*TestStepFinished)(nil), "io.cucumber.messages.TestStepFinished")
	proto.RegisterType((*TestStepFinished_TestStepResult)(nil), "io.cucumber.messages.TestStepFinished.TestStepResult")
	proto.RegisterType((*TestRunFinished)(nil), "io.cucumber.messages.TestRunFinished")
	proto.RegisterType((*Hook)(nil), "io.cucumber.messages.Hook")
	proto.RegisterType((*StepDefinition)(nil), "io.cucumber.messages.StepDefinition")
	proto.RegisterType((*StepDefinition_StepDefinitionPattern)(nil), "io.cucumber.messages.StepDefinition.StepDefinitionPattern")
	proto.RegisterType((*ParameterType)(nil), "io.cucumber.messages.ParameterType")
	proto.RegisterType((*UndefinedParameterType)(nil), "io.cucumber.messages.UndefinedParameterType")
	proto.RegisterType((*ParseError)(nil), "io.cucumber.messages.ParseError")
}

func init() { proto.RegisterFile("messages.proto", fileDescriptor_4dc296cbfe5ffcd5) }

var fileDescriptor_4dc296cbfe5ffcd5 = []byte{
	// 2923 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0xcd, 0x6f, 0x23, 0xc7,
	0xb1, 0xd7, 0xf0, 0x9b, 0x25, 0x89, 0xe4, 0xb6, 0xd7, 0x32, 0x3d, 0xb6, 0xe5, 0x7d, 0xf4, 0xd7,
	0x3e, 0xbc, 0x67, 0xda, 0x6f, 0xbd, 0x6f, 0x13, 0xac, 0xed, 0x38, 0xfa, 0xa0, 0x24, 0xae, 0xb5,
	0x5a, 0xa1, 0x29, 0xad, 0xb3, 0x36, 0x8c, 0xc9, 0x68, 0xa6, 0x97, 0x1a, 0x6b, 0xc8, 0x21, 0x66,
	0x7a, 0xb4, 0x5e, 0xe4, 0x14, 0xc3, 0x08, 0x82, 0x00, 0x81, 0x03, 0xe4, 0x92, 0x53, 0x02, 0x24,
	0x01, 0x72, 0xca, 0x25, 0x01, 0x9c, 0x7f, 0x20, 0x08, 0x0c, 0xf8, 0x62, 0xc0, 0x39, 0x04, 0x48,
	0x0e, 0x81, 0x7d, 0xc8, 0x3d, 0xd7, 0x5c, 0x82, 0xfe, 0x1a, 0xce, 0x0c, 0x3f, 0x96, 0x12, 0xd7,
	0x80, 0x91, 0x13, 0xa7, 0x6b, 0xaa, 0x7e, 0x5d, 0x55, 0x5d, 0x55, 0x53, 0xdd, 0x4d, 0xa8, 0xf4,
	0x48, 0x10, 0x98, 0x5d, 0x12, 0x34, 0x07, 0xbe, 0x47, 0x3d, 0x74, 0xd1, 0xf1, 0x9a, 0x56, 0x68,
	0x85, 0xbd, 0x23, 0xe2, 0x37, 0xd5, 0xbb, 0xc6, 0x47, 0x00, 0xa5, 0x56, 0xff, 0x94, 0xb8, 0xde,
	0x80, 0xa0, 0x6b, 0x50, 0x08, 0xbc, 0xd0, 0xb7, 0x48, 0x5d, 0xbb, 0xa4, 0x5d, 0x5e, 0xbc, 0xf2,
	0x64, 0x73, 0x9c, 0x4c, 0xb3, 0xc3, 0x79, 0x76, 0x16, 0xb0, 0xe4, 0x46, 0x18, 0x6a, 0xdd, 0x63,
	0xe2, 0x9f, 0x38, 0x7d, 0xc3, 0xf6, 0xac, 0xb0, 0x47, 0xfa, 0xb4, 0x9e, 0xe1, 0x08, 0xcf, 0x8d,
	0x47, 0xd8, 0x16, 0xdc, 0x9b, 0x92, 0x79, 0x67, 0x01, 0x57, 0xbb, 0x49, 0x12, 0xd3, 0x65, 0xe0,
	0x58, 0x27, 0x2e, 0xa9, 0x67, 0xa7, 0xe9, 0xb2, 0xcf, 0x79, 0x98, 0x2e, 0x82, 0x1b, 0xdd, 0x82,
	0x6a, 0x40, 0xc9, 0xc0, 0xb0, 0xc9, 0x5d, 0xa7, 0xef, 0x50, 0xc7, 0xeb, 0xd7, 0x73, 0x1c, 0xe0,
	0xd9, 0x09, 0xc6, 0x50, 0x32, 0xd8, 0x8c, 0x78, 0x77, 0x16, 0x70, 0x25, 0x48, 0x50, 0xd0, 0xcb,
	0x90, 0x3b, 0xf6, 0xbc, 0x93, 0x7a, 0x9e, 0xa3, 0xe8, 0xe3, 0x51, 0x76, 0x3c, 0xef, 0x64, 0x67,
	0x01, 0x73, 0x4e, 0xb4, 0x0b, 0x95, 0x81, 0xe9, 0x9b, 0x3d, 0x42, 0x89, 0x6f, 0xd0, 0xfb, 0x03,
	0x52, 0x2f, 0x70, 0xd9, 0x67, 0x26, 0x98, 0xa0, 0x78, 0x0f, 0xee, 0x0f, 0x98, 0x25, 0xcb, 0x83,
	0x38, 0x01, 0xbd, 0x0e, 0x65, 0x4a, 0x02, 0x6a, 0x58, 0x66, 0x40, 0xea, 0x45, 0x0e, 0xb4, 0x3a,
	0x1e, 0xe8, 0x80, 0x04, 0x74, 0xc3, 0x0c, 0x18, 0x46, 0x89, 0xca, 0x67, 0x74, 0x0c, 0xf5, 0xb0,
	0xcf, 0x9d, 0x41, 0x6c, 0x23, 0xa5, 0x56, 0x89, 0xa3, 0xfd, 0xef, 0x78, 0xb4, 0x43, 0x25, 0x95,
	0xd6, 0x6f, 0x25, 0x1c, 0xfb, 0x06, 0xed, 0x43, 0x8d, 0x2b, 0xea, 0x87, 0x7d, 0x23, 0xa0, 0xa6,
	0x4f, 0x89, 0x5d, 0x2f, 0x4f, 0x73, 0x3d, 0xd3, 0x17, 0x87, 0xfd, 0x8e, 0xe0, 0x65, 0xae, 0xa7,
	0x09, 0x0a, 0xea, 0xc0, 0x85, 0xc8, 0xf4, 0x08, 0x12, 0xa6, 0x05, 0x96, 0x72, 0xc1, 0x10, 0xb3,
	0x4a, 0x93, 0xa4, 0x08, 0x94, 0x47, 0x89, 0x02, 0x5d, 0x7c, 0x10, 0x28, 0x0b, 0x93, 0x14, 0x68,
	0x8c, 0x84, 0xd6, 0x01, 0x4c, 0x4a, 0x4d, 0xeb, 0x98, 0xc7, 0xfe, 0x12, 0x47, 0xbb, 0x34, 0x1e,
	0x6d, 0x2d, 0xe2, 0xdb, 0x59, 0xc0, 0x31, 0x29, 0x74, 0x1b, 0xd0, 0x50, 0x31, 0x16, 0x7e, 0xc1,
	0x31, 0xb1, 0xeb, 0xcb, 0x1c, 0xeb, 0xf9, 0xe9, 0x9a, 0x6d, 0x49, 0xee, 0x9d, 0x05, 0x5c, 0xa3,
	0x29, 0x5a, 0x84, 0xcb, 0xbd, 0x18, 0xe1, 0x56, 0x1e, 0x84, 0xcb, 0x7c, 0x96, 0xc6, 0x8d, 0xd3,
	0x22, 0x47, 0xb2, 0xf5, 0x8e, 0x60, 0xab, 0x0f, 0x72, 0x24, 0x0e, 0xfb, 0x31, 0xd4, 0x2a, 0x4d,
	0x92, 0xd0, 0x06, 0x2c, 0x0e, 0x4c, 0x3f, 0x20, 0x06, 0xf1, 0x7d, 0xcf, 0xaf, 0xd7, 0xa6, 0x79,
	0x72, 0x9f, 0x31, 0xb6, 0x18, 0x1f, 0xf3, 0xe4, 0x20, 0x1a, 0xb1, 0x94, 0xed, 0x11, 0x6a, 0xd6,
	0x2f, 0x4c, 0x4b, 0xd9, 0x9b, 0x84, 0x9a, 0x2c, 0x65, 0x19, 0xe7, 0x7a, 0x19, 0x8a, 0xf2, 0x45,
	0xe3, 0xcf, 0x39, 0xc8, 0xb1, 0x77, 0xe8, 0xbf, 0xa1, 0xc6, 0x2b, 0xa7, 0xe5, 0xb9, 0xc6, 0x29,
	0xf1, 0x03, 0x56, 0x4a, 0x58, 0x5d, 0x2c, 0xe3, 0xaa, 0xa2, 0xdf, 0x16, 0x64, 0x74, 0x03, 0x2a,
	0x4e, 0x6f, 0xe0, 0x12, 0xb6, 0x8e, 0x26, 0xaf, 0x39, 0xa2, 0xfc, 0x35, 0x26, 0x4f, 0xdd, 0xdc,
	0xf7, 0x3d, 0x3b, 0xb4, 0x28, 0x4e, 0x49, 0xa2, 0xd7, 0xa0, 0xe8, 0x87, 0x7d, 0xea, 0xf4, 0x54,
	0xe5, 0x9b, 0x05, 0x44, 0x89, 0xa0, 0x2b, 0x90, 0xf1, 0x02, 0x59, 0xf1, 0x66, 0x11, 0xcc, 0x78,
	0x01, 0xba, 0x0a, 0x59, 0x6b, 0x10, 0xca, 0x02, 0x37, 0x8b, 0x10, 0x63, 0x47, 0x2f, 0x42, 0xc6,
	0x72, 0x64, 0x65, 0x7b, 0x6a, 0x8a, 0xd0, 0x46, 0x1b, 0x67, 0x2c, 0x47, 0xff, 0x06, 0x14, 0xa5,
	0x38, 0x42, 0x90, 0xeb, 0x9b, 0x3d, 0x22, 0x9d, 0xc9, 0x9f, 0x51, 0x1d, 0x8a, 0xca, 0xc7, 0x19,
	0x4e, 0x56, 0x43, 0xfd, 0x8f, 0x1a, 0x64, 0x36, 0xda, 0x63, 0x85, 0x6a, 0x90, 0x0d, 0x7d, 0x57,
	0x0a, 0xb0, 0x47, 0xf4, 0x0a, 0x64, 0xbb, 0x0e, 0x95, 0x8e, 0xfb, 0xaf, 0xa9, 0x5a, 0x35, 0xb7,
	0x1d, 0x8a, 0x19, 0xb7, 0x6e, 0x41, 0x76, 0xdb, 0xa1, 0x68, 0x05, 0x0a, 0x3e, 0xe9, 0x79, 0x54,
	0xcd, 0x21, 0x47, 0x48, 0x87, 0x92, 0x4f, 0x4e, 0x9d, 0x98, 0x6e, 0xd1, 0x98, 0xc9, 0x1c, 0xf9,
	0x66, 0xdf, 0x3a, 0xe6, 0x53, 0x96, 0xb1, 0x1c, 0x31, 0xcd, 0xa8, 0xd9, 0xe5, 0xeb, 0x50, 0xc6,
	0xec, 0xb1, 0xf1, 0x2a, 0x94, 0x0f, 0x9c, 0x1e, 0x09, 0xa8, 0xd9, 0x1b, 0x30, 0x6b, 0x03, 0x62,
	0x79, 0x7d, 0x3b, 0xe0, 0x73, 0x65, 0xb1, 0x1a, 0xa2, 0x8b, 0x90, 0xef, 0x9b, 0x7d, 0x2f, 0xe0,
	0x33, 0xe5, 0xb1, 0x18, 0x34, 0xae, 0x43, 0x69, 0x33, 0xf4, 0x45, 0x7c, 0x9c, 0x55, 0xf6, 0x1a,
	0x94, 0x76, 0x3d, 0x4b, 0xc8, 0x22, 0xc8, 0xb9, 0x4e, 0x5f, 0x18, 0xb8, 0x8c, 0xf9, 0x33, 0x33,
	0xc1, 0xf2, 0xdc, 0xb0, 0x27, 0x8c, 0x5b, 0xc6, 0x72, 0xd4, 0xf8, 0x38, 0x07, 0x55, 0xf1, 0xa5,
	0xc7, 0xe4, 0x2e, 0xf1, 0x49, 0xdf, 0x22, 0x08, 0x31, 0x87, 0x3b, 0xc2, 0x3f, 0x3b, 0x0b, 0xcc,
	0xe5, 0x0e, 0xea, 0xc0, 0xe2, 0x7b, 0xe6, 0xa9, 0x69, 0xf4, 0x08, 0x3d, 0xf6, 0x6c, 0xe9, 0xfa,
	0x97, 0xa7, 0x75, 0x0e, 0x11, 0x5e, 0xf3, 0x86, 0x79, 0x6a, 0xde, 0xe4, 0x72, 0x2c, 0x83, 0xdf,
	0x8b, 0x46, 0xe8, 0x14, 0xea, 0x1c, 0x34, 0xa0, 0xa6, 0x75, 0x62, 0x50, 0xdf, 0xb4, 0x88, 0x41,
	0x44, 0x96, 0xc8, 0xe0, 0x7e, 0x75, 0xf6, 0x19, 0x3a, 0x0c, 0xe4, 0x80, 0x61, 0xb4, 0x04, 0xc4,
	0xce, 0x02, 0x7e, 0xf4, 0xbd, 0x71, 0x2f, 0xd0, 0x75, 0x28, 0xb9, 0xd2, 0x59, 0x32, 0x85, 0x27,
	0x7c, 0x6b, 0x95, 0x4b, 0x71, 0xc4, 0xaf, 0x7f, 0xa0, 0x01, 0x0c, 0x0d, 0x42, 0x4f, 0x01, 0x58,
	0xae, 0x19, 0x04, 0x46, 0x2c, 0x6c, 0xcb, 0x9c, 0xb2, 0xc7, 0x62, 0xf7, 0x69, 0x58, 0x14, 0x1e,
	0x13, 0xef, 0x45, 0x60, 0x81, 0x20, 0x71, 0x86, 0xab, 0xb0, 0x22, 0x19, 0x92, 0x5f, 0xed, 0xa0,
	0x9e, 0xbd, 0x94, 0xbd, 0x5c, 0xc6, 0x17, 0xc5, 0xdb, 0xc4, 0x37, 0x38, 0xd0, 0x29, 0x3c, 0x3a,
	0xd6, 0xe4, 0xb9, 0xd5, 0x79, 0x02, 0xca, 0x77, 0x1d, 0x97, 0x88, 0xd7, 0x22, 0xd8, 0x4b, 0x8c,
	0xc0, 0x5e, 0xae, 0x2f, 0x42, 0xd9, 0x57, 0x2e, 0x6f, 0xdc, 0x84, 0x82, 0x58, 0x05, 0x91, 0x9f,
	0x32, 0x5c, 0x44, 0xb0, 0x20, 0xc8, 0xd9, 0x26, 0x35, 0x25, 0x3e, 0x7f, 0x66, 0x9a, 0xf5, 0x88,
	0xed, 0x98, 0xa2, 0x27, 0x11, 0xd0, 0x65, 0x4e, 0x61, 0x26, 0x35, 0x3e, 0x79, 0x02, 0xaa, 0xa9,
	0x7e, 0x71, 0x0c, 0xf0, 0x36, 0x14, 0xef, 0x12, 0x93, 0x86, 0x3e, 0x91, 0xeb, 0xf6, 0xe2, 0x4c,
	0x9d, 0x67, 0x73, 0x4b, 0x08, 0x61, 0x25, 0x8d, 0xda, 0x50, 0xb2, 0xbc, 0x1e, 0x7b, 0x27, 0x1c,
	0x3d, 0x33, 0xd2, 0x86, 0x90, 0xc2, 0x91, 0xb8, 0x7e, 0x07, 0x8a, 0x92, 0x98, 0x88, 0x2b, 0xed,
	0x6c, 0x71, 0xc5, 0x7c, 0x46, 0xc9, 0xfb, 0x54, 0xf9, 0x8c, 0x3d, 0xeb, 0xbf, 0x7f, 0x1c, 0x8a,
	0x52, 0xf5, 0xb9, 0xb0, 0x5b, 0x90, 0xa3, 0x66, 0x97, 0x55, 0x0c, 0x66, 0xe9, 0xff, 0x9d, 0xc9,
	0x67, 0xcd, 0x03, 0xb3, 0x8b, 0xb9, 0x38, 0x2b, 0x91, 0xae, 0xd9, 0xef, 0x86, 0x66, 0x37, 0x8a,
	0x0d, 0x35, 0x66, 0xf5, 0xea, 0x84, 0xdc, 0xbf, 0xe7, 0xf9, 0xb6, 0x2c, 0x87, 0x6a, 0x18, 0x95,
	0xf4, 0x7c, 0xac, 0xa4, 0x5f, 0x82, 0x45, 0x9b, 0x04, 0x96, 0xef, 0x0c, 0xb8, 0x3d, 0x05, 0xfe,
	0x2a, 0x4e, 0x42, 0xb7, 0xa1, 0x64, 0x1d, 0x3b, 0xae, 0xed, 0x93, 0x7e, 0xbd, 0xc8, 0xd5, 0xbe,
	0x7e, 0x36, 0xb5, 0xe5, 0xef, 0x06, 0x03, 0xc1, 0x11, 0x96, 0x4e, 0x20, 0x7b, 0x60, 0x76, 0xe7,
	0x5d, 0xa9, 0x58, 0xf6, 0x08, 0x83, 0x2a, 0x90, 0x71, 0x6c, 0xe9, 0x94, 0x8c, 0x63, 0xeb, 0x7f,
	0x28, 0xc0, 0x52, 0x5c, 0x03, 0x74, 0x08, 0x39, 0x3f, 0x74, 0xd5, 0x96, 0xeb, 0x8d, 0xf3, 0xdb,
	0xd2, 0xc4, 0x21, 0xdf, 0x09, 0x71, 0x38, 0xf4, 0x36, 0xc0, 0x91, 0x69, 0x9d, 0x74, 0x7d, 0x2f,
	0xec, 0xdb, 0x32, 0x27, 0xbe, 0x79, 0x36, 0xf0, 0xf5, 0x48, 0x9e, 0x55, 0xe7, 0x21, 0x1a, 0x3a,
	0x80, 0x52, 0x60, 0x91, 0xbe, 0xe9, 0x3b, 0x9e, 0xac, 0xf7, 0xd7, 0xce, 0x86, 0xdc, 0x91, 0xd2,
	0x6c, 0xa7, 0xa2, 0x90, 0xf4, 0x4f, 0x33, 0x90, 0x63, 0x26, 0xcc, 0xb5, 0x04, 0xb1, 0x68, 0xcb,
	0x8c, 0x8f, 0xb6, 0xec, 0xe4, 0x68, 0xcb, 0x8d, 0x46, 0xdb, 0x77, 0x63, 0xd1, 0x96, 0xe7, 0xd1,
	0xb6, 0x39, 0xe7, 0x0a, 0xa5, 0xe2, 0x4e, 0x06, 0x48, 0x41, 0x05, 0x48, 0x94, 0x92, 0xc5, 0xb9,
	0x52, 0x52, 0xff, 0x93, 0x06, 0xe5, 0x68, 0xba, 0x54, 0x34, 0x68, 0x5f, 0x59, 0x34, 0x64, 0x1e,
	0x56, 0x34, 0xac, 0x17, 0x21, 0x7f, 0x6a, 0xba, 0x21, 0x89, 0x1e, 0xf4, 0x7f, 0x6a, 0x00, 0x43,
	0x25, 0xbe, 0x56, 0x51, 0xb2, 0x03, 0x79, 0xb6, 0x6b, 0x0b, 0x64, 0x88, 0x5c, 0x39, 0xa3, 0xfd,
	0x94, 0x0c, 0xb0, 0x00, 0x48, 0x47, 0x83, 0xfe, 0x71, 0x01, 0x4a, 0xca, 0x3f, 0x5f, 0x87, 0x4a,
	0x1f, 0xf3, 0x5c, 0x76, 0xbc, 0xe7, 0x72, 0x93, 0x3d, 0x97, 0x9f, 0xe2, 0xb9, 0xc2, 0xbc, 0x9e,
	0x7b, 0x07, 0x4a, 0xe4, 0x7d, 0x93, 0xed, 0xa5, 0x54, 0xee, 0xbc, 0x71, 0xbe, 0x30, 0x6c, 0xb6,
	0x24, 0x0c, 0x8e, 0x00, 0xe5, 0xb2, 0x94, 0xa2, 0x65, 0xf9, 0x45, 0x16, 0x4a, 0x8a, 0xed, 0x3f,
	0x71, 0x59, 0xee, 0xc0, 0x12, 0x35, 0x8f, 0x5c, 0x62, 0x1c, 0x13, 0xd3, 0x26, 0xbe, 0xdc, 0xe6,
	0x5d, 0x3b, 0xab, 0x7a, 0x47, 0x2e, 0xc1, 0xde, 0x3d, 0xbc, 0xc8, 0xb1, 0x76, 0x38, 0x14, 0x3a,
	0x04, 0x10, 0xd0, 0x47, 0x9e, 0x7d, 0x5f, 0xae, 0xd4, 0x79, 0x81, 0xcb, 0x1c, 0x69, 0xdd, 0xb3,
	0xef, 0x8f, 0xac, 0xd0, 0x8f, 0x33, 0x50, 0x52, 0x7c, 0x73, 0xad, 0xd0, 0x6d, 0xc8, 0x5b, 0xc4,
	0x75, 0xd5, 0x12, 0x7d, 0xfb, 0x7c, 0xaa, 0x8a, 0x87, 0x0d, 0xe2, 0xba, 0x58, 0xc0, 0x8d, 0x34,
	0x06, 0xef, 0x42, 0x39, 0xe2, 0x99, 0x4b, 0xe1, 0x8b, 0xb2, 0x60, 0xca, 0xd2, 0x26, 0xab, 0xe7,
	0xf7, 0xf3, 0x90, 0x63, 0xe9, 0xf2, 0xd5, 0xd5, 0x4d, 0xde, 0xa4, 0x66, 0x87, 0x4d, 0x2a, 0x7a,
	0x17, 0xc0, 0xf6, 0x2c, 0x23, 0xa0, 0xbe, 0xd3, 0xef, 0xca, 0x6d, 0xdb, 0x6b, 0x67, 0x4f, 0xf0,
	0xe6, 0xa6, 0x67, 0x75, 0x38, 0xc6, 0xce, 0x02, 0x2e, 0xdb, 0x6a, 0xc0, 0xe1, 0x4d, 0x6a, 0x1a,
	0x3c, 0x06, 0xe4, 0xe9, 0xc5, 0xb9, 0xe0, 0x4d, 0x6a, 0x72, 0xcf, 0x73, 0x78, 0x35, 0x18, 0xa9,
	0xc4, 0x3f, 0xd5, 0xa0, 0x1c, 0xb1, 0xce, 0xe5, 0xc5, 0x1b, 0x90, 0xf3, 0xbd, 0x7b, 0x2a, 0xa0,
	0xce, 0x1b, 0xfb, 0x1c, 0x43, 0xff, 0x39, 0xd3, 0x2a, 0x72, 0xc9, 0x3c, 0x5a, 0x25, 0xb7, 0x61,
	0x99, 0xd4, 0x36, 0x8c, 0x2d, 0xbd, 0xe5, 0xf5, 0x29, 0xdb, 0x80, 0xcb, 0x0a, 0x23, 0x87, 0xe8,
	0x49, 0x28, 0xdb, 0xc4, 0x75, 0x7a, 0x0e, 0x25, 0xbe, 0x2c, 0x33, 0x43, 0xc2, 0x3a, 0x40, 0xc9,
	0xf4, 0xbb, 0xdc, 0x86, 0xc6, 0x8f, 0xb2, 0x00, 0xc3, 0xe3, 0x4f, 0xf4, 0x7a, 0xea, 0xba, 0xe1,
	0xb9, 0x99, 0xb6, 0xf4, 0xd1, 0xad, 0xc3, 0x25, 0x58, 0x1a, 0x9e, 0x97, 0x3a, 0x2a, 0x22, 0x41,
	0x9d, 0x7f, 0xb6, 0x6d, 0xf4, 0x12, 0x5c, 0x1c, 0x39, 0x3f, 0x36, 0xa2, 0xa4, 0xbb, 0x90, 0x3a,
	0x19, 0x6e, 0xf3, 0x28, 0xe6, 0x55, 0x49, 0x16, 0x4b, 0xf6, 0x9c, 0xf2, 0x4b, 0x3e, 0xed, 0x97,
	0x77, 0xa0, 0x26, 0x1d, 0x61, 0x90, 0xbe, 0xe5, 0xd9, 0x2c, 0xd4, 0x59, 0xd0, 0x54, 0x26, 0x9d,
	0x81, 0x0c, 0x1d, 0xd0, 0xdc, 0x10, 0x82, 0x2d, 0x29, 0x87, 0xab, 0x56, 0x92, 0x90, 0xdc, 0x74,
	0x17, 0x93, 0x9b, 0x6e, 0x75, 0xfa, 0x55, 0x8a, 0x4e, 0xbf, 0x1a, 0xff, 0x03, 0xd5, 0x14, 0x24,
	0x5a, 0x82, 0x52, 0x7b, 0xb3, 0xb5, 0x77, 0xd0, 0x3e, 0xb8, 0x53, 0x5b, 0x40, 0x00, 0x85, 0xf5,
	0xb5, 0x4e, 0xeb, 0xda, 0xd5, 0x9a, 0xd6, 0xf8, 0x3c, 0x0b, 0x05, 0x71, 0x7b, 0x22, 0x43, 0x5d,
	0x8b, 0x5a, 0x50, 0xb9, 0xbd, 0xce, 0x24, 0xf6, 0xed, 0x23, 0x6d, 0x51, 0x7c, 0xd3, 0x97, 0x4b,
	0x6d, 0xfa, 0x5e, 0x4f, 0x36, 0x44, 0x2f, 0x4c, 0xbb, 0xbc, 0x91, 0x3f, 0xf1, 0x6f, 0xf9, 0x75,
	0xf9, 0x55, 0x14, 0x4d, 0xc1, 0xf3, 0x33, 0x48, 0x0f, 0x3f, 0x85, 0x97, 0x60, 0xc9, 0x0c, 0xa8,
	0xd1, 0xf7, 0x6c, 0x62, 0x38, 0xb6, 0xe8, 0x05, 0xca, 0x18, 0xcc, 0x80, 0xee, 0x79, 0x36, 0x69,
	0xdb, 0x81, 0xfe, 0x06, 0x94, 0x23, 0xa1, 0xb1, 0xe7, 0x8a, 0xab, 0xb0, 0x18, 0x83, 0x50, 0xb9,
	0x10, 0x21, 0xe8, 0x3f, 0xd3, 0x00, 0x86, 0x4a, 0x47, 0xb5, 0x4f, 0x8b, 0xd5, 0xbe, 0xcd, 0x61,
	0xd8, 0xcb, 0xa6, 0xf8, 0xf2, 0x34, 0x2b, 0x18, 0xce, 0x9a, 0xe4, 0xc7, 0x91, 0x64, 0xfa, 0x1b,
	0x31, 0x62, 0x5b, 0x2e, 0x6d, 0x5b, 0xe3, 0xb7, 0x39, 0x40, 0xa3, 0x90, 0xe8, 0x4e, 0xa2, 0x14,
	0x4f, 0xed, 0xff, 0x47, 0xa5, 0x25, 0x69, 0x42, 0x19, 0x3e, 0x4c, 0x94, 0x61, 0x61, 0xeb, 0xd5,
	0x33, 0x42, 0x8f, 0x96, 0x5f, 0xfd, 0x06, 0x54, 0x53, 0xd3, 0xa6, 0x32, 0x51, 0x9b, 0x52, 0xa1,
	0x32, 0x89, 0x0a, 0xc5, 0x7a, 0x81, 0xc5, 0xd8, 0x44, 0xe8, 0x2d, 0x59, 0x80, 0x35, 0x1e, 0x5e,
	0x1b, 0xe7, 0x51, 0x36, 0xfe, 0x3c, 0xac, 0xc6, 0xbf, 0xd6, 0xa0, 0x92, 0x7c, 0x81, 0x1c, 0xd5,
	0x3e, 0x88, 0xc9, 0x3a, 0x0f, 0x61, 0xb2, 0xf8, 0x30, 0xd6, 0x51, 0xe8, 0x2f, 0x28, 0x97, 0x0d,
	0xfb, 0x88, 0xa8, 0x17, 0xd0, 0x62, 0xbd, 0x40, 0xfc, 0xb6, 0xe3, 0x07, 0x45, 0x28, 0xa9, 0xdb,
	0x9e, 0x91, 0x3a, 0xf0, 0x04, 0x94, 0xc5, 0xad, 0xea, 0x30, 0x0b, 0x4a, 0x82, 0xd0, 0xb6, 0xd1,
	0x16, 0x40, 0x54, 0x7e, 0xd5, 0x51, 0xd9, 0x0b, 0xd3, 0xaf, 0x93, 0xa2, 0xfb, 0x2a, 0x5c, 0x56,
	0x55, 0x3a, 0xd0, 0x3f, 0x2c, 0x08, 0x0d, 0x78, 0x2a, 0xa5, 0x35, 0x78, 0x16, 0x2a, 0x52, 0x83,
	0x64, 0x95, 0x5f, 0x1a, 0x44, 0x0e, 0x6b, 0xdb, 0xa8, 0x09, 0x8f, 0xa4, 0xee, 0x7c, 0x79, 0x76,
	0x88, 0x73, 0xd2, 0x0b, 0xc9, 0xfb, 0xdc, 0xb6, 0x1d, 0xa0, 0xef, 0x81, 0xce, 0xf9, 0x7b, 0x26,
	0xb5, 0x8e, 0x0d, 0x95, 0x6d, 0x81, 0xe1, 0x3a, 0x01, 0x15, 0x49, 0xb5, 0x78, 0xe5, 0x5b, 0x33,
	0x9a, 0xc2, 0x7b, 0x88, 0x9b, 0x0c, 0x48, 0xad, 0x5c, 0xb0, 0xeb, 0x04, 0x14, 0x3f, 0x16, 0x8c,
	0xa5, 0x07, 0xe8, 0x31, 0x28, 0x1e, 0x7b, 0xde, 0x09, 0xb3, 0x45, 0x7c, 0x4c, 0x0a, 0x6c, 0xd8,
	0xb6, 0xf5, 0x7f, 0x65, 0x61, 0x65, 0x3c, 0x18, 0xfa, 0x40, 0x83, 0x8b, 0xe3, 0x34, 0x96, 0x41,
	0xb5, 0x3f, 0x9f, 0xae, 0xa3, 0x64, 0x8c, 0x46, 0xb5, 0xd7, 0xff, 0x9a, 0x81, 0x0b, 0x23, 0x9c,
	0xcc, 0xf7, 0xc9, 0xf3, 0xe9, 0xf8, 0x01, 0xf3, 0x85, 0xc4, 0x55, 0x36, 0xff, 0x6a, 0xb9, 0x90,
	0x67, 0x1b, 0xf8, 0x81, 0xac, 0x14, 0xb7, 0x1f, 0xb6, 0xea, 0xcd, 0x6d, 0x86, 0x8e, 0xc5, 0x24,
	0xfa, 0x6f, 0x34, 0xc8, 0x73, 0x02, 0xcb, 0x04, 0xde, 0x01, 0xc8, 0xbb, 0x0f, 0x31, 0x18, 0xdf,
	0x2b, 0x23, 0x3f, 0x76, 0xe8, 0x23, 0x02, 0xfb, 0xab, 0x52, 0x33, 0x9a, 0xa7, 0x71, 0x0b, 0x2a,
	0xc9, 0xfb, 0x70, 0x7e, 0xf1, 0xaf, 0x6e, 0x8c, 0x64, 0xc9, 0x7e, 0x7a, 0x82, 0x1a, 0x8a, 0x0d,
	0x0f, 0x25, 0x1a, 0xbf, 0xd4, 0xa0, 0x9a, 0xba, 0x0e, 0x9f, 0x13, 0x92, 0x55, 0x58, 0x93, 0x52,
	0xd2, 0x1b, 0x88, 0x1e, 0x70, 0x19, 0xab, 0x61, 0xd4, 0x8b, 0xf1, 0x4e, 0xcb, 0x51, 0x27, 0xbd,
	0xa0, 0x3a, 0xac, 0xb6, 0x2d, 0x33, 0x3b, 0xaf, 0x32, 0xfb, 0x46, 0xae, 0x94, 0xa9, 0x65, 0x1b,
	0x3f, 0xd4, 0xa0, 0x96, 0xbe, 0x6c, 0x9e, 0x57, 0xcb, 0xb3, 0x76, 0x7d, 0x52, 0x95, 0x5f, 0x49,
	0x7f, 0xc5, 0xaf, 0xf5, 0xe7, 0xd4, 0xe4, 0xe1, 0x77, 0xa8, 0x8d, 0xcf, 0x73, 0xc2, 0x61, 0x89,
	0x1b, 0x7e, 0x43, 0xfe, 0xf3, 0x82, 0xcf, 0xe3, 0x93, 0x20, 0x74, 0xa9, 0xd4, 0xf6, 0xff, 0x67,
	0xfb, 0xdf, 0xc0, 0xb0, 0x30, 0x73, 0x61, 0xf1, 0x47, 0x8c, 0xe1, 0x38, 0xe9, 0x87, 0xcc, 0xdc,
	0x7e, 0xc8, 0xce, 0xec, 0x87, 0xdc, 0x04, 0x3f, 0xe8, 0x9f, 0x66, 0x44, 0xbe, 0xc4, 0x94, 0x3c,
	0x80, 0x42, 0x40, 0x4d, 0x1a, 0x8a, 0x7b, 0xd1, 0xca, 0xa4, 0xbd, 0xe0, 0x03, 0x6c, 0x6f, 0x76,
	0x38, 0x06, 0x96, 0x58, 0x2c, 0xe6, 0xa5, 0xa8, 0xea, 0x2a, 0xe4, 0x90, 0x6d, 0xb6, 0x6c, 0x79,
	0x29, 0x2b, 0x4f, 0xc1, 0x27, 0x6c, 0xb6, 0xd4, 0xd5, 0x2d, 0x8e, 0xf8, 0xd1, 0xf3, 0x50, 0xbd,
	0xe7, 0xb8, 0xae, 0x71, 0x44, 0x0c, 0x9f, 0x50, 0xdf, 0x21, 0xc2, 0xd4, 0x12, 0x5e, 0x66, 0xe4,
	0x75, 0x82, 0x05, 0xb1, 0x41, 0xa0, 0x20, 0xf4, 0x41, 0x8b, 0x50, 0x3c, 0xdc, 0x7b, 0x73, 0xef,
	0xd6, 0x5b, 0x7b, 0xa2, 0x8f, 0xdf, 0x5f, 0xeb, 0x74, 0x5a, 0x9b, 0x35, 0x8d, 0xbd, 0xe8, 0xbc,
	0xd9, 0xde, 0xdf, 0x6f, 0x6d, 0xd6, 0x32, 0x6c, 0xb0, 0xdf, 0xda, 0xdb, 0x6c, 0xef, 0x6d, 0xd7,
	0xb2, 0x68, 0x19, 0xca, 0x87, 0x7b, 0x9b, 0xad, 0xad, 0xf6, 0x5e, 0x6b, 0xb3, 0x96, 0x63, 0xc3,
	0xb5, 0x9b, 0xeb, 0xed, 0xed, 0xc3, 0x5b, 0x87, 0x9d, 0x5a, 0x9e, 0x61, 0x6c, 0xad, 0xb5, 0x77,
	0x5b, 0x9b, 0xb5, 0x42, 0xe3, 0x43, 0x19, 0xfb, 0xf1, 0x7f, 0x62, 0xd4, 0xa1, 0x18, 0x84, 0x96,
	0x45, 0x02, 0xe1, 0xcf, 0x12, 0x56, 0xc3, 0x79, 0xa3, 0x21, 0xe6, 0xd1, 0x6c, 0xc2, 0xa3, 0x8d,
	0x8f, 0x34, 0xc8, 0xed, 0x78, 0xde, 0xc9, 0x48, 0x1b, 0xf0, 0x1c, 0x54, 0xa8, 0xd9, 0x35, 0xc8,
	0xfb, 0x03, 0x9f, 0x04, 0xb1, 0x8b, 0xf8, 0x65, 0x6a, 0x76, 0x5b, 0x11, 0x11, 0xed, 0x43, 0x4d,
	0xec, 0x0d, 0x8d, 0xe8, 0x36, 0x52, 0xae, 0xcc, 0x8c, 0x5b, 0xcb, 0x6a, 0x90, 0x24, 0x34, 0x7e,
	0x97, 0x85, 0x4a, 0xf2, 0x1f, 0x62, 0x23, 0xba, 0x1d, 0x40, 0x71, 0xc0, 0xca, 0xa0, 0xaf, 0x6e,
	0x8c, 0xaf, 0xcf, 0xf2, 0x47, 0xb3, 0xd4, 0x70, 0x5f, 0x20, 0x60, 0x05, 0xf5, 0xf0, 0x4d, 0xd1,
	0xff, 0xa1, 0xc1, 0xa3, 0x63, 0x27, 0x45, 0x2b, 0x89, 0x7d, 0x78, 0x39, 0xda, 0x60, 0x1f, 0x43,
	0x2e, 0x3a, 0x0b, 0xa8, 0x5c, 0x39, 0x38, 0xbf, 0x59, 0xe3, 0xa9, 0xac, 0x25, 0xc0, 0x7c, 0x86,
	0xc6, 0x2e, 0x3c, 0x3e, 0x91, 0x05, 0x3d, 0x06, 0x8f, 0x6c, 0x1c, 0x6e, 0x1c, 0xde, 0x5c, 0x6f,
	0x61, 0xa3, 0xf5, 0x9d, 0x7d, 0xdc, 0xea, 0x74, 0xda, 0xb7, 0x58, 0x16, 0xac, 0x00, 0xc2, 0xad,
	0xed, 0xc3, 0xdd, 0xb5, 0x04, 0x5d, 0x6b, 0xfc, 0x4d, 0x83, 0xe5, 0xe4, 0x5f, 0xd3, 0xc6, 0x6d,
	0xf2, 0x5e, 0x82, 0x47, 0x7c, 0xd2, 0x0d, 0x5d, 0xd3, 0x8f, 0xc5, 0x95, 0x38, 0x94, 0x29, 0x63,
	0x24, 0x5f, 0x0d, 0x83, 0x2b, 0x40, 0xbb, 0xf0, 0xcc, 0x80, 0x2f, 0x86, 0x71, 0xd7, 0xf3, 0x8d,
	0x51, 0x59, 0xd1, 0x9c, 0xf1, 0x55, 0x2a, 0xe1, 0xa7, 0x05, 0xeb, 0x96, 0xe7, 0xe3, 0x34, 0x12,
	0xef, 0x03, 0xd0, 0x65, 0xa8, 0x85, 0x01, 0xe1, 0x50, 0x41, 0xdf, 0x19, 0x0c, 0x08, 0x0d, 0x64,
	0x09, 0xa8, 0x84, 0x01, 0xd9, 0xf2, 0xfc, 0x8e, 0xa4, 0xa6, 0xbf, 0x9c, 0x8d, 0x5d, 0x58, 0x19,
	0xff, 0xdf, 0xbc, 0x09, 0x7b, 0x59, 0x18, 0x49, 0x9b, 0x18, 0xa5, 0x41, 0x00, 0x86, 0xff, 0xa3,
	0x9a, 0xf7, 0x48, 0x66, 0x62, 0xb1, 0x5c, 0x6f, 0x7c, 0xf2, 0xc5, 0xaa, 0xf6, 0xd9, 0x17, 0xab,
	0xda, 0xdf, 0xbf, 0x58, 0xd5, 0x7e, 0xf2, 0xe5, 0xea, 0xc2, 0x67, 0x5f, 0xae, 0x2e, 0xfc, 0xe5,
	0xcb, 0xd5, 0x85, 0xb7, 0x4b, 0x0a, 0xf5, 0xa8, 0xc0, 0xff, 0x56, 0xf5, 0xca, 0xbf, 0x03, 0x00,
	0x00, 0xff, 0xff, 0x5b, 0xe2, 0x69, 0x4b, 0xba, 0x2a, 0x00, 0x00,
}

func (m *Envelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Envelope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size := m.Message.Size()
			i -= size
			if _, err := m.Message.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Envelope_Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_GherkinDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_GherkinDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GherkinDocument != nil {
		{
			size, err := m.GherkinDocument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_Pickle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_Pickle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Pickle != nil {
		{
			size, err := m.Pickle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_StepDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_StepDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StepDefinition != nil {
		{
			size, err := m.StepDefinition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_Hook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_Hook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Hook != nil {
		{
			size, err := m.Hook.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_ParameterType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_ParameterType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ParameterType != nil {
		{
			size, err := m.ParameterType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestCase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_TestCase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestCase != nil {
		{
			size, err := m.TestCase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_UndefinedParameterType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_UndefinedParameterType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UndefinedParameterType != nil {
		{
			size, err := m.UndefinedParameterType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestRunStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_TestRunStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestRunStarted != nil {
		{
			size, err := m.TestRunStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestCaseStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_TestCaseStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestCaseStarted != nil {
		{
			size, err := m.TestCaseStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestStepStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_TestStepStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestStepStarted != nil {
		{
			size, err := m.TestStepStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_Attachment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_Attachment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Attachment != nil {
		{
			size, err := m.Attachment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestStepFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_TestStepFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestStepFinished != nil {
		{
			size, err := m.TestStepFinished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestCaseFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_TestCaseFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestCaseFinished != nil {
		{
			size, err := m.TestCaseFinished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestRunFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_TestRunFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestRunFinished != nil {
		{
			size, err := m.TestRunFinished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_ParseError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_ParseError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ParseError != nil {
		{
			size, err := m.ParseError.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_Meta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_Meta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Meta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Meta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Meta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ci != nil {
		{
			size, err := m.Ci.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Cpu != nil {
		{
			size, err := m.Cpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Os != nil {
		{
			size, err := m.Os.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Runtime != nil {
		{
			size, err := m.Runtime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Implementation != nil {
		{
			size, err := m.Implementation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProtocolVersion) > 0 {
		i -= len(m.ProtocolVersion)
		copy(dAtA[i:], m.ProtocolVersion)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ProtocolVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Meta_Product) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Meta_Product) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Meta_Product) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Meta_CI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Meta_CI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Meta_CI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Git != nil {
		{
			size, err := m.Git.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Meta_CI_Git) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Meta_CI_Git) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Meta_CI_Git) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Branch) > 0 {
		i -= len(m.Branch)
		copy(dAtA[i:], m.Branch)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Branch)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Revision) > 0 {
		i -= len(m.Revision)
		copy(dAtA[i:], m.Revision)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Revision)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Remote) > 0 {
		i -= len(m.Remote)
		copy(dAtA[i:], m.Remote)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Remote)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nanos != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Nanos))
		i--
		dAtA[i] = 0x10
	}
	if m.Seconds != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Duration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Duration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Duration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nanos != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Nanos))
		i--
		dAtA[i] = 0x10
	}
	if m.Seconds != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Column != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Column))
		i--
		dAtA[i] = 0x10
	}
	if m.Line != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Line))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SourceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reference != nil {
		{
			size := m.Reference.Size()
			i -= size
			if _, err := m.Reference.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SourceReference_Uri) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceReference_Uri) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Uri)
	copy(dAtA[i:], m.Uri)
	i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *SourceReference_JavaMethod_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceReference_JavaMethod_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JavaMethod != nil {
		{
			size, err := m.JavaMethod.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SourceReference_JavaStackTraceElement_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceReference_JavaStackTraceElement_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.JavaStackTraceElement != nil {
		{
			size, err := m.JavaStackTraceElement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *SourceReference_JavaMethod) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceReference_JavaMethod) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceReference_JavaMethod) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MethodParameterTypes) > 0 {
		for iNdEx := len(m.MethodParameterTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MethodParameterTypes[iNdEx])
			copy(dAtA[i:], m.MethodParameterTypes[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.MethodParameterTypes[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.MethodName) > 0 {
		i -= len(m.MethodName)
		copy(dAtA[i:], m.MethodName)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.MethodName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SourceReference_JavaStackTraceElement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceReference_JavaStackTraceElement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceReference_JavaStackTraceElement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MethodName) > 0 {
		i -= len(m.MethodName)
		copy(dAtA[i:], m.MethodName)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.MethodName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClassName) > 0 {
		i -= len(m.ClassName)
		copy(dAtA[i:], m.ClassName)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ClassName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MediaType) > 0 {
		i -= len(m.MediaType)
		copy(dAtA[i:], m.MediaType)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.MediaType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comments) > 0 {
		for iNdEx := len(m.Comments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Comments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Feature != nil {
		{
			size, err := m.Feature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Comment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Comment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Comment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_FeatureChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_FeatureChild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_FeatureChild_Rule_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild_Rule_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rule != nil {
		{
			size, err := m.Rule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_Background) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild_Background) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Background != nil {
		{
			size, err := m.Background.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_Scenario) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild_Scenario) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scenario != nil {
		{
			size, err := m.Scenario.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Background) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Background) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Background != nil {
		{
			size, err := m.Background.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scenario != nil {
		{
			size, err := m.Scenario.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_Background) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Background) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Background) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Scenario) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Scenario) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Scenario) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Examples) > 0 {
		for iNdEx := len(m.Examples) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Examples[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Scenario_Examples) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TableBody) > 0 {
		for iNdEx := len(m.TableBody) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableBody[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.TableHeader != nil {
		{
			size, err := m.TableHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_TableRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_TableRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_TableRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Cells) > 0 {
		for iNdEx := len(m.Cells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_TableRow_TableCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_TableRow_TableCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_TableRow_TableCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Step) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x32
	}
	if m.Argument != nil {
		{
			size := m.Argument.Size()
			i -= size
			if _, err := m.Argument.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Step_DocString_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Step_DocString_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DocString != nil {
		{
			size, err := m.DocString.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_Step_DataTable_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Step_DataTable_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DataTable != nil {
		{
			size, err := m.DataTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_Step_DataTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Step_DataTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Step_DataTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Step_DocString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Step_DocString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Step_DocString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Delimiter) > 0 {
		i -= len(m.Delimiter)
		copy(dAtA[i:], m.Delimiter)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Delimiter)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MediaType) > 0 {
		i -= len(m.MediaType)
		copy(dAtA[i:], m.MediaType)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.MediaType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Attachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attachment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Attachment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ContentEncoding != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.ContentEncoding))
		i--
		dAtA[i] = 0x30
	}
	if len(m.MediaType) > 0 {
		i -= len(m.MediaType)
		copy(dAtA[i:], m.MediaType)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.MediaType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TestCaseStartedId) > 0 {
		i -= len(m.TestCaseStartedId)
		copy(dAtA[i:], m.TestCaseStartedId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseStartedId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TestStepId) > 0 {
		i -= len(m.TestStepId)
		copy(dAtA[i:], m.TestStepId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestStepId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pickle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pickle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pickle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AstNodeIds) > 0 {
		for iNdEx := len(m.AstNodeIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AstNodeIds[iNdEx])
			copy(dAtA[i:], m.AstNodeIds[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.AstNodeIds[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pickle_PickleTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pickle_PickleTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pickle_PickleTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AstNodeId) > 0 {
		i -= len(m.AstNodeId)
		copy(dAtA[i:], m.AstNodeId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.AstNodeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pickle_PickleStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pickle_PickleStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pickle_PickleStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AstNodeIds) > 0 {
		for iNdEx := len(m.AstNodeIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AstNodeIds[iNdEx])
			copy(dAtA[i:], m.AstNodeIds[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.AstNodeIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Argument != nil {
		{
			size, err := m.Argument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PickleStepArgument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size := m.Message.Size()
			i -= size
			if _, err := m.Message.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PickleStepArgument_DocString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument_DocString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DocString != nil {
		{
			size, err := m.DocString.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PickleStepArgument_DataTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument_DataTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DataTable != nil {
		{
			size, err := m.DataTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PickleStepArgument_PickleDocString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleDocString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument_PickleDocString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MediaType) > 0 {
		i -= len(m.MediaType)
		copy(dAtA[i:], m.MediaType)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.MediaType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PickleStepArgument_PickleTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument_PickleTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cells) > 0 {
		for iNdEx := len(m.Cells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestSteps) > 0 {
		for iNdEx := len(m.TestSteps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TestSteps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PickleId) > 0 {
		i -= len(m.PickleId)
		copy(dAtA[i:], m.PickleId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCase_TestStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCase_TestStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCase_TestStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HookId) > 0 {
		i -= len(m.HookId)
		copy(dAtA[i:], m.HookId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.HookId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StepMatchArgumentsLists) > 0 {
		for iNdEx := len(m.StepMatchArgumentsLists) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StepMatchArgumentsLists[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.StepDefinitionIds) > 0 {
		for iNdEx := len(m.StepDefinitionIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StepDefinitionIds[iNdEx])
			copy(dAtA[i:], m.StepDefinitionIds[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.StepDefinitionIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PickleStepId) > 0 {
		i -= len(m.PickleStepId)
		copy(dAtA[i:], m.PickleStepId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleStepId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCase_TestStep_StepMatchArgumentsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCase_TestStep_StepMatchArgumentsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCase_TestStep_StepMatchArgumentsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StepMatchArguments) > 0 {
		for iNdEx := len(m.StepMatchArguments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StepMatchArguments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ParameterTypeName) > 0 {
		i -= len(m.ParameterTypeName)
		copy(dAtA[i:], m.ParameterTypeName)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ParameterTypeName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Start != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestRunStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestRunStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestRunStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCaseStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCaseStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TestCaseId) > 0 {
		i -= len(m.TestCaseId)
		copy(dAtA[i:], m.TestCaseId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Attempt != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Attempt))
		i--
		dAtA[i] = 0x18
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCaseFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCaseFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseStartedId) > 0 {
		i -= len(m.TestCaseStartedId)
		copy(dAtA[i:], m.TestCaseStartedId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseStartedId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestStepStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestStepStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestStepStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseStartedId) > 0 {
		i -= len(m.TestCaseStartedId)
		copy(dAtA[i:], m.TestCaseStartedId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseStartedId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TestStepId) > 0 {
		i -= len(m.TestStepId)
		copy(dAtA[i:], m.TestStepId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestStepId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestStepFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestStepFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestStepFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseStartedId) > 0 {
		i -= len(m.TestCaseStartedId)
		copy(dAtA[i:], m.TestCaseStartedId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseStartedId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TestStepId) > 0 {
		i -= len(m.TestStepId)
		copy(dAtA[i:], m.TestStepId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestStepId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TestStepResult != nil {
		{
			size, err := m.TestStepResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestStepFinished_TestStepResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestStepFinished_TestStepResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestStepFinished_TestStepResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WillBeRetried {
		i--
		if m.WillBeRetried {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Duration != nil {
		{
			size, err := m.Duration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestRunFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestRunFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestRunFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Hook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Hook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SourceReference != nil {
		{
			size, err := m.SourceReference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TagExpression) > 0 {
		i -= len(m.TagExpression)
		copy(dAtA[i:], m.TagExpression)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TagExpression)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StepDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SourceReference != nil {
		{
			size, err := m.SourceReference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Pattern != nil {
		{
			size, err := m.Pattern.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StepDefinition_StepDefinitionPattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepDefinition_StepDefinitionPattern) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepDefinition_StepDefinitionPattern) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParameterType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParameterType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParameterType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x2a
	}
	if m.UseForSnippets {
		i--
		if m.UseForSnippets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PreferForRegularExpressionMatch {
		i--
		if m.PreferForRegularExpressionMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.RegularExpressions) > 0 {
		for iNdEx := len(m.RegularExpressions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RegularExpressions[iNdEx])
			copy(dAtA[i:], m.RegularExpressions[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.RegularExpressions[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UndefinedParameterType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UndefinedParameterType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UndefinedParameterType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Expression) > 0 {
		i -= len(m.Expression)
		copy(dAtA[i:], m.Expression)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Expression)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParseError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParseError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParseError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessages(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessages(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Envelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *Envelope_Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_GherkinDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GherkinDocument != nil {
		l = m.GherkinDocument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_Pickle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pickle != nil {
		l = m.Pickle.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_StepDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StepDefinition != nil {
		l = m.StepDefinition.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_Hook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hook != nil {
		l = m.Hook.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_ParameterType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParameterType != nil {
		l = m.ParameterType.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestCase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestCase != nil {
		l = m.TestCase.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_UndefinedParameterType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UndefinedParameterType != nil {
		l = m.UndefinedParameterType.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestRunStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestRunStarted != nil {
		l = m.TestRunStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestCaseStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestCaseStarted != nil {
		l = m.TestCaseStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestStepStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestStepStarted != nil {
		l = m.TestStepStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_Attachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Attachment != nil {
		l = m.Attachment.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestStepFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestStepFinished != nil {
		l = m.TestStepFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestCaseFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestCaseFinished != nil {
		l = m.TestCaseFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestRunFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestRunFinished != nil {
		l = m.TestRunFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_ParseError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ParseError != nil {
		l = m.ParseError.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_Meta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Meta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProtocolVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Implementation != nil {
		l = m.Implementation.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Runtime != nil {
		l = m.Runtime.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Os != nil {
		l = m.Os.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Ci != nil {
		l = m.Ci.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Meta_Product) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Meta_CI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Git != nil {
		l = m.Git.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Meta_CI_Git) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Remote)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Revision)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovMessages(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovMessages(uint64(m.Nanos))
	}
	return n
}

func (m *Duration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovMessages(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovMessages(uint64(m.Nanos))
	}
	return n
}

func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Line != 0 {
		n += 1 + sovMessages(uint64(m.Line))
	}
	if m.Column != 0 {
		n += 1 + sovMessages(uint64(m.Column))
	}
	return n
}

func (m *SourceReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reference != nil {
		n += m.Reference.Size()
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *SourceReference_Uri) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	n += 1 + l + sovMessages(uint64(l))
	return n
}
func (m *SourceReference_JavaMethod_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JavaMethod != nil {
		l = m.JavaMethod.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *SourceReference_JavaStackTraceElement_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JavaStackTraceElement != nil {
		l = m.JavaStackTraceElement.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *SourceReference_JavaMethod) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.MethodName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.MethodParameterTypes) > 0 {
		for _, s := range m.MethodParameterTypes {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *SourceReference_JavaStackTraceElement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.MethodName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.MediaType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Feature != nil {
		l = m.Feature.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Comments) > 0 {
		for _, e := range m.Comments {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Comment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild_Rule_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rule != nil {
		l = m.Rule.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_Background) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Background != nil {
		l = m.Background.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_Scenario) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scenario != nil {
		l = m.Scenario.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Background) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Background != nil {
		l = m.Background.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scenario != nil {
		l = m.Scenario.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_Background) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_Scenario) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Examples) > 0 {
		for _, e := range m.Examples {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_Scenario_Examples) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.TableHeader != nil {
		l = m.TableHeader.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.TableBody) > 0 {
		for _, e := range m.TableBody {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_TableRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Cells) > 0 {
		for _, e := range m.Cells {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_TableRow_TableCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_Step) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Argument != nil {
		n += m.Argument.Size()
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_Step_DocString_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_Step_DataTable_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_Step_DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_Step_DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.MediaType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Delimiter)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Attachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestStepId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseStartedId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.MediaType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ContentEncoding != 0 {
		n += 1 + sovMessages(uint64(m.ContentEncoding))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Pickle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.AstNodeIds) > 0 {
		for _, s := range m.AstNodeIds {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *Pickle_PickleTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.AstNodeId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Pickle_PickleStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Argument != nil {
		l = m.Argument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.AstNodeIds) > 0 {
		for _, s := range m.AstNodeIds {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleStepArgument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *PickleStepArgument_DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *PickleStepArgument_DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *PickleStepArgument_PickleDocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MediaType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleStepArgument_PickleTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cells) > 0 {
		for _, e := range m.Cells {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.TestSteps) > 0 {
		for _, e := range m.TestSteps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestCase_TestStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.PickleStepId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.StepDefinitionIds) > 0 {
		for _, s := range m.StepDefinitionIds {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.StepMatchArgumentsLists) > 0 {
		for _, e := range m.StepMatchArgumentsLists {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.HookId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCase_TestStep_StepMatchArgumentsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StepMatchArguments) > 0 {
		for _, e := range m.StepMatchArguments {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParameterTypeName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovMessages(uint64(m.Start))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestRunStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCaseStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Attempt != 0 {
		n += 1 + sovMessages(uint64(m.Attempt))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCaseFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseStartedId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestStepStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestStepId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseStartedId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestStepFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestStepResult != nil {
		l = m.TestStepResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestStepId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseStartedId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestStepFinished_TestStepResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovMessages(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.WillBeRetried {
		n += 2
	}
	return n
}

func (m *TestRunFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Hook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TagExpression)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.SourceReference != nil {
		l = m.SourceReference.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *StepDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.SourceReference != nil {
		l = m.SourceReference.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *StepDefinition_StepDefinitionPattern) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	return n
}

func (m *ParameterType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.RegularExpressions) > 0 {
		for _, s := range m.RegularExpressions {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.PreferForRegularExpressionMatch {
		n += 2
	}
	if m.UseForSnippets {
		n += 2
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *UndefinedParameterType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Expression)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *ParseError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func sovMessages(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessages(x uint64) (n int) {
	return sovMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Envelope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Envelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Envelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Source{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Source{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GherkinDocument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_GherkinDocument{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pickle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Pickle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Pickle{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StepDefinition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_StepDefinition{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Hook{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Hook{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParameterType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_ParameterType{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestCase{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UndefinedParameterType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UndefinedParameterType{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_UndefinedParameterType{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestRunStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestRunStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestRunStarted{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCaseStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestCaseStarted{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestStepStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestStepStarted{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Attachment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Attachment{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestStepFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestStepFinished{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCaseFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestCaseFinished{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestRunFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestRunFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestRunFinished{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParseError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ParseError{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_ParseError{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Meta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Meta{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Meta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Meta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Meta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProtocolVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implementation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Implementation == nil {
				m.Implementation = &Meta_Product{}
			}
			if err := m.Implementation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Runtime == nil {
				m.Runtime = &Meta_Product{}
			}
			if err := m.Runtime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &Meta_Product{}
			}
			if err := m.Os.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &Meta_Product{}
			}
			if err := m.Cpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ci", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ci == nil {
				m.Ci = &Meta_CI{}
			}
			if err := m.Ci.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Meta_Product) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Product: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Product: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Meta_CI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Git", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Git == nil {
				m.Git = &Meta_CI_Git{}
			}
			if err := m.Git.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Meta_CI_Git) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Git: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Git: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Duration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Duration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Duration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = &SourceReference_Uri{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaMethod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceReference_JavaMethod{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reference = &SourceReference_JavaMethod_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JavaStackTraceElement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceReference_JavaStackTraceElement{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Reference = &SourceReference_JavaStackTraceElement_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceReference_JavaMethod) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaMethod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaMethod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MethodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodParameterTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MethodParameterTypes = append(m.MethodParameterTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceReference_JavaStackTraceElement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JavaStackTraceElement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JavaStackTraceElement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MethodName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GherkinDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GherkinDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Feature == nil {
				m.Feature = &GherkinDocument_Feature{}
			}
			if err := m.Feature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comments = append(m.Comments, &GherkinDocument_Comment{})
			if err := m.Comments[len(m.Comments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Comment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Comment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Comment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Feature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Feature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &GherkinDocument_Feature_Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &GherkinDocument_Feature_FeatureChild{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_FeatureChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_FeatureChild_Rule{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_Rule_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Background{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_Background{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scenario", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Scenario{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_Scenario{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &GherkinDocument_Feature_FeatureChild_RuleChild{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &GherkinDocument_Feature_Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Background{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_RuleChild_Background{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scenario", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Scenario{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_RuleChild_Scenario{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Background) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Background: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Background: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &GherkinDocument_Feature_Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Scenario) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Scenario: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Scenario: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &GherkinDocument_Feature_Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &GherkinDocument_Feature_Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Examples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Examples = append(m.Examples, &GherkinDocument_Feature_Scenario_Examples{})
			if err := m.Examples[len(m.Examples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Scenario_Examples) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Examples: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Examples: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &GherkinDocument_Feature_Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableHeader == nil {
				m.TableHeader = &GherkinDocument_Feature_TableRow{}
			}
			if err := m.TableHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableBody = append(m.TableBody, &GherkinDocument_Feature_TableRow{})
			if err := m.TableBody[len(m.TableBody)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_TableRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, &GherkinDocument_Feature_TableRow_TableCell{})
			if err := m.Cells[len(m.Cells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_TableRow_TableCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Step_DocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Argument = &GherkinDocument_Feature_Step_DocString_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Step_DataTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Argument = &GherkinDocument_Feature_Step_DataTable_{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Step_DataTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &GherkinDocument_Feature_TableRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Step_DocString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delimiter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delimiter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SourceReference{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestStepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStartedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseStartedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentEncoding", wireType)
			}
			m.ContentEncoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentEncoding |= Attachment_ContentEncoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pickle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pickle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pickle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &Pickle_PickleStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Pickle_PickleTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AstNodeIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AstNodeIds = append(m.AstNodeIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pickle_PickleTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AstNodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AstNodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pickle_PickleStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Argument == nil {
				m.Argument = &PickleStepArgument{}
			}
			if err := m.Argument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AstNodeIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AstNodeIds = append(m.AstNodeIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleStepArgument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleStepArgument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleStepArgument_PickleDocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &PickleStepArgument_DocString{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleStepArgument_PickleTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &PickleStepArgument_DataTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleDocString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleDocString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleDocString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &PickleStepArgument_PickleTable_PickleTableRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTableRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTableRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, &PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell{})
			if err := m.Cells[len(m.Cells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTableCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTableCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestSteps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestSteps = append(m.TestSteps, &TestCase_TestStep{})
			if err := m.TestSteps[len(m.TestSteps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCase_TestStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleStepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleStepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepDefinitionIds = append(m.StepDefinitionIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepMatchArgumentsLists", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepMatchArgumentsLists = append(m.StepMatchArgumentsLists, &TestCase_TestStep_StepMatchArgumentsList{})
			if err := m.StepMatchArgumentsLists[len(m.StepMatchArgumentsLists)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HookId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCase_TestStep_StepMatchArgumentsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepMatchArgumentsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepMatchArgumentsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepMatchArguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepMatchArguments = append(m.StepMatchArguments, &TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument{})
			if err := m.StepMatchArguments[len(m.StepMatchArguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepMatchArgument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepMatchArgument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &TestCase_TestStep_StepMatchArgumentsList_StepMatchArgument_Group{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestRunStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestRunStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestRunStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attempt", wireType)
			}
			m.Attempt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attempt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStartedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseStartedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestStepStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStepStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStepStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestStepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStartedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseStartedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestStepFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStepFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStepFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestStepResult == nil {
				m.TestStepResult = &TestStepFinished_TestStepResult{}
			}
			if err := m.TestStepResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestStepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStartedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseStartedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestStepFinished_TestStepResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStepResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStepResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TestStepFinished_TestStepResult_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &Duration{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WillBeRetried", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WillBeRetried = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestRunFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestRunFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestRunFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Hook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceReference == nil {
				m.SourceReference = &SourceReference{}
			}
			if err := m.SourceReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &StepDefinition_StepDefinitionPattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceReference == nil {
				m.SourceReference = &SourceReference{}
			}
			if err := m.SourceReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepDefinition_StepDefinitionPattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepDefinitionPattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepDefinitionPattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StepDefinition_StepDefinitionPattern_StepDefinitionPatternType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParameterType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParameterType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParameterType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegularExpressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegularExpressions = append(m.RegularExpressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferForRegularExpressionMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreferForRegularExpressionMatch = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseForSnippets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseForSnippets = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UndefinedParameterType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UndefinedParameterType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UndefinedParameterType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParseError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParseError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParseError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SourceReference{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessages
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessages
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessages
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessages        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessages          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessages = fmt.Errorf("proto: unexpected end of group")
)
