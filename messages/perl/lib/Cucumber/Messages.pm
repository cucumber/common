package Cucumber::Messages;

# DO NOT CHANGE THIS FILE!!

# The code was auto-generated by this script:
# https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb

=head1 NAME

Cucumber::Messages - Library of classes to encapsulate Cucumber messages

=head1 SYNOPSIS

  use Cucumber::Messages;

  my $loc = Cucumber::Messages::Location->new(
     line => 12, column => 26
  );
  my $loc_json = $loc->to_json;

  my $envelope = Cucumber::Messages::Envelope->from_json($serialized_envelope);

=head1 DESCRIPTION

L<Cucumber messages|https://github.com/cucumber/common/tree/main/messages>
define the central protocol in the Cucumber ecosystem by which the various
components communicate. Messages are serialized to NDJSON.

This library provides both serialization/deserialization to/from NDJSON as
well as the in-memory representation of the messages for Perl applications.

Each serialized message should be wrapped in a C<Cucumber::Messages::Envelope>
and can thereby be deserialized by calling the C<from_json> class message
with the serialized representation as its argument, like shown in the SYNOPSIS.

=cut

use strict;
use warnings;

use Cucumber::Messages::Message;

=head1 MESSAGE CLASSES

=cut



package Cucumber::Messages::Attachment {

=head2 Cucumber::Messages::Attachment

=head3 DESCRIPTION

Represents the Attachment message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

//// Attachments (parse errors, execution errors, screenshots, links...)

*
 An attachment represents any kind of data associated with a line in a
 [Source](#io.cucumber.messages.Source) file. It can be used for:

 * Syntax errors during parse time
 * Screenshots captured and attached during execution
 * Logs captured and attached during execution

 It is not to be used for runtime errors raised/thrown during execution. This
 is captured in `TestResult`.

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   body => 'string',
   content_encoding => '',
   file_name => 'string',
   media_type => 'string',
   source => 'Cucumber::Messages::Source',
   test_case_started_id => 'string',
   test_step_id => 'string',
   url => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 body

*
 The body of the attachment. If `contentEncoding` is `IDENTITY`, the attachment
 is simply the string. If it's `BASE64`, the string should be Base64 decoded to
 obtain the attachment.

=cut

has body =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 content_encoding

*
 Whether to interpret `body` "as-is" (IDENTITY) or if it needs to be Base64-decoded (BASE64).

 Content encoding is *not* determined by the media type, but rather by the type
 of the object being attached:

 - string => IDENTITY
 - byte array => BASE64
 - stream => BASE64


Available constants for valid values of this field:

=over

=item * CONTENTENCODING_IDENTITY

=item * CONTENTENCODING_BASE64

=back

=cut


use constant
   CONTENTENCODING_IDENTITY => 'IDENTITY',
   CONTENTENCODING_BASE64 => 'BASE64',
   ;

has content_encoding =>
    (is => 'ro',
     required => 1,
     default => sub { CONTENTENCODING_IDENTITY },
    );


=head4 file_name

*
 Suggested file name of the attachment. (Provided by the user as an argument to `attach`)

=cut

has file_name =>
    (is => 'ro',
    );


=head4 media_type

*
 The media type of the data. This can be any valid
 [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
 as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
 and `text/x.cucumber.stacktrace+plain`

=cut

has media_type =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 source


=cut

has source =>
    (is => 'ro',
    );


=head4 test_case_started_id


=cut

has test_case_started_id =>
    (is => 'ro',
    );


=head4 test_step_id


=cut

has test_step_id =>
    (is => 'ro',
    );


=head4 url

*
 A URL where the attachment can be retrieved. This field should not be set by Cucumber.
 It should be set by a program that reads a message stream and does the following for
 each Attachment message:

 - Writes the body (after base64 decoding if necessary) to a new file.
 - Sets `body` and `contentEncoding` to `null`
 - Writes out the new attachment message

 This will result in a smaller message stream, which can improve performance and
 reduce bandwidth of message consumers. It also makes it easier to process and download attachments
 separately from reports.

=cut

has url =>
    (is => 'ro',
    );


}

package Cucumber::Messages::Duration {

=head2 Cucumber::Messages::Duration

=head3 DESCRIPTION

Represents the Duration message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

The structure is pretty close of the Timestamp one. For clarity, a second type
 of message is used.

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   seconds => 'number',
   nanos => 'number',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 seconds


=cut

has seconds =>
    (is => 'ro',
     required => 1,
     default => sub { 0 },
    );


=head4 nanos

Non-negative fractions of a second at nanosecond resolution. Negative
 second values with fractions must still have non-negative nanos values
 that count forward in time. Must be from 0 to 999,999,999
 inclusive.

=cut

has nanos =>
    (is => 'ro',
     required => 1,
     default => sub { 0 },
    );


}

package Cucumber::Messages::Envelope {

=head2 Cucumber::Messages::Envelope

=head3 DESCRIPTION

Represents the Envelope message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

When removing a field, replace it with reserved, rather than deleting the line.
 When adding a field, add it to the end and increment the number by one.
 See https://developers.google.com/protocol-buffers/docs/proto#updating for details

*
 All the messages that are passed between different components/processes are Envelope
 messages.

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   attachment => 'Cucumber::Messages::Attachment',
   gherkin_document => 'Cucumber::Messages::GherkinDocument',
   hook => 'Cucumber::Messages::Hook',
   meta => 'Cucumber::Messages::Meta',
   parameter_type => 'Cucumber::Messages::ParameterType',
   parse_error => 'Cucumber::Messages::ParseError',
   pickle => 'Cucumber::Messages::Pickle',
   source => 'Cucumber::Messages::Source',
   step_definition => 'Cucumber::Messages::StepDefinition',
   test_case => 'Cucumber::Messages::TestCase',
   test_case_finished => 'Cucumber::Messages::TestCaseFinished',
   test_case_started => 'Cucumber::Messages::TestCaseStarted',
   test_run_finished => 'Cucumber::Messages::TestRunFinished',
   test_run_started => 'Cucumber::Messages::TestRunStarted',
   test_step_finished => 'Cucumber::Messages::TestStepFinished',
   test_step_started => 'Cucumber::Messages::TestStepStarted',
   undefined_parameter_type => 'Cucumber::Messages::UndefinedParameterType',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 attachment


=cut

has attachment =>
    (is => 'ro',
    );


=head4 gherkin_document


=cut

has gherkin_document =>
    (is => 'ro',
    );


=head4 hook


=cut

has hook =>
    (is => 'ro',
    );


=head4 meta


=cut

has meta =>
    (is => 'ro',
    );


=head4 parameter_type


=cut

has parameter_type =>
    (is => 'ro',
    );


=head4 parse_error


=cut

has parse_error =>
    (is => 'ro',
    );


=head4 pickle


=cut

has pickle =>
    (is => 'ro',
    );


=head4 source


=cut

has source =>
    (is => 'ro',
    );


=head4 step_definition


=cut

has step_definition =>
    (is => 'ro',
    );


=head4 test_case


=cut

has test_case =>
    (is => 'ro',
    );


=head4 test_case_finished


=cut

has test_case_finished =>
    (is => 'ro',
    );


=head4 test_case_started


=cut

has test_case_started =>
    (is => 'ro',
    );


=head4 test_run_finished


=cut

has test_run_finished =>
    (is => 'ro',
    );


=head4 test_run_started


=cut

has test_run_started =>
    (is => 'ro',
    );


=head4 test_step_finished


=cut

has test_step_finished =>
    (is => 'ro',
    );


=head4 test_step_started


=cut

has test_step_started =>
    (is => 'ro',
    );


=head4 undefined_parameter_type


=cut

has undefined_parameter_type =>
    (is => 'ro',
    );


}

package Cucumber::Messages::GherkinDocument {

=head2 Cucumber::Messages::GherkinDocument

=head3 DESCRIPTION

Represents the GherkinDocument message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 The [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) of a Gherkin document.
 Cucumber implementations should *not* depend on `GherkinDocument` or any of its
 children for execution - use [Pickle](#io.cucumber.messages.Pickle) instead.

 The only consumers of `GherkinDocument` should only be formatters that produce
 "rich" output, resembling the original Gherkin document.

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   uri => 'string',
   feature => 'Cucumber::Messages::Feature',
   comments => '[]Cucumber::Messages::Comment',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 uri

*
 The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
 of the source, typically a file path relative to the root directory

=cut

has uri =>
    (is => 'ro',
    );


=head4 feature


=cut

has feature =>
    (is => 'ro',
    );


=head4 comments

All the comments in the Gherkin document

=cut

has comments =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


}

package Cucumber::Messages::Background {

=head2 Cucumber::Messages::Background

=head3 DESCRIPTION

Represents the Background message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   keyword => 'string',
   name => 'string',
   description => 'string',
   steps => '[]Cucumber::Messages::Step',
   id => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location

The location of the `Background` keyword

=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 keyword


=cut

has keyword =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 name


=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 description


=cut

has description =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 steps


=cut

has steps =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 id


=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::Comment {

=head2 Cucumber::Messages::Comment

=head3 DESCRIPTION

Represents the Comment message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 A comment in a Gherkin document

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   text => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location

The location of the comment

=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 text

The text of the comment

=cut

has text =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::DataTable {

=head2 Cucumber::Messages::DataTable

=head3 DESCRIPTION

Represents the DataTable message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   rows => '[]Cucumber::Messages::TableRow',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location


=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 rows


=cut

has rows =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


}

package Cucumber::Messages::DocString {

=head2 Cucumber::Messages::DocString

=head3 DESCRIPTION

Represents the DocString message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   media_type => 'string',
   content => 'string',
   delimiter => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location


=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 media_type


=cut

has media_type =>
    (is => 'ro',
    );


=head4 content


=cut

has content =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 delimiter


=cut

has delimiter =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::Examples {

=head2 Cucumber::Messages::Examples

=head3 DESCRIPTION

Represents the Examples message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   tags => '[]Cucumber::Messages::Tag',
   keyword => 'string',
   name => 'string',
   description => 'string',
   table_header => 'Cucumber::Messages::TableRow',
   table_body => '[]Cucumber::Messages::TableRow',
   id => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location

The location of the `Examples` keyword

=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 tags


=cut

has tags =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 keyword


=cut

has keyword =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 name


=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 description


=cut

has description =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 table_header


=cut

has table_header =>
    (is => 'ro',
    );


=head4 table_body


=cut

has table_body =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 id


=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::Feature {

=head2 Cucumber::Messages::Feature

=head3 DESCRIPTION

Represents the Feature message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   tags => '[]Cucumber::Messages::Tag',
   language => 'string',
   keyword => 'string',
   name => 'string',
   description => 'string',
   children => '[]Cucumber::Messages::FeatureChild',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location

The location of the `Feature` keyword

=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 tags

All the tags placed above the `Feature` keyword

=cut

has tags =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 language

The [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code of the Gherkin document

=cut

has language =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 keyword

The text of the `Feature` keyword (in the language specified by `language`)

=cut

has keyword =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 name

The name of the feature (the text following the `keyword`)

=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 description

The line(s) underneath the line with the `keyword` that are used as description

=cut

has description =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 children

Zero or more children

=cut

has children =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


}

package Cucumber::Messages::FeatureChild {

=head2 Cucumber::Messages::FeatureChild

=head3 DESCRIPTION

Represents the FeatureChild message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 A child node of a `Feature` node

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   rule => 'Cucumber::Messages::Rule',
   background => 'Cucumber::Messages::Background',
   scenario => 'Cucumber::Messages::Scenario',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 rule


=cut

has rule =>
    (is => 'ro',
    );


=head4 background


=cut

has background =>
    (is => 'ro',
    );


=head4 scenario


=cut

has scenario =>
    (is => 'ro',
    );


}

package Cucumber::Messages::Rule {

=head2 Cucumber::Messages::Rule

=head3 DESCRIPTION

Represents the Rule message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   tags => '[]Cucumber::Messages::Tag',
   keyword => 'string',
   name => 'string',
   description => 'string',
   children => '[]Cucumber::Messages::RuleChild',
   id => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location

The location of the `Rule` keyword

=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 tags

All the tags placed above the `Rule` keyword

=cut

has tags =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 keyword


=cut

has keyword =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 name


=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 description


=cut

has description =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 children


=cut

has children =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 id


=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::RuleChild {

=head2 Cucumber::Messages::RuleChild

=head3 DESCRIPTION

Represents the RuleChild message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 A child node of a `Rule` node

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   background => 'Cucumber::Messages::Background',
   scenario => 'Cucumber::Messages::Scenario',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 background


=cut

has background =>
    (is => 'ro',
    );


=head4 scenario


=cut

has scenario =>
    (is => 'ro',
    );


}

package Cucumber::Messages::Scenario {

=head2 Cucumber::Messages::Scenario

=head3 DESCRIPTION

Represents the Scenario message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   tags => '[]Cucumber::Messages::Tag',
   keyword => 'string',
   name => 'string',
   description => 'string',
   steps => '[]Cucumber::Messages::Step',
   examples => '[]Cucumber::Messages::Examples',
   id => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location

The location of the `Scenario` keyword

=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 tags


=cut

has tags =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 keyword


=cut

has keyword =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 name


=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 description


=cut

has description =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 steps


=cut

has steps =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 examples


=cut

has examples =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 id


=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::Step {

=head2 Cucumber::Messages::Step

=head3 DESCRIPTION

Represents the Step message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

A step

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   keyword => 'string',
   text => 'string',
   doc_string => 'Cucumber::Messages::DocString',
   data_table => 'Cucumber::Messages::DataTable',
   id => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location

The location of the steps' `keyword`

=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 keyword


=cut

has keyword =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 text


=cut

has text =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 doc_string


=cut

has doc_string =>
    (is => 'ro',
    );


=head4 data_table


=cut

has data_table =>
    (is => 'ro',
    );


=head4 id

Unique ID to be able to reference the Step from PickleStep

=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::TableCell {

=head2 Cucumber::Messages::TableCell

=head3 DESCRIPTION

Represents the TableCell message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

A cell in a `TableRow`

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   value => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location

The location of the cell

=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 value

The value of the cell

=cut

has value =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::TableRow {

=head2 Cucumber::Messages::TableRow

=head3 DESCRIPTION

Represents the TableRow message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

A row in a table

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   cells => '[]Cucumber::Messages::TableCell',
   id => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location

The location of the first cell in the row

=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 cells

Cells in the row

=cut

has cells =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 id


=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::Tag {

=head2 Cucumber::Messages::Tag

=head3 DESCRIPTION

Represents the Tag message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 A tag

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   location => 'Cucumber::Messages::Location',
   name => 'string',
   id => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 location

Location of the tag

=cut

has location =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Location->new() },
    );


=head4 name

The name of the tag (including the leading `@`)

=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 id

Unique ID to be able to reference the Tag from PickleTag

=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::Hook {

=head2 Cucumber::Messages::Hook

=head3 DESCRIPTION

Represents the Hook message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   id => 'string',
   source_reference => 'Cucumber::Messages::SourceReference',
   tag_expression => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 id


=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 source_reference


=cut

has source_reference =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::SourceReference->new() },
    );


=head4 tag_expression


=cut

has tag_expression =>
    (is => 'ro',
    );


}

package Cucumber::Messages::Location {

=head2 Cucumber::Messages::Location

=head3 DESCRIPTION

Represents the Location message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 Points to a line and a column in a text file

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   line => 'number',
   column => 'number',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 line


=cut

has line =>
    (is => 'ro',
     required => 1,
     default => sub { 0 },
    );


=head4 column


=cut

has column =>
    (is => 'ro',
    );


}

package Cucumber::Messages::Meta {

=head2 Cucumber::Messages::Meta

=head3 DESCRIPTION

Represents the Meta message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 This message contains meta information about the environment. Consumers can use
 this for various purposes.

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   protocol_version => 'string',
   implementation => 'Cucumber::Messages::Product',
   runtime => 'Cucumber::Messages::Product',
   os => 'Cucumber::Messages::Product',
   cpu => 'Cucumber::Messages::Product',
   ci => 'Cucumber::Messages::Ci',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 protocol_version

*
 The [SEMVER](https://semver.org/) version number of the protocol

=cut

has protocol_version =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 implementation

SpecFlow, Cucumber-JVM, Cucumber.js, Cucumber-Ruby, Behat etc.

=cut

has implementation =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Product->new() },
    );


=head4 runtime

Java, Ruby, Node.js etc

=cut

has runtime =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Product->new() },
    );


=head4 os

Windows, Linux, MacOS etc

=cut

has os =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Product->new() },
    );


=head4 cpu

386, arm, amd64 etc

=cut

has cpu =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Product->new() },
    );


=head4 ci


=cut

has ci =>
    (is => 'ro',
    );


}

package Cucumber::Messages::Ci {

=head2 Cucumber::Messages::Ci

=head3 DESCRIPTION

Represents the Ci message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

CI environment

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   name => 'string',
   url => 'string',
   build_number => 'string',
   git => 'Cucumber::Messages::Git',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 name

Name of the CI product, e.g. "Jenkins", "CircleCI" etc.

=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 url

Link to the build

=cut

has url =>
    (is => 'ro',
    );


=head4 build_number

The build number. Some CI servers use non-numeric build numbers, which is why this is a string

=cut

has build_number =>
    (is => 'ro',
    );


=head4 git


=cut

has git =>
    (is => 'ro',
    );


}

package Cucumber::Messages::Git {

=head2 Cucumber::Messages::Git

=head3 DESCRIPTION

Represents the Git message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

Information about Git, provided by the Build/CI server as environment
 variables.

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   remote => 'string',
   revision => 'string',
   branch => 'string',
   tag => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 remote


=cut

has remote =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 revision


=cut

has revision =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 branch


=cut

has branch =>
    (is => 'ro',
    );


=head4 tag


=cut

has tag =>
    (is => 'ro',
    );


}

package Cucumber::Messages::Product {

=head2 Cucumber::Messages::Product

=head3 DESCRIPTION

Represents the Product message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

Used to describe various properties of Meta

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   name => 'string',
   version => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 name

The product name

=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 version

The product version

=cut

has version =>
    (is => 'ro',
    );


}

package Cucumber::Messages::ParameterType {

=head2 Cucumber::Messages::ParameterType

=head3 DESCRIPTION

Represents the ParameterType message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   name => 'string',
   regular_expressions => '[]string',
   prefer_for_regular_expression_match => 'boolean',
   use_for_snippets => 'boolean',
   id => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 name

The name is unique, so we don't need an id.

=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 regular_expressions


=cut

has regular_expressions =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 prefer_for_regular_expression_match


=cut

has prefer_for_regular_expression_match =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 use_for_snippets


=cut

has use_for_snippets =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 id


=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::ParseError {

=head2 Cucumber::Messages::ParseError

=head3 DESCRIPTION

Represents the ParseError message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   source => 'Cucumber::Messages::SourceReference',
   message => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 source


=cut

has source =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::SourceReference->new() },
    );


=head4 message


=cut

has message =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::Pickle {

=head2 Cucumber::Messages::Pickle

=head3 DESCRIPTION

Represents the Pickle message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

//// Pickles

*
 A `Pickle` represents a template for a `TestCase`. It is typically derived
 from another format, such as [GherkinDocument](#io.cucumber.messages.GherkinDocument).
 In the future a `Pickle` may be derived from other formats such as Markdown or
 Excel files.

 By making `Pickle` the main data structure Cucumber uses for execution, the
 implementation of Cucumber itself becomes simpler, as it doesn't have to deal
 with the complex structure of a [GherkinDocument](#io.cucumber.messages.GherkinDocument).

 Each `PickleStep` of a `Pickle` is matched with a `StepDefinition` to create a `TestCase`

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   id => 'string',
   uri => 'string',
   name => 'string',
   language => 'string',
   steps => '[]Cucumber::Messages::PickleStep',
   tags => '[]Cucumber::Messages::PickleTag',
   ast_node_ids => '[]string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 id

*
 A unique id for the pickle. This is a [SHA1](https://en.wikipedia.org/wiki/SHA-1) hash
 from the source data and the `locations` of the pickle.
 This ID will change if source the file is modified.

=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 uri

The uri of the source file

=cut

has uri =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 name

The name of the pickle

=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 language

The language of the pickle

=cut

has language =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 steps

One or more steps

=cut

has steps =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 tags

*
 One or more tags. If this pickle is constructed from a Gherkin document,
 It includes inherited tags from the `Feature` as well.

=cut

has tags =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 ast_node_ids

*
 Points to the AST node locations of the pickle. The last one represents the unique
 id of the pickle. A pickle constructed from `Examples` will have the first
 id originating from the `Scenario` AST node, and the second from the `TableRow` AST node.

=cut

has ast_node_ids =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


}

package Cucumber::Messages::PickleDocString {

=head2 Cucumber::Messages::PickleDocString

=head3 DESCRIPTION

Represents the PickleDocString message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   media_type => 'string',
   content => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 media_type


=cut

has media_type =>
    (is => 'ro',
    );


=head4 content


=cut

has content =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::PickleStep {

=head2 Cucumber::Messages::PickleStep

=head3 DESCRIPTION

Represents the PickleStep message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 An executable step

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   argument => 'Cucumber::Messages::PickleStepArgument',
   ast_node_ids => '[]string',
   id => 'string',
   text => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 argument


=cut

has argument =>
    (is => 'ro',
    );


=head4 ast_node_ids

References the IDs of the source of the step. For Gherkin, this can be
 the ID of a Step, and possibly also the ID of a TableRow

=cut

has ast_node_ids =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 id

A unique ID for the PickleStep

=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 text


=cut

has text =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::PickleStepArgument {

=head2 Cucumber::Messages::PickleStepArgument

=head3 DESCRIPTION

Represents the PickleStepArgument message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

An optional argument

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   doc_string => 'Cucumber::Messages::PickleDocString',
   data_table => 'Cucumber::Messages::PickleTable',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 doc_string


=cut

has doc_string =>
    (is => 'ro',
    );


=head4 data_table


=cut

has data_table =>
    (is => 'ro',
    );


}

package Cucumber::Messages::PickleTable {

=head2 Cucumber::Messages::PickleTable

=head3 DESCRIPTION

Represents the PickleTable message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   rows => '[]Cucumber::Messages::PickleTableRow',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 rows


=cut

has rows =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


}

package Cucumber::Messages::PickleTableCell {

=head2 Cucumber::Messages::PickleTableCell

=head3 DESCRIPTION

Represents the PickleTableCell message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   value => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 value


=cut

has value =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::PickleTableRow {

=head2 Cucumber::Messages::PickleTableRow

=head3 DESCRIPTION

Represents the PickleTableRow message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   cells => '[]Cucumber::Messages::PickleTableCell',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 cells


=cut

has cells =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


}

package Cucumber::Messages::PickleTag {

=head2 Cucumber::Messages::PickleTag

=head3 DESCRIPTION

Represents the PickleTag message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 A tag

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   name => 'string',
   ast_node_id => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 name


=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 ast_node_id

Points to the AST node this was created from

=cut

has ast_node_id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::Source {

=head2 Cucumber::Messages::Source

=head3 DESCRIPTION

Represents the Source message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

//// Source

*
 A source file, typically a Gherkin document or Java/Ruby/JavaScript source code

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   uri => 'string',
   data => 'string',
   media_type => '',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 uri

*
 The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
 of the source, typically a file path relative to the root directory

=cut

has uri =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 data

The contents of the file

=cut

has data =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 media_type

The media type of the file. Can be used to specify custom types, such as
 text/x.cucumber.gherkin+plain


Available constants for valid values of this field:

=over

=item * MEDIATYPE_TEXT_X_CUCUMBER_GHERKIN_PLAIN

=item * MEDIATYPE_TEXT_X_CUCUMBER_GHERKIN_MARKDOWN

=back

=cut


use constant
   MEDIATYPE_TEXT_X_CUCUMBER_GHERKIN_PLAIN => 'text/x.cucumber.gherkin+plain',
   MEDIATYPE_TEXT_X_CUCUMBER_GHERKIN_MARKDOWN => 'text/x.cucumber.gherkin+markdown',
   ;

has media_type =>
    (is => 'ro',
     required => 1,
     default => sub { MEDIATYPE_TEXT_X_CUCUMBER_GHERKIN_PLAIN },
    );


}

package Cucumber::Messages::SourceReference {

=head2 Cucumber::Messages::SourceReference

=head3 DESCRIPTION

Represents the SourceReference message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 Points to a [Source](#io.cucumber.messages.Source) identified by `uri` and a
 [Location](#io.cucumber.messages.Location) within that file.

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   uri => 'string',
   java_method => 'Cucumber::Messages::JavaMethod',
   java_stack_trace_element => 'Cucumber::Messages::JavaStackTraceElement',
   location => 'Cucumber::Messages::Location',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 uri


=cut

has uri =>
    (is => 'ro',
    );


=head4 java_method


=cut

has java_method =>
    (is => 'ro',
    );


=head4 java_stack_trace_element


=cut

has java_stack_trace_element =>
    (is => 'ro',
    );


=head4 location


=cut

has location =>
    (is => 'ro',
    );


}

package Cucumber::Messages::JavaMethod {

=head2 Cucumber::Messages::JavaMethod

=head3 DESCRIPTION

Represents the JavaMethod message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   class_name => 'string',
   method_name => 'string',
   method_parameter_types => '[]string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 class_name


=cut

has class_name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 method_name


=cut

has method_name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 method_parameter_types


=cut

has method_parameter_types =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


}

package Cucumber::Messages::JavaStackTraceElement {

=head2 Cucumber::Messages::JavaStackTraceElement

=head3 DESCRIPTION

Represents the JavaStackTraceElement message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   class_name => 'string',
   file_name => 'string',
   method_name => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 class_name


=cut

has class_name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 file_name


=cut

has file_name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 method_name


=cut

has method_name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::StepDefinition {

=head2 Cucumber::Messages::StepDefinition

=head3 DESCRIPTION

Represents the StepDefinition message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   id => 'string',
   pattern => 'Cucumber::Messages::StepDefinitionPattern',
   source_reference => 'Cucumber::Messages::SourceReference',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 id


=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 pattern


=cut

has pattern =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::StepDefinitionPattern->new() },
    );


=head4 source_reference


=cut

has source_reference =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::SourceReference->new() },
    );


}

package Cucumber::Messages::StepDefinitionPattern {

=head2 Cucumber::Messages::StepDefinitionPattern

=head3 DESCRIPTION

Represents the StepDefinitionPattern message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   source => 'string',
   type => '',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 source


=cut

has source =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 type



Available constants for valid values of this field:

=over

=item * TYPE_CUCUMBER_EXPRESSION

=item * TYPE_REGULAR_EXPRESSION

=back

=cut


use constant
   TYPE_CUCUMBER_EXPRESSION => 'CUCUMBER_EXPRESSION',
   TYPE_REGULAR_EXPRESSION => 'REGULAR_EXPRESSION',
   ;

has type =>
    (is => 'ro',
     required => 1,
     default => sub { TYPE_CUCUMBER_EXPRESSION },
    );


}

package Cucumber::Messages::TestCase {

=head2 Cucumber::Messages::TestCase

=head3 DESCRIPTION

Represents the TestCase message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

//// TestCases

*
 A `TestCase` contains a sequence of `TestStep`s.

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   id => 'string',
   pickle_id => 'string',
   test_steps => '[]Cucumber::Messages::TestStep',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 id


=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 pickle_id

The ID of the `Pickle` this `TestCase` is derived from.

=cut

has pickle_id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 test_steps


=cut

has test_steps =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


}

package Cucumber::Messages::Group {

=head2 Cucumber::Messages::Group

=head3 DESCRIPTION

Represents the Group message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   children => '[]Cucumber::Messages::Group',
   start => 'number',
   value => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 children


=cut

has children =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


=head4 start


=cut

has start =>
    (is => 'ro',
    );


=head4 value


=cut

has value =>
    (is => 'ro',
    );


}

package Cucumber::Messages::StepMatchArgument {

=head2 Cucumber::Messages::StepMatchArgument

=head3 DESCRIPTION

Represents the StepMatchArgument message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 Represents a single argument extracted from a step match and passed to a step definition.
 This is used for the following purposes:
 - Construct an argument to pass to a step definition (possibly through a parameter type transform)
 - Highlight the matched parameter in rich formatters such as the HTML formatter

 This message closely matches the `Argument` class in the `cucumber-expressions` library.

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   group => 'Cucumber::Messages::Group',
   parameter_type_name => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 group

*
 Represents the outermost capture group of an argument. This message closely matches the
 `Group` class in the `cucumber-expressions` library.

=cut

has group =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Group->new() },
    );


=head4 parameter_type_name


=cut

has parameter_type_name =>
    (is => 'ro',
    );


}

package Cucumber::Messages::StepMatchArgumentsList {

=head2 Cucumber::Messages::StepMatchArgumentsList

=head3 DESCRIPTION

Represents the StepMatchArgumentsList message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   step_match_arguments => '[]Cucumber::Messages::StepMatchArgument',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 step_match_arguments


=cut

has step_match_arguments =>
    (is => 'ro',
     required => 1,
     default => sub { [] },
    );


}

package Cucumber::Messages::TestStep {

=head2 Cucumber::Messages::TestStep

=head3 DESCRIPTION

Represents the TestStep message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.

*
 A `TestStep` is derived from either a `PickleStep`
 combined with a `StepDefinition`, or from a `Hook`.

=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   hook_id => 'string',
   id => 'string',
   pickle_step_id => 'string',
   step_definition_ids => '[]string',
   step_match_arguments_lists => '[]Cucumber::Messages::StepMatchArgumentsList',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 hook_id

Pointer to the `Hook` (if derived from a Hook)

=cut

has hook_id =>
    (is => 'ro',
    );


=head4 id


=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 pickle_step_id

Pointer to the `PickleStep` (if derived from a `PickleStep`)

=cut

has pickle_step_id =>
    (is => 'ro',
    );


=head4 step_definition_ids

Pointer to all the matching `StepDefinition`s (if derived from a `PickleStep`)

=cut

has step_definition_ids =>
    (is => 'ro',
    );


=head4 step_match_arguments_lists

A list of list of StepMatchArgument (if derived from a `PickleStep`).
 Each element represents a matching step definition. A size of 0 means `UNDEFINED`,
 and a size of 2+ means `AMBIGUOUS`

=cut

has step_match_arguments_lists =>
    (is => 'ro',
    );


}

package Cucumber::Messages::TestCaseFinished {

=head2 Cucumber::Messages::TestCaseFinished

=head3 DESCRIPTION

Represents the TestCaseFinished message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   test_case_started_id => 'string',
   timestamp => 'Cucumber::Messages::Timestamp',
   will_be_retried => 'boolean',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 test_case_started_id


=cut

has test_case_started_id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 timestamp


=cut

has timestamp =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Timestamp->new() },
    );


=head4 will_be_retried


=cut

has will_be_retried =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

package Cucumber::Messages::TestCaseStarted {

=head2 Cucumber::Messages::TestCaseStarted

=head3 DESCRIPTION

Represents the TestCaseStarted message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   attempt => 'number',
   id => 'string',
   test_case_id => 'string',
   timestamp => 'Cucumber::Messages::Timestamp',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 attempt

*
 The first attempt should have value 0, and for each retry the value
 should increase by 1.

=cut

has attempt =>
    (is => 'ro',
     required => 1,
     default => sub { 0 },
    );


=head4 id

*
 Because a `TestCase` can be run multiple times (in case of a retry),
 we use this field to group messages relating to the same attempt.

=cut

has id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 test_case_id


=cut

has test_case_id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 timestamp


=cut

has timestamp =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Timestamp->new() },
    );


}

package Cucumber::Messages::TestRunFinished {

=head2 Cucumber::Messages::TestRunFinished

=head3 DESCRIPTION

Represents the TestRunFinished message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   message => 'string',
   success => 'boolean',
   timestamp => 'Cucumber::Messages::Timestamp',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 message

Error message. Can be a stack trace from a failed `BeforeAll` or `AfterAll`.
 If there are undefined parameter types, the message is simply
 "The following parameter type(s() are not defined: xxx, yyy".
 The independent `UndefinedParameterType` messages can be used to generate
 snippets for those parameter types.

=cut

has message =>
    (is => 'ro',
    );


=head4 success

success = StrictModeEnabled ? (failed_count == 0 && ambiguous_count == 0 && undefined_count == 0 && pending_count == 0) : (failed_count == 0 && ambiguous_count == 0)

=cut

has success =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 timestamp

Timestamp when the TestRun is finished

=cut

has timestamp =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Timestamp->new() },
    );


}

package Cucumber::Messages::TestRunStarted {

=head2 Cucumber::Messages::TestRunStarted

=head3 DESCRIPTION

Represents the TestRunStarted message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   timestamp => 'Cucumber::Messages::Timestamp',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 timestamp


=cut

has timestamp =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Timestamp->new() },
    );


}

package Cucumber::Messages::TestStepFinished {

=head2 Cucumber::Messages::TestStepFinished

=head3 DESCRIPTION

Represents the TestStepFinished message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   test_case_started_id => 'string',
   test_step_id => 'string',
   test_step_result => 'Cucumber::Messages::TestStepResult',
   timestamp => 'Cucumber::Messages::Timestamp',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 test_case_started_id


=cut

has test_case_started_id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 test_step_id


=cut

has test_step_id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 test_step_result


=cut

has test_step_result =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::TestStepResult->new() },
    );


=head4 timestamp


=cut

has timestamp =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Timestamp->new() },
    );


}

package Cucumber::Messages::TestStepResult {

=head2 Cucumber::Messages::TestStepResult

=head3 DESCRIPTION

Represents the TestStepResult message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   duration => 'Cucumber::Messages::Duration',
   message => 'string',
   status => '',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 duration


=cut

has duration =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Duration->new() },
    );


=head4 message


=cut

has message =>
    (is => 'ro',
    );


=head4 status



Available constants for valid values of this field:

=over

=item * STATUS_UNKNOWN

=item * STATUS_PASSED

=item * STATUS_SKIPPED

=item * STATUS_PENDING

=item * STATUS_UNDEFINED

=item * STATUS_AMBIGUOUS

=item * STATUS_FAILED

=back

=cut


use constant
   STATUS_UNKNOWN => 'UNKNOWN',
   STATUS_PASSED => 'PASSED',
   STATUS_SKIPPED => 'SKIPPED',
   STATUS_PENDING => 'PENDING',
   STATUS_UNDEFINED => 'UNDEFINED',
   STATUS_AMBIGUOUS => 'AMBIGUOUS',
   STATUS_FAILED => 'FAILED',
   ;

has status =>
    (is => 'ro',
     required => 1,
     default => sub { STATUS_UNKNOWN },
    );


}

package Cucumber::Messages::TestStepStarted {

=head2 Cucumber::Messages::TestStepStarted

=head3 DESCRIPTION

Represents the TestStepStarted message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   test_case_started_id => 'string',
   test_step_id => 'string',
   timestamp => 'Cucumber::Messages::Timestamp',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 test_case_started_id


=cut

has test_case_started_id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 test_step_id


=cut

has test_step_id =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 timestamp


=cut

has timestamp =>
    (is => 'ro',
     required => 1,
     default => sub { Cucumber::Messages::Timestamp->new() },
    );


}

package Cucumber::Messages::Timestamp {

=head2 Cucumber::Messages::Timestamp

=head3 DESCRIPTION

Represents the Timestamp message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   seconds => 'number',
   nanos => 'number',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 seconds

Represents seconds of UTC time since Unix epoch
 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
 9999-12-31T23:59:59Z inclusive.

=cut

has seconds =>
    (is => 'ro',
     required => 1,
     default => sub { 0 },
    );


=head4 nanos

Non-negative fractions of a second at nanosecond resolution. Negative
 second values with fractions must still have non-negative nanos values
 that count forward in time. Must be from 0 to 999,999,999
 inclusive.

=cut

has nanos =>
    (is => 'ro',
     required => 1,
     default => sub { 0 },
    );


}

package Cucumber::Messages::UndefinedParameterType {

=head2 Cucumber::Messages::UndefinedParameterType

=head3 DESCRIPTION

Represents the UndefinedParameterType message in Cucumber's
L<message protocol|https://github.com/cucumber/common/tree/main/messages#readme>.



=head3 ATTRIBUTES

=cut

use Moo;
extends 'Cucumber::Messages::Message';

use Scalar::Util qw( blessed );

my %types = (
   expression => 'string',
   name => 'string',
);

# This is a work-around for the fact that Moo doesn't have introspection
# and Perl doesn't have boolean values...
sub _types {
    return \%types;
}



=head4 expression


=cut

has expression =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


=head4 name


=cut

has name =>
    (is => 'ro',
     required => 1,
     default => sub { '' },
    );


}

1;

__END__

=head1 LICENSE

Please see the included LICENSE for the canonical version. In summary:

The MIT License (MIT)

  Copyright (c) 2021 Erik Huelsmann
  Copyright (c) 2021 Cucumber Ltd

This work is loosely derived from prior work of the same library for Ruby,
called C<cucumber-messages>.

=cut


