{"version":3,"sources":["../src/cache.js"],"names":[],"mappings":"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","file":"cache.js","sourcesContent":["import R from 'ramda';\nimport Promise from 'bluebird';\nimport fs from 'fs-extra';\nimport * as f from './funcs';\n\nconst formatPath = R.pipe(f.ensureString('./.cache'), f.toAbsolutePath);\n\nconst toGetValue = (data) => {\n  const { type } = data;\n  let { value } = data;\n  if (type === 'Date') { value = new Date(value); }\n  return value;\n};\n\nconst getValueP = (path, defaultValue) => new Promise((resolve, reject) => {\n  fs.readJson(path, (err, result) => {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        resolve(defaultValue);\n      } else {\n        reject(err);\n      }\n    } else {\n      const value = toGetValue(result);\n      resolve(value);\n    }\n  });\n});\n\nconst toJson = (value) => JSON.stringify({ value, type: R.type(value) });\n\n\n\n/**\n * A cache that read/writes to a specific part of the file-system.\n */\nexport default class FileSystemCache {\n  /**\n   * Constructor.\n   * @param options\n   *            - basePath:   The folder path to read/write to.\n   *                          Default: './build'\n   *            - ns:         A single value, or array, that represents a\n   *                          a unique namespace within which values for this\n   *                          store are cached.\n   *            - extension:  An optional file-extension for paths.\n   */\n  constructor({ basePath, ns, extension } = {}) {\n    this.basePath = formatPath(basePath);\n    this.ns = f.hash(ns);\n    if (f.isString(extension)) { this.extension = extension; }\n    if (f.isFileSync(this.basePath)) {\n      throw new Error(`The basePath '${ this.basePath }' is a file. It should be a folder.`);\n    }\n  }\n\n  /**\n   * Generates the path to the cached files.\n   * @param {string} key: The key of the cache item.\n   * @return {string}.\n   */\n  path(key) {\n    if (f.isNothing(key)) { throw new Error(`Path requires a cache key.`); }\n    let name = f.hash(key);\n    if (this.ns) { name = `${ this.ns }-${ name }`; }\n    if (this.extension) {\n      name = `${ name }.${ this.extension.replace(/^\\./, '') }`;\n    }\n    return `${ this.basePath }/${ name }`;\n  }\n\n\n  /**\n   * Determines whether the file exists.\n   * @param {string} key: The key of the cache item.\n   * @return {Promise}\n   */\n  fileExists(key) { return f.existsP(this.path(key)); }\n\n\n  /**\n   * Ensure that the base path exists.\n   * @return {Promise}\n   */\n  ensureBasePath() {\n    return new Promise((resolve, reject) => {\n      if (this.basePathExists) {\n        resolve();\n      } else {\n        fs.ensureDir(this.basePath, (err) => {\n          if (err) {\n            reject(err);\n          } else {\n            this.basePathExists = true;\n            resolve();\n          }\n        });\n      }\n    });\n  }\n\n\n  /**\n   * Gets the contents of the file with the given key.\n   * @param {string} key: The key of the cache item.\n   * @param defaultValue: Optional. A default value to return if the value does not exist in cache.\n   * @return {Promise} - File contents, or\n   *                     undefined if the file does not exist.\n   */\n  get(key, defaultValue) { return getValueP(this.path(key), defaultValue); }\n\n\n  /**\n   * Gets the contents of the file with the given key.\n   * @param {string} key: The key of the cache item.\n   * @param defaultValue: Optional. A default value to return if the value does not exist in cache.\n   * @return the cached value, or undefined.\n   */\n  getSync(key, defaultValue) {\n    const path = this.path(key);\n    return fs.existsSync(path)\n      ? toGetValue(fs.readJsonSync(path))\n      : defaultValue;\n  }\n\n\n  /**\n   * Writes the given value to the file-system.\n   * @param {string} key: The key of the cache item.\n   * @param value: The value to write (Primitive or Object).\n   * @return {Promise}\n   */\n  set(key, value) {\n    const path = this.path(key);\n    return new Promise((resolve, reject) => {\n      this.ensureBasePath()\n      .then(() => {\n        fs.outputFile(path, toJson(value), (err) => {\n          if (err) { reject(err); } else { resolve({ path }); }\n        });\n      })\n      .catch(err => reject(err));\n    });\n  }\n\n\n  /**\n   * Writes the given value to the file-system and memory cache.\n   * @param {string} key: The key of the cache item.\n   * @param value: The value to write (Primitive or Object).\n   * @return the cache.\n   */\n  setSync(key, value) {\n    fs.outputFileSync(this.path(key), toJson(value));\n    return this;\n  }\n\n\n  /**\n   * Removes the item from the file-system.\n   * @param {string} key: The key of the cache item.\n   * @return {Promise}\n   */\n  remove(key) { return f.removeFileP(this.path(key)); }\n\n\n  /**\n   * Removes all items from the cache.\n   * @return {Promise}\n   */\n  clear() {\n    return new Promise((resolve, reject) => {\n      f.filePathsP(this.basePath, this.ns)\n        .then(paths => {\n          const remove = (index) => {\n            const path = paths[index];\n            if (path) {\n              f.removeFileP(path)\n              .then(() => remove(index + 1)) // <== RECURSION.\n              .catch(err => reject(err));\n            } else {\n              resolve(); // All files have been removed.\n            }\n          };\n          remove(0);\n        })\n        .catch(err => reject(err));\n    });\n  }\n\n\n  /**\n   * Saves several items to the cache in one operation.\n   * @param {array} items: An array of objects of the form { key, value }.\n   * @return {Promise}\n   */\n  save(items) {\n    // Setup initial conditions.\n    if (!R.is(Array, items)) { items = [items]; }\n    const isValid = (item) => {\n      if (!R.is(Object, item)) { return false; }\n      return item.key && item.value;\n    };\n    items = R.pipe(\n      R.reject(R.isNil),\n      R.forEach((item) => {\n        if (!isValid(item)) {\n          throw new Error(`Save items not valid, must be an array of {key, value} objects.`);\n        }\n      })\n    )(items);\n\n    return new Promise((resolve, reject) => {\n      // Don't continue if no items were passed.\n      const response = { paths: [] };\n      if (items.length === 0) {\n        resolve(response);\n        return;\n      }\n\n      // Recursively set each item to the file-system.\n      const setValue = (index) => {\n        const item = items[index];\n        if (item) {\n          this.set(item.key, item.value)\n          .then(result => {\n            response.paths[index] = result.path;\n            setValue(index + 1); // <== RECURSION.\n          })\n          .catch(err => reject(err));\n        } else {\n          // No more items - done.\n          resolve(response);\n        }\n      };\n      setValue(0);\n    });\n  }\n\n\n  /**\n   * Loads all files within the cache's namespace.\n   */\n  load() {\n    return new Promise((resolve, reject) => {\n      f.filePathsP(this.basePath, this.ns)\n        .then(paths => {\n          // Bail out if there are no paths in the folder.\n          const response = { files: [] };\n          if (paths.length === 0) {\n            resolve(response);\n            return;\n          }\n\n          // Get each value.\n          const getValue = (index) => {\n            const path = paths[index];\n            if (path) {\n              getValueP(path)\n              .then(result => {\n                response.files[index] = { path, value: result };\n                getValue(index + 1); // <== RECURSION.\n              })\n              .catch(err => reject(err));\n            } else {\n              // All paths have been loaded.\n              resolve(response);\n            }\n          };\n          getValue(0);\n        })\n        .catch(err => reject(err));\n    });\n  }\n}\n"]}