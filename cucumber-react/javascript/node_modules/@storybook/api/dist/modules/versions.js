"use strict";

require("core-js/modules/es.array.find");

require("core-js/modules/es.date.now");

require("core-js/modules/es.date.to-string");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.object.values");

require("core-js/modules/es.promise");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _default;

require("regenerator-runtime/runtime");

var _global = require("global");

var _semver = _interopRequireDefault(require("semver"));

var _clientLogger = require("@storybook/client-logger");

var _version = require("../version");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var checkInterval = 24 * 60 * 60 * 1000;
var versionsUrl = 'https://storybook.js.org/versions.json';

function fetchLatestVersion(v) {
  var fromFetch;
  return regeneratorRuntime.async(function fetchLatestVersion$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap((0, _global.fetch)("".concat(versionsUrl, "?current=").concat(v)));

        case 2:
          fromFetch = _context.sent;
          return _context.abrupt("return", fromFetch.json());

        case 4:
        case "end":
          return _context.stop();
      }
    }
  });
}

function _default(_ref) {
  var store = _ref.store,
      mode = _ref.mode;

  var _store$getState = store.getState(),
      _store$getState$versi = _store$getState.versions,
      persistedVersions = _store$getState$versi === void 0 ? {} : _store$getState$versi,
      _store$getState$lastV = _store$getState.lastVersionCheck,
      lastVersionCheck = _store$getState$lastV === void 0 ? 0 : _store$getState$lastV,
      dismissedVersionNotification = _store$getState.dismissedVersionNotification; // Check to see if we have info about the current version persisted


  var persistedCurrentVersion = Object.values(persistedVersions).find(function (v) {
    return v.version === _version.version;
  });
  var state = {
    versions: Object.assign({}, persistedVersions, {
      current: Object.assign({
        version: _version.version
      }, persistedCurrentVersion && {
        info: persistedCurrentVersion.info
      })
    }),
    lastVersionCheck: lastVersionCheck,
    dismissedVersionNotification: dismissedVersionNotification
  };
  var api = {
    getCurrentVersion: function getCurrentVersion() {
      var _store$getState2 = store.getState(),
          current = _store$getState2.versions.current;

      return current;
    },
    getLatestVersion: function getLatestVersion() {
      var _store$getState3 = store.getState(),
          _store$getState3$vers = _store$getState3.versions,
          latest = _store$getState3$vers.latest,
          next = _store$getState3$vers.next,
          current = _store$getState3$vers.current;

      if (current && _semver["default"].prerelease(current.version) && next) {
        return latest && _semver["default"].gt(latest.version, next.version) ? latest : next;
      }

      return latest;
    },
    versionUpdateAvailable: function versionUpdateAvailable() {
      var latest = api.getLatestVersion();
      var current = api.getCurrentVersion();

      if (!latest || !latest.version) {
        return true;
      }

      return latest && _semver["default"].gt(latest.version, current.version);
    }
  }; // Grab versions from the server/local storage right away

  function init(_ref2) {
    var fullApi, _store$getState4, _store$getState4$vers, versions, now, _ref3, latest, next, latestVersion;

    return regeneratorRuntime.async(function init$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            fullApi = _ref2.api;
            _store$getState4 = store.getState(), _store$getState4$vers = _store$getState4.versions, versions = _store$getState4$vers === void 0 ? {} : _store$getState4$vers;
            now = Date.now();

            if (!(!lastVersionCheck || now - lastVersionCheck > checkInterval)) {
              _context2.next = 17;
              break;
            }

            _context2.prev = 4;
            _context2.next = 7;
            return regeneratorRuntime.awrap(fetchLatestVersion(_version.version));

          case 7:
            _ref3 = _context2.sent;
            latest = _ref3.latest;
            next = _ref3.next;
            _context2.next = 12;
            return regeneratorRuntime.awrap(store.setState({
              versions: Object.assign({}, versions, {
                latest: latest,
                next: next
              }),
              lastVersionCheck: now
            }, {
              persistence: 'permanent'
            }));

          case 12:
            _context2.next = 17;
            break;

          case 14:
            _context2.prev = 14;
            _context2.t0 = _context2["catch"](4);

            _clientLogger.logger.warn("Failed to fetch latest version from server: ".concat(_context2.t0));

          case 17:
            if (api.versionUpdateAvailable()) {
              latestVersion = api.getLatestVersion().version;

              if (latestVersion !== dismissedVersionNotification && !_semver["default"].patch(latestVersion) && !_semver["default"].prerelease(latestVersion) && mode !== 'production') {
                fullApi.addNotification({
                  id: 'update',
                  link: '/settings/about',
                  content: "\uD83C\uDF89 Storybook ".concat(latestVersion, " is available!"),
                  onClear: function onClear() {
                    store.setState({
                      dismissedVersionNotification: latestVersion
                    }, {
                      persistence: 'permanent'
                    });
                  }
                });
              }
            }

          case 18:
          case "end":
            return _context2.stop();
        }
      }
    }, null, null, [[4, 14]]);
  }

  return {
    init: init,
    state: state,
    api: api
  };
}