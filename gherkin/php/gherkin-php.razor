@using Berp;
@helper CallProduction(ProductionRule production)
{
    switch(production.Type) {
        case ProductionRuleType.Start:
            @:$this->startRule($context, RuleType::@production.RuleName);
            break;
        case ProductionRuleType.End:
            @:$this->endRule($context, RuleType::@production.RuleName);
            break;
        case ProductionRuleType.Process:
            @:$this->build($context, $token);
            break;
    }
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{<text>
        $stateComment = "State: @state.Id - @Raw(state.Comment)";
        $expectedTokens = ["@Raw(string.Join("\", \"", expectedTokens))"];
        $error = $token->isEOF()
                ? new UnexpectedEofException($token, $expectedTokens, $stateComment)
                : new UnexpectedTokenException($token, $expectedTokens, $stateComment);

        $this->addError($context, $error);

        return @state.Id;
</text>}
@helper matchToken(TokenType tokenType)
{<text>$this->match_@(tokenType)($context, $token)</text>}
Parser/TokenMatcherInterface.php
<?php declare(strict_types=1);

/**
 * This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
 *
 *  Changes to this file may cause incorrect behavior and will be lost if
 *  the code is regenerated.
 */

namespace Cucumber\Gherkin\Parser;

use Cucumber\Gherkin\Token;

interface TokenMatcherInterface
{
    @foreach(var rule in Model.RuleSet.TokenRules)
    {
    @:public function match_@(rule.Name.Replace("#", ""))(Token $token) : bool;
    }
    public function reset() : void;
}

Parser/TokenType.php
<?php declare(strict_types=1);

/**
 * This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
 *
 *  Changes to this file may cause incorrect behavior and will be lost if
 *  the code is regenerated.
 */

namespace Cucumber\Gherkin\Parser;

enum TokenType
{
	case None;
	@foreach(var rule in Model.RuleSet.TokenRules)
    {
        <text>    case @rule.Name.Replace("#", "");
</text>
	}
}

Parser/RuleType.php
<?php declare(strict_types=1);

/**
 * This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
 *
 *  Changes to this file may cause incorrect behavior and will be lost if
 *  the code is regenerated.
 */

namespace Cucumber\Gherkin\Parser;

enum RuleType
{
	use TokenRuleTypesCastTrait;

    case None;
    @foreach(var rule in Model.RuleSet.Where(r => !r.TempRule))
    {
        <text>    case @rule.Name.Replace("#", "_"); // @rule.ToString(true)
</text>
	}
}

Parser.php
<?php declare(strict_types=1);

/**
 * This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
 *
 *  Changes to this file may cause incorrect behavior and will be lost if
 *  the code is regenerated.
 */

namespace Cucumber\Gherkin;

use Cucumber\Gherkin\Parser\ParserContext;
use Cucumber\Gherkin\Parser\ParserTrait;
use Cucumber\Gherkin\Parser\RuleType;
use Cucumber\Gherkin\ParserException\UnexpectedTokenException;
use Cucumber\Gherkin\ParserException\UnexpectedEofException;

/**
 * @@template T
 */
final class @Model.ParserClassName
{
	/**
	 * @@use ParserTrait<T>
	 */
    use ParserTrait;
@foreach(var rule in Model.RuleSet.TokenRules)
{<text>
    private function match_@(rule.Name.Replace("#", ""))(ParserContext $context, Token $token) : bool
    {
        @if (rule.Name != "#EOF")
        {
<text>        if ($token->isEOF()) {
            return false;
        }

</text>
        }
        return $this->handleExternalError(
            $context,
            fn() => $context->tokenMatcher->match_@(rule.Name.Replace("#", ""))($token),
            false,
        );
    }
</text>
}

    private function matchToken(int $state, Token $token, ParserContext $context) : int
    {
        return match($state)
        {
        @foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
        {
            @:@state.Id => $this->matchTokenAt_@(state.Id)($token, $context),
        }
            default => throw new \LogicException("Unknown state: $state"),
        };
    }

@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
{
<text>
    // @Raw(state.Comment)
    private function matchTokenAt_@(state.Id)(Token $token, ParserContext $context) : int
    {
        @foreach(var transition in state.Transitions)
        {
        @:if (@matchToken(transition.TokenType)) {
            if (transition.LookAheadHint != null)
            {
            @:if ($this->lookahead_@(transition.LookAheadHint.Id)($context))
            @:{
            }
            foreach(var production in transition.Productions)
            {
                @CallProduction(production)
            }
            @:return @transition.TargetState;
            if (transition.LookAheadHint != null)
            {
            @:}
            }
        @:}
        }
        @HandleParserError(state.Transitions.Select(t => "#" + t.TokenType.ToString()).Distinct(), state)
    }
</text>
}

@foreach(var lookAheadHint in Model.RuleSet.LookAheadHints)
{
<text>
    private function lookahead_@(lookAheadHint.Id)(ParserContext $context) : bool
    {
        $queue = [];
        $match = false;
        do
        {
            $token = $this->readToken($context);
            $queue[] = $token;

            if (false
            @foreach(var tokenType in lookAheadHint.ExpectedTokens)
            {
                @:|| @matchToken(tokenType)
            }
            )
            {
                $match = true;
                break;
            }
        } while (false
        @foreach(var tokenType in lookAheadHint.Skip)
        {
            @:|| @matchToken(tokenType)
        }
        );

        $context->tokenQueue = [...$context->tokenQueue, ...$queue];

        return $match;
    }
</text>
}


}
