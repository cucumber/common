// ------------------------------------------------------------------------------
//  <auto-generated>
//      This code was generated by Berp (http://https://github.com/gasparnagy/berp/).
// 
//      Changes to this file may cause incorrect behavior and will be lost if
//      the code is regenerated.
//  </auto-generated>
// ------------------------------------------------------------------------------
#region Designer generated code
#pragma warning disable
@using Berp;
@helper CallProduction(ProductionRule production)
{
    switch(production.Type)
    {
        case ProductionRuleType.Start:
                @:StartRule(context, RuleType.@production.RuleName);
            break;
        case ProductionRuleType.End:
                @:EndRule(context, RuleType.@production.RuleName);
            break;
        case ProductionRuleType.Process:
                @:Build(context, token);
            break;
    }
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{<text>
            const string stateComment = "State: @state.Id - @Raw(state.Comment)";
            token.Detach();
            var expectedTokens = new string[] {"@Raw(string.Join("\", \"", expectedTokens))"};
            var error = token.IsEOF ? (ParserException)new UnexpectedEOFException(token, expectedTokens, stateComment) 
                : new UnexpectedTokenException(token, expectedTokens, stateComment);
            if (StopAtFirstError)
                throw error;
            
            AddError(context, error);
            return @state.Id;
</text>}
@helper MatchToken(TokenType tokenType)
{<text>Match_@(tokenType)(context, token)</text>}
using System;
using System.Linq;
using System.Collections.Generic;
namespace @Model.Namespace
{
    public enum TokenType
    {
        None,
        @foreach(var rule in Model.RuleSet.TokenRules)
        {<text>        @rule.Name.Replace("#", ""),
</text>}
    }

    public enum RuleType
    {
        None,
        @foreach(var rule in Model.RuleSet.Where(r => !r.TempRule))
        {<text>        @rule.Name.Replace("#", "_"), // @rule.ToString(true)
</text>}
    }

    [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public partial class @Model.ParserClassName<T>
    {
        private readonly IAstBuilder<T> astBuilder;

        public Parser()
            : this(new AstBuilder<T>())
        {
        }

        public Parser(IAstBuilder<T> astBuilder)
        {
            this.astBuilder = astBuilder;
        }

        public bool StopAtFirstError { get; set;}

        [System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        protected class ParserContext
        {
            public ITokenScanner TokenScanner { get; set; }
            public ITokenMatcher TokenMatcher { get; set; }
            public Queue<Token> TokenQueue { get; set; }
            public List<ParserException> Errors { get; set; }
        }

        public T Parse(ITokenScanner tokenScanner)
        {
            return Parse(tokenScanner, new TokenMatcher());
        }

        public T Parse(ITokenScanner tokenScanner, ITokenMatcher tokenMatcher)
        {
            tokenMatcher.Reset();
            astBuilder.Reset();
            var context = new ParserContext
            {
                TokenScanner = tokenScanner,
                TokenMatcher = tokenMatcher,
                TokenQueue = new Queue<Token>(),
                Errors = new List<ParserException>()
            };

            StartRule(context, RuleType.@Model.RuleSet.StartRule.Name);
            int state = 0;
            Token token;
            do
            {
                token = ReadToken(context);
                state = MatchToken(state, token, context);
            } while(!token.IsEOF);

            EndRule(context, RuleType.@Model.RuleSet.StartRule.Name);

            if (context.Errors.Count > 0)
            {
                throw new CompositeParserException(context.Errors.ToArray());
            }

            return GetResult(context);
        }

        private void AddError(ParserContext context, ParserException error)
        {
            if (context.Errors.Any(e => e.Message == error.Message))
                return;
            context.Errors.Add(error);
            if (context.Errors.Count > 10)
                throw new CompositeParserException(context.Errors.ToArray());
        }

        private void HandleAstError(ParserContext context, Action action)
        {
            HandleExternalError(context, () => { action(); return true; });
        }

        private T HandleExternalError<T>(ParserContext context, Func<T> action, T defaultValue = default(T))
        {
            if (StopAtFirstError)
            {
                return action();
            }

            try
            {
                return action();
            }
            catch (CompositeParserException compositeParserException)
            {
                foreach (var error in compositeParserException.Errors)
                    AddError(context, error);
            }
            catch (ParserException error)
            {
                AddError(context, error);
            }
            return defaultValue;
        }

        void Build(ParserContext context, Token token)
        {
            HandleAstError(context, () => this.astBuilder.Build(token));
        }

        void StartRule(ParserContext context, RuleType ruleType)
        {
            HandleAstError(context, () => this.astBuilder.StartRule(ruleType));
        }

        void EndRule(ParserContext context, RuleType ruleType)
        {
            HandleAstError(context, () => this.astBuilder.EndRule(ruleType));
        }

        T GetResult(ParserContext context)
        {
            return this.astBuilder.GetResult();
        }

        Token ReadToken(ParserContext context)
        {
            return context.TokenQueue.Count > 0 ? context.TokenQueue.Dequeue() : context.TokenScanner.Read();
        }

        @foreach(var rule in Model.RuleSet.TokenRules)
        {<text>
        bool Match_@(rule.Name.Replace("#", ""))(ParserContext context, Token token)
        {
            @if (rule.Name != "#EOF")
            {
            @:if (token.IsEOF) return false;
            }
            return HandleExternalError(context, () => context.TokenMatcher.Match_@(rule.Name.Replace("#", ""))(token), false); 
        }</text>
        }

        protected virtual int MatchToken(int state, Token token, ParserContext context)
        {
            int newState;
            switch(state)
            {
            @foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
            {
                @:case @state.Id:
                    @:newState = MatchTokenAt_@(state.Id)(token, context);
                    @:break;
            }
                default:
                    throw new InvalidOperationException("Unknown state: " + state);
            }
            return newState;
        }

    @foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
    {
        <text>
        // @Raw(state.Comment)
        int MatchTokenAt_@(state.Id)(Token token, ParserContext context)
        {
            @foreach(var transition in state.Transitions)
            {
            @:if (@MatchToken(transition.TokenType))
            @:{
                if (transition.LookAheadHint != null)
                {
                @:if (LookAhead_@(transition.LookAheadHint.Id)(context, token))
                @:{
                }
                foreach(var production in transition.Productions)
                {
                    @CallProduction(production)
                }
                @:return @transition.TargetState;
                if (transition.LookAheadHint != null)
                {
                @:}
                }
            @:}
            }
            @HandleParserError(state.Transitions.Select(t => "#" + t.TokenType.ToString()).Distinct(), state)
        }
        </text>
    }

    @foreach(var lookAheadHint in Model.RuleSet.LookAheadHints)
    {
        <text>
        bool LookAhead_@(lookAheadHint.Id)(ParserContext context, Token currentToken)
        {
            currentToken.Detach();
            Token token;
            var queue = new Queue<Token>();
            bool match = false;
            do
            {
                token = ReadToken(context);
                token.Detach();
                queue.Enqueue(token);

                if (false
                @foreach(var tokenType in lookAheadHint.ExpectedTokens)
                {
                    @:|| @MatchToken(tokenType)
                }
                )
                {
                    match = true;
                    break;
                }
            } while (false
            @foreach(var tokenType in lookAheadHint.Skip)
            {
                @:|| @MatchToken(tokenType)
            }
            );
            foreach(var t in queue)
                context.TokenQueue.Enqueue(t);
            return match;
        }
        </text>
    }
    }

    public partial interface IAstBuilder<T> 
    {
        void Build(Token token);
        void StartRule(RuleType ruleType);
        void EndRule(RuleType ruleType);
        T GetResult();
        void Reset();
    }

    public partial interface ITokenScanner 
    {
        Token Read();
    }

    public partial interface ITokenMatcher
    {
        @foreach(var rule in Model.RuleSet.TokenRules)
        {
        @:bool Match_@(rule.Name.Replace("#", ""))(Token token);
        }
        void Reset();
    }
}
#pragma warning restore
#endregion
