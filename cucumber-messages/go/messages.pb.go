// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: messages.proto

package messages

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SourcesOrderType int32

const (
	SourcesOrderType_ORDER_OF_DEFINITION SourcesOrderType = 0
	SourcesOrderType_RANDOM              SourcesOrderType = 1
)

var SourcesOrderType_name = map[int32]string{
	0: "ORDER_OF_DEFINITION",
	1: "RANDOM",
}

var SourcesOrderType_value = map[string]int32{
	"ORDER_OF_DEFINITION": 0,
	"RANDOM":              1,
}

func (x SourcesOrderType) String() string {
	return proto.EnumName(SourcesOrderType_name, int32(x))
}

func (SourcesOrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{0}
}

type StepDefinitionPatternType int32

const (
	StepDefinitionPatternType_CUCUMBER_EXPRESSION StepDefinitionPatternType = 0
	StepDefinitionPatternType_REGULAR_EXPRESSION  StepDefinitionPatternType = 1
)

var StepDefinitionPatternType_name = map[int32]string{
	0: "CUCUMBER_EXPRESSION",
	1: "REGULAR_EXPRESSION",
}

var StepDefinitionPatternType_value = map[string]int32{
	"CUCUMBER_EXPRESSION": 0,
	"REGULAR_EXPRESSION":  1,
}

func (x StepDefinitionPatternType) String() string {
	return proto.EnumName(StepDefinitionPatternType_name, int32(x))
}

func (StepDefinitionPatternType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{1}
}

type Media_Encoding int32

const (
	// Base64 encoded binary data
	Media_BASE64 Media_Encoding = 0
	// UTF8 encoded string
	Media_UTF8 Media_Encoding = 1
)

var Media_Encoding_name = map[int32]string{
	0: "BASE64",
	1: "UTF8",
}

var Media_Encoding_value = map[string]int32{
	"BASE64": 0,
	"UTF8":   1,
}

func (x Media_Encoding) String() string {
	return proto.EnumName(Media_Encoding_name, int32(x))
}

func (Media_Encoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{5, 0}
}

//*
// Status of a step. Can also represent status of a Pickle (aggregated
// from the status of its steps).
//
// The ordinal values of statuses are significant. The status of a Pickle
// is determined by the union of statuses of its steps. The
// status of the Pickle is the status with the highest ordinal
// in the enum.
//
// For example, if a pickle has steps with statuses passed, undefined and skipped,
// then the pickle's status is undefined.
type TestResult_Status int32

const (
	// The step hasn't been matched or executed.
	TestResult_UNKNOWN TestResult_Status = 0
	// The step matched one step definition and passed execution.
	TestResult_PASSED TestResult_Status = 1
	// The step matched one step definition but was not executed because the
	// previous step was not PASSED.
	TestResult_SKIPPED TestResult_Status = 2
	// The step matched one step definition and signalled pending during execution.
	// This is the default behaviour of generated step definitions, which either
	// throw a special PendingException, or return a special value indicating that it's
	// pending. How to signal the pending status depends on the Cucumber implementation.
	TestResult_PENDING TestResult_Status = 3
	// The step matched no step definitions.
	TestResult_UNDEFINED TestResult_Status = 4
	// The step matched two or more step definitions.
	TestResult_AMBIGUOUS TestResult_Status = 5
	// The step matched one step definition and failed execution.
	TestResult_FAILED TestResult_Status = 6
)

var TestResult_Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "PASSED",
	2: "SKIPPED",
	3: "PENDING",
	4: "UNDEFINED",
	5: "AMBIGUOUS",
	6: "FAILED",
}

var TestResult_Status_value = map[string]int32{
	"UNKNOWN":   0,
	"PASSED":    1,
	"SKIPPED":   2,
	"PENDING":   3,
	"UNDEFINED": 4,
	"AMBIGUOUS": 5,
	"FAILED":    6,
}

func (x TestResult_Status) String() string {
	return proto.EnumName(TestResult_Status_name, int32(x))
}

func (TestResult_Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{24, 0}
}

// From https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/timestamp.proto
type Timestamp struct {
	// Represents seconds of UTC time since Unix epoch
	// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	// 9999-12-31T23:59:59Z inclusive.
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive.
	Nanos int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
}

func (m *Timestamp) Reset()         { *m = Timestamp{} }
func (m *Timestamp) String() string { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()    {}
func (*Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{0}
}
func (m *Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timestamp.Merge(m, src)
}
func (m *Timestamp) XXX_Size() int {
	return m.Size()
}
func (m *Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Timestamp proto.InternalMessageInfo

func (m *Timestamp) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Timestamp) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

// The structure is pretty close of the Timestamp one. For clarity, a second type
// of message is used.
type Duration struct {
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive.
	Nanos int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
}

func (m *Duration) Reset()         { *m = Duration{} }
func (m *Duration) String() string { return proto.CompactTextString(m) }
func (*Duration) ProtoMessage()    {}
func (*Duration) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{1}
}
func (m *Duration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Duration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Duration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Duration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Duration.Merge(m, src)
}
func (m *Duration) XXX_Size() int {
	return m.Size()
}
func (m *Duration) XXX_DiscardUnknown() {
	xxx_messageInfo_Duration.DiscardUnknown(m)
}

var xxx_messageInfo_Duration proto.InternalMessageInfo

func (m *Duration) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Duration) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

//*
// All the messages that are passed between different components/processes are Envelope
// messages.
type Envelope struct {
	// Types that are valid to be assigned to Message:
	//	*Envelope_Source
	//	*Envelope_GherkinDocument
	//	*Envelope_Pickle
	//	*Envelope_Attachment
	//	*Envelope_TestCaseStarted
	//	*Envelope_TestStepStarted
	//	*Envelope_TestStepFinished
	//	*Envelope_TestCaseFinished
	//	*Envelope_TestHookStarted
	//	*Envelope_TestHookFinished
	//	*Envelope_PickleAccepted
	//	*Envelope_PickleRejected
	//	*Envelope_TestCasePrepared
	//	*Envelope_TestRunStarted
	//	*Envelope_TestRunFinished
	//	*Envelope_CommandStart
	//	*Envelope_CommandActionComplete
	//	*Envelope_CommandRunBeforeTestRunHooks
	//	*Envelope_CommandInitializeTestCase
	//	*Envelope_CommandRunBeforeTestCaseHook
	//	*Envelope_CommandRunTestStep
	//	*Envelope_CommandRunAfterTestCaseHook
	//	*Envelope_CommandRunAfterTestRunHooks
	//	*Envelope_CommandGenerateSnippet
	//	*Envelope_CommandError
	//	*Envelope_TestStepMatched
	//	*Envelope_TestCase
	Message isEnvelope_Message `protobuf_oneof:"message"`
}

func (m *Envelope) Reset()         { *m = Envelope{} }
func (m *Envelope) String() string { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()    {}
func (*Envelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{2}
}
func (m *Envelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Envelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Envelope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Envelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Envelope.Merge(m, src)
}
func (m *Envelope) XXX_Size() int {
	return m.Size()
}
func (m *Envelope) XXX_DiscardUnknown() {
	xxx_messageInfo_Envelope.DiscardUnknown(m)
}

var xxx_messageInfo_Envelope proto.InternalMessageInfo

type isEnvelope_Message interface {
	isEnvelope_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Envelope_Source struct {
	Source *Source `protobuf:"bytes,1,opt,name=source,proto3,oneof"`
}
type Envelope_GherkinDocument struct {
	GherkinDocument *GherkinDocument `protobuf:"bytes,2,opt,name=gherkinDocument,proto3,oneof"`
}
type Envelope_Pickle struct {
	Pickle *Pickle `protobuf:"bytes,3,opt,name=pickle,proto3,oneof"`
}
type Envelope_Attachment struct {
	Attachment *Attachment `protobuf:"bytes,4,opt,name=attachment,proto3,oneof"`
}
type Envelope_TestCaseStarted struct {
	TestCaseStarted *TestCaseStarted `protobuf:"bytes,5,opt,name=testCaseStarted,proto3,oneof"`
}
type Envelope_TestStepStarted struct {
	TestStepStarted *TestStepStarted `protobuf:"bytes,6,opt,name=testStepStarted,proto3,oneof"`
}
type Envelope_TestStepFinished struct {
	TestStepFinished *TestStepFinished `protobuf:"bytes,7,opt,name=testStepFinished,proto3,oneof"`
}
type Envelope_TestCaseFinished struct {
	TestCaseFinished *TestCaseFinished `protobuf:"bytes,8,opt,name=testCaseFinished,proto3,oneof"`
}
type Envelope_TestHookStarted struct {
	TestHookStarted *TestHookStarted `protobuf:"bytes,9,opt,name=testHookStarted,proto3,oneof"`
}
type Envelope_TestHookFinished struct {
	TestHookFinished *TestHookFinished `protobuf:"bytes,10,opt,name=testHookFinished,proto3,oneof"`
}
type Envelope_PickleAccepted struct {
	PickleAccepted *PickleAccepted `protobuf:"bytes,11,opt,name=pickleAccepted,proto3,oneof"`
}
type Envelope_PickleRejected struct {
	PickleRejected *PickleRejected `protobuf:"bytes,12,opt,name=pickleRejected,proto3,oneof"`
}
type Envelope_TestCasePrepared struct {
	TestCasePrepared *TestCasePrepared `protobuf:"bytes,13,opt,name=testCasePrepared,proto3,oneof"`
}
type Envelope_TestRunStarted struct {
	TestRunStarted *TestRunStarted `protobuf:"bytes,14,opt,name=testRunStarted,proto3,oneof"`
}
type Envelope_TestRunFinished struct {
	TestRunFinished *TestRunFinished `protobuf:"bytes,15,opt,name=testRunFinished,proto3,oneof"`
}
type Envelope_CommandStart struct {
	CommandStart *CommandStart `protobuf:"bytes,16,opt,name=commandStart,proto3,oneof"`
}
type Envelope_CommandActionComplete struct {
	CommandActionComplete *CommandActionComplete `protobuf:"bytes,17,opt,name=commandActionComplete,proto3,oneof"`
}
type Envelope_CommandRunBeforeTestRunHooks struct {
	CommandRunBeforeTestRunHooks *CommandRunBeforeTestRunHooks `protobuf:"bytes,18,opt,name=commandRunBeforeTestRunHooks,proto3,oneof"`
}
type Envelope_CommandInitializeTestCase struct {
	CommandInitializeTestCase *CommandInitializeTestCase `protobuf:"bytes,19,opt,name=commandInitializeTestCase,proto3,oneof"`
}
type Envelope_CommandRunBeforeTestCaseHook struct {
	CommandRunBeforeTestCaseHook *CommandRunBeforeTestCaseHook `protobuf:"bytes,20,opt,name=commandRunBeforeTestCaseHook,proto3,oneof"`
}
type Envelope_CommandRunTestStep struct {
	CommandRunTestStep *CommandRunTestStep `protobuf:"bytes,21,opt,name=commandRunTestStep,proto3,oneof"`
}
type Envelope_CommandRunAfterTestCaseHook struct {
	CommandRunAfterTestCaseHook *CommandRunAfterTestCaseHook `protobuf:"bytes,22,opt,name=commandRunAfterTestCaseHook,proto3,oneof"`
}
type Envelope_CommandRunAfterTestRunHooks struct {
	CommandRunAfterTestRunHooks *CommandRunAfterTestRunHooks `protobuf:"bytes,23,opt,name=commandRunAfterTestRunHooks,proto3,oneof"`
}
type Envelope_CommandGenerateSnippet struct {
	CommandGenerateSnippet *CommandGenerateSnippet `protobuf:"bytes,24,opt,name=commandGenerateSnippet,proto3,oneof"`
}
type Envelope_CommandError struct {
	CommandError string `protobuf:"bytes,25,opt,name=commandError,proto3,oneof"`
}
type Envelope_TestStepMatched struct {
	TestStepMatched *TestStepMatched `protobuf:"bytes,26,opt,name=testStepMatched,proto3,oneof"`
}
type Envelope_TestCase struct {
	TestCase *TestCase `protobuf:"bytes,27,opt,name=testCase,proto3,oneof"`
}

func (*Envelope_Source) isEnvelope_Message()                       {}
func (*Envelope_GherkinDocument) isEnvelope_Message()              {}
func (*Envelope_Pickle) isEnvelope_Message()                       {}
func (*Envelope_Attachment) isEnvelope_Message()                   {}
func (*Envelope_TestCaseStarted) isEnvelope_Message()              {}
func (*Envelope_TestStepStarted) isEnvelope_Message()              {}
func (*Envelope_TestStepFinished) isEnvelope_Message()             {}
func (*Envelope_TestCaseFinished) isEnvelope_Message()             {}
func (*Envelope_TestHookStarted) isEnvelope_Message()              {}
func (*Envelope_TestHookFinished) isEnvelope_Message()             {}
func (*Envelope_PickleAccepted) isEnvelope_Message()               {}
func (*Envelope_PickleRejected) isEnvelope_Message()               {}
func (*Envelope_TestCasePrepared) isEnvelope_Message()             {}
func (*Envelope_TestRunStarted) isEnvelope_Message()               {}
func (*Envelope_TestRunFinished) isEnvelope_Message()              {}
func (*Envelope_CommandStart) isEnvelope_Message()                 {}
func (*Envelope_CommandActionComplete) isEnvelope_Message()        {}
func (*Envelope_CommandRunBeforeTestRunHooks) isEnvelope_Message() {}
func (*Envelope_CommandInitializeTestCase) isEnvelope_Message()    {}
func (*Envelope_CommandRunBeforeTestCaseHook) isEnvelope_Message() {}
func (*Envelope_CommandRunTestStep) isEnvelope_Message()           {}
func (*Envelope_CommandRunAfterTestCaseHook) isEnvelope_Message()  {}
func (*Envelope_CommandRunAfterTestRunHooks) isEnvelope_Message()  {}
func (*Envelope_CommandGenerateSnippet) isEnvelope_Message()       {}
func (*Envelope_CommandError) isEnvelope_Message()                 {}
func (*Envelope_TestStepMatched) isEnvelope_Message()              {}
func (*Envelope_TestCase) isEnvelope_Message()                     {}

func (m *Envelope) GetMessage() isEnvelope_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Envelope) GetSource() *Source {
	if x, ok := m.GetMessage().(*Envelope_Source); ok {
		return x.Source
	}
	return nil
}

func (m *Envelope) GetGherkinDocument() *GherkinDocument {
	if x, ok := m.GetMessage().(*Envelope_GherkinDocument); ok {
		return x.GherkinDocument
	}
	return nil
}

func (m *Envelope) GetPickle() *Pickle {
	if x, ok := m.GetMessage().(*Envelope_Pickle); ok {
		return x.Pickle
	}
	return nil
}

func (m *Envelope) GetAttachment() *Attachment {
	if x, ok := m.GetMessage().(*Envelope_Attachment); ok {
		return x.Attachment
	}
	return nil
}

func (m *Envelope) GetTestCaseStarted() *TestCaseStarted {
	if x, ok := m.GetMessage().(*Envelope_TestCaseStarted); ok {
		return x.TestCaseStarted
	}
	return nil
}

func (m *Envelope) GetTestStepStarted() *TestStepStarted {
	if x, ok := m.GetMessage().(*Envelope_TestStepStarted); ok {
		return x.TestStepStarted
	}
	return nil
}

func (m *Envelope) GetTestStepFinished() *TestStepFinished {
	if x, ok := m.GetMessage().(*Envelope_TestStepFinished); ok {
		return x.TestStepFinished
	}
	return nil
}

func (m *Envelope) GetTestCaseFinished() *TestCaseFinished {
	if x, ok := m.GetMessage().(*Envelope_TestCaseFinished); ok {
		return x.TestCaseFinished
	}
	return nil
}

func (m *Envelope) GetTestHookStarted() *TestHookStarted {
	if x, ok := m.GetMessage().(*Envelope_TestHookStarted); ok {
		return x.TestHookStarted
	}
	return nil
}

func (m *Envelope) GetTestHookFinished() *TestHookFinished {
	if x, ok := m.GetMessage().(*Envelope_TestHookFinished); ok {
		return x.TestHookFinished
	}
	return nil
}

func (m *Envelope) GetPickleAccepted() *PickleAccepted {
	if x, ok := m.GetMessage().(*Envelope_PickleAccepted); ok {
		return x.PickleAccepted
	}
	return nil
}

func (m *Envelope) GetPickleRejected() *PickleRejected {
	if x, ok := m.GetMessage().(*Envelope_PickleRejected); ok {
		return x.PickleRejected
	}
	return nil
}

func (m *Envelope) GetTestCasePrepared() *TestCasePrepared {
	if x, ok := m.GetMessage().(*Envelope_TestCasePrepared); ok {
		return x.TestCasePrepared
	}
	return nil
}

func (m *Envelope) GetTestRunStarted() *TestRunStarted {
	if x, ok := m.GetMessage().(*Envelope_TestRunStarted); ok {
		return x.TestRunStarted
	}
	return nil
}

func (m *Envelope) GetTestRunFinished() *TestRunFinished {
	if x, ok := m.GetMessage().(*Envelope_TestRunFinished); ok {
		return x.TestRunFinished
	}
	return nil
}

func (m *Envelope) GetCommandStart() *CommandStart {
	if x, ok := m.GetMessage().(*Envelope_CommandStart); ok {
		return x.CommandStart
	}
	return nil
}

func (m *Envelope) GetCommandActionComplete() *CommandActionComplete {
	if x, ok := m.GetMessage().(*Envelope_CommandActionComplete); ok {
		return x.CommandActionComplete
	}
	return nil
}

func (m *Envelope) GetCommandRunBeforeTestRunHooks() *CommandRunBeforeTestRunHooks {
	if x, ok := m.GetMessage().(*Envelope_CommandRunBeforeTestRunHooks); ok {
		return x.CommandRunBeforeTestRunHooks
	}
	return nil
}

func (m *Envelope) GetCommandInitializeTestCase() *CommandInitializeTestCase {
	if x, ok := m.GetMessage().(*Envelope_CommandInitializeTestCase); ok {
		return x.CommandInitializeTestCase
	}
	return nil
}

func (m *Envelope) GetCommandRunBeforeTestCaseHook() *CommandRunBeforeTestCaseHook {
	if x, ok := m.GetMessage().(*Envelope_CommandRunBeforeTestCaseHook); ok {
		return x.CommandRunBeforeTestCaseHook
	}
	return nil
}

func (m *Envelope) GetCommandRunTestStep() *CommandRunTestStep {
	if x, ok := m.GetMessage().(*Envelope_CommandRunTestStep); ok {
		return x.CommandRunTestStep
	}
	return nil
}

func (m *Envelope) GetCommandRunAfterTestCaseHook() *CommandRunAfterTestCaseHook {
	if x, ok := m.GetMessage().(*Envelope_CommandRunAfterTestCaseHook); ok {
		return x.CommandRunAfterTestCaseHook
	}
	return nil
}

func (m *Envelope) GetCommandRunAfterTestRunHooks() *CommandRunAfterTestRunHooks {
	if x, ok := m.GetMessage().(*Envelope_CommandRunAfterTestRunHooks); ok {
		return x.CommandRunAfterTestRunHooks
	}
	return nil
}

func (m *Envelope) GetCommandGenerateSnippet() *CommandGenerateSnippet {
	if x, ok := m.GetMessage().(*Envelope_CommandGenerateSnippet); ok {
		return x.CommandGenerateSnippet
	}
	return nil
}

func (m *Envelope) GetCommandError() string {
	if x, ok := m.GetMessage().(*Envelope_CommandError); ok {
		return x.CommandError
	}
	return ""
}

func (m *Envelope) GetTestStepMatched() *TestStepMatched {
	if x, ok := m.GetMessage().(*Envelope_TestStepMatched); ok {
		return x.TestStepMatched
	}
	return nil
}

func (m *Envelope) GetTestCase() *TestCase {
	if x, ok := m.GetMessage().(*Envelope_TestCase); ok {
		return x.TestCase
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Envelope) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Envelope_Source)(nil),
		(*Envelope_GherkinDocument)(nil),
		(*Envelope_Pickle)(nil),
		(*Envelope_Attachment)(nil),
		(*Envelope_TestCaseStarted)(nil),
		(*Envelope_TestStepStarted)(nil),
		(*Envelope_TestStepFinished)(nil),
		(*Envelope_TestCaseFinished)(nil),
		(*Envelope_TestHookStarted)(nil),
		(*Envelope_TestHookFinished)(nil),
		(*Envelope_PickleAccepted)(nil),
		(*Envelope_PickleRejected)(nil),
		(*Envelope_TestCasePrepared)(nil),
		(*Envelope_TestRunStarted)(nil),
		(*Envelope_TestRunFinished)(nil),
		(*Envelope_CommandStart)(nil),
		(*Envelope_CommandActionComplete)(nil),
		(*Envelope_CommandRunBeforeTestRunHooks)(nil),
		(*Envelope_CommandInitializeTestCase)(nil),
		(*Envelope_CommandRunBeforeTestCaseHook)(nil),
		(*Envelope_CommandRunTestStep)(nil),
		(*Envelope_CommandRunAfterTestCaseHook)(nil),
		(*Envelope_CommandRunAfterTestRunHooks)(nil),
		(*Envelope_CommandGenerateSnippet)(nil),
		(*Envelope_CommandError)(nil),
		(*Envelope_TestStepMatched)(nil),
		(*Envelope_TestCase)(nil),
	}
}

//*
// Points to a line and a column in a text file
type Location struct {
	Line   uint32 `protobuf:"varint,1,opt,name=line,proto3" json:"line,omitempty"`
	Column uint32 `protobuf:"varint,2,opt,name=column,proto3" json:"column,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{3}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetLine() uint32 {
	if m != nil {
		return m.Line
	}
	return 0
}

func (m *Location) GetColumn() uint32 {
	if m != nil {
		return m.Column
	}
	return 0
}

//*
// Points to a [Source](#io.cucumber.messages.Source) identified by `uri` and a
// [Location](#io.cucumber.messages.Location) within that file.
type SourceReference struct {
	Uri      string    `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Location *Location `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *SourceReference) Reset()         { *m = SourceReference{} }
func (m *SourceReference) String() string { return proto.CompactTextString(m) }
func (*SourceReference) ProtoMessage()    {}
func (*SourceReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{4}
}
func (m *SourceReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceReference.Merge(m, src)
}
func (m *SourceReference) XXX_Size() int {
	return m.Size()
}
func (m *SourceReference) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceReference.DiscardUnknown(m)
}

var xxx_messageInfo_SourceReference proto.InternalMessageInfo

func (m *SourceReference) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *SourceReference) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

//*
// Meta information about encoded contents
type Media struct {
	// The encoding of the data
	Encoding Media_Encoding `protobuf:"varint,1,opt,name=encoding,proto3,enum=io.cucumber.messages.Media_Encoding" json:"encoding,omitempty"`
	//*
	// The content type of the data. This can be any valid
	// [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
	// as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
	// and `text/x.cucumber.stacktrace+plain`
	ContentType string `protobuf:"bytes,2,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
}

func (m *Media) Reset()         { *m = Media{} }
func (m *Media) String() string { return proto.CompactTextString(m) }
func (*Media) ProtoMessage()    {}
func (*Media) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{5}
}
func (m *Media) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Media) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Media.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Media) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Media.Merge(m, src)
}
func (m *Media) XXX_Size() int {
	return m.Size()
}
func (m *Media) XXX_DiscardUnknown() {
	xxx_messageInfo_Media.DiscardUnknown(m)
}

var xxx_messageInfo_Media proto.InternalMessageInfo

func (m *Media) GetEncoding() Media_Encoding {
	if m != nil {
		return m.Encoding
	}
	return Media_BASE64
}

func (m *Media) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

//*
// A source file, typically a Gherkin document
type Source struct {
	//*
	// The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
	// of the source, typically a file path relative to the root directory
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// The contents of the file
	Data string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	// The media type of the file
	Media *Media `protobuf:"bytes,3,opt,name=media,proto3" json:"media,omitempty"`
}

func (m *Source) Reset()         { *m = Source{} }
func (m *Source) String() string { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()    {}
func (*Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{6}
}
func (m *Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Source.Merge(m, src)
}
func (m *Source) XXX_Size() int {
	return m.Size()
}
func (m *Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Source proto.InternalMessageInfo

func (m *Source) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Source) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Source) GetMedia() *Media {
	if m != nil {
		return m.Media
	}
	return nil
}

//*
// The [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) of a Gherkin document.
// Cucumber implementations should *not* depend on `GherkinDocument` or any of its
// children for execution - use [Pickle](#io.cucumber.messages.Pickle) instead.
//
// The only consumers of `GherkinDocument` should only be formatters that produce
// "rich" output, resembling the original Gherkin document.
type GherkinDocument struct {
	//*
	// The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
	// of the source, typically a file path relative to the root directory
	Uri     string                   `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Feature *GherkinDocument_Feature `protobuf:"bytes,2,opt,name=feature,proto3" json:"feature,omitempty"`
	// All the comments in the Gherkin document
	Comments []*GherkinDocument_Comment `protobuf:"bytes,3,rep,name=comments,proto3" json:"comments,omitempty"`
}

func (m *GherkinDocument) Reset()         { *m = GherkinDocument{} }
func (m *GherkinDocument) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument) ProtoMessage()    {}
func (*GherkinDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7}
}
func (m *GherkinDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument.Merge(m, src)
}
func (m *GherkinDocument) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument proto.InternalMessageInfo

func (m *GherkinDocument) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *GherkinDocument) GetFeature() *GherkinDocument_Feature {
	if m != nil {
		return m.Feature
	}
	return nil
}

func (m *GherkinDocument) GetComments() []*GherkinDocument_Comment {
	if m != nil {
		return m.Comments
	}
	return nil
}

//*
// A comment in a Gherkin document
type GherkinDocument_Comment struct {
	// The location of the comment
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// The text of the comment
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *GherkinDocument_Comment) Reset()         { *m = GherkinDocument_Comment{} }
func (m *GherkinDocument_Comment) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Comment) ProtoMessage()    {}
func (*GherkinDocument_Comment) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 0}
}
func (m *GherkinDocument_Comment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Comment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Comment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Comment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Comment.Merge(m, src)
}
func (m *GherkinDocument_Comment) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Comment) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Comment.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Comment proto.InternalMessageInfo

func (m *GherkinDocument_Comment) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Comment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

//*
// The top level node in the AST
type GherkinDocument_Feature struct {
	// The location of the `Feature` keyword
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// All the tags placed above the `Feature` keyword
	Tags []*GherkinDocument_Feature_Tag `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	// The [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code of the Gherkin document
	Language string `protobuf:"bytes,3,opt,name=language,proto3" json:"language,omitempty"`
	// The text of the `Feature` keyword (in the language specified by `language`)
	Keyword string `protobuf:"bytes,4,opt,name=keyword,proto3" json:"keyword,omitempty"`
	// The name of the feature (the text following the `keyword`)
	Name string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	// The line(s) underneath the line with the `keyword` that are used as description
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	// Zero or more children
	Children []*GherkinDocument_Feature_FeatureChild `protobuf:"bytes,7,rep,name=children,proto3" json:"children,omitempty"`
}

func (m *GherkinDocument_Feature) Reset()         { *m = GherkinDocument_Feature{} }
func (m *GherkinDocument_Feature) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature) ProtoMessage()    {}
func (*GherkinDocument_Feature) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1}
}
func (m *GherkinDocument_Feature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature.Merge(m, src)
}
func (m *GherkinDocument_Feature) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature proto.InternalMessageInfo

func (m *GherkinDocument_Feature) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature) GetTags() []*GherkinDocument_Feature_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GherkinDocument_Feature) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *GherkinDocument_Feature) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature) GetChildren() []*GherkinDocument_Feature_FeatureChild {
	if m != nil {
		return m.Children
	}
	return nil
}

//*
// A tag
type GherkinDocument_Feature_Tag struct {
	// Location of the tag
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// The name of the tag (including the leading `@`)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GherkinDocument_Feature_Tag) Reset()         { *m = GherkinDocument_Feature_Tag{} }
func (m *GherkinDocument_Feature_Tag) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Tag) ProtoMessage()    {}
func (*GherkinDocument_Feature_Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 0}
}
func (m *GherkinDocument_Feature_Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Tag.Merge(m, src)
}
func (m *GherkinDocument_Feature_Tag) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Tag proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Tag) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Tag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

//*
// A child node of a `Feature` node
type GherkinDocument_Feature_FeatureChild struct {
	// Types that are valid to be assigned to Value:
	//	*GherkinDocument_Feature_FeatureChild_Rule_
	//	*GherkinDocument_Feature_FeatureChild_Background
	//	*GherkinDocument_Feature_FeatureChild_Scenario
	Value isGherkinDocument_Feature_FeatureChild_Value `protobuf_oneof:"value"`
}

func (m *GherkinDocument_Feature_FeatureChild) Reset()         { *m = GherkinDocument_Feature_FeatureChild{} }
func (m *GherkinDocument_Feature_FeatureChild) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_FeatureChild) ProtoMessage()    {}
func (*GherkinDocument_Feature_FeatureChild) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 1}
}
func (m *GherkinDocument_Feature_FeatureChild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_FeatureChild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_FeatureChild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_FeatureChild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild.Merge(m, src)
}
func (m *GherkinDocument_Feature_FeatureChild) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_FeatureChild) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_FeatureChild proto.InternalMessageInfo

type isGherkinDocument_Feature_FeatureChild_Value interface {
	isGherkinDocument_Feature_FeatureChild_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GherkinDocument_Feature_FeatureChild_Rule_ struct {
	Rule *GherkinDocument_Feature_FeatureChild_Rule `protobuf:"bytes,1,opt,name=rule,proto3,oneof"`
}
type GherkinDocument_Feature_FeatureChild_Background struct {
	Background *GherkinDocument_Feature_Background `protobuf:"bytes,2,opt,name=background,proto3,oneof"`
}
type GherkinDocument_Feature_FeatureChild_Scenario struct {
	Scenario *GherkinDocument_Feature_Scenario `protobuf:"bytes,3,opt,name=scenario,proto3,oneof"`
}

func (*GherkinDocument_Feature_FeatureChild_Rule_) isGherkinDocument_Feature_FeatureChild_Value() {}
func (*GherkinDocument_Feature_FeatureChild_Background) isGherkinDocument_Feature_FeatureChild_Value() {
}
func (*GherkinDocument_Feature_FeatureChild_Scenario) isGherkinDocument_Feature_FeatureChild_Value() {}

func (m *GherkinDocument_Feature_FeatureChild) GetValue() isGherkinDocument_Feature_FeatureChild_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild) GetRule() *GherkinDocument_Feature_FeatureChild_Rule {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_Rule_); ok {
		return x.Rule
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild) GetBackground() *GherkinDocument_Feature_Background {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_Background); ok {
		return x.Background
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild) GetScenario() *GherkinDocument_Feature_Scenario {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_Scenario); ok {
		return x.Scenario
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GherkinDocument_Feature_FeatureChild) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GherkinDocument_Feature_FeatureChild_Rule_)(nil),
		(*GherkinDocument_Feature_FeatureChild_Background)(nil),
		(*GherkinDocument_Feature_FeatureChild_Scenario)(nil),
	}
}

//*
// A `Rule` node
type GherkinDocument_Feature_FeatureChild_Rule struct {
	// The location of the `Rule` keyword
	Location    *Location                                         `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Keyword     string                                            `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                                            `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description string                                            `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Children    []*GherkinDocument_Feature_FeatureChild_RuleChild `protobuf:"bytes,5,rep,name=children,proto3" json:"children,omitempty"`
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) Reset() {
	*m = GherkinDocument_Feature_FeatureChild_Rule{}
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_FeatureChild_Rule) ProtoMessage()    {}
func (*GherkinDocument_Feature_FeatureChild_Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 1, 0}
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_FeatureChild_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild_Rule.Merge(m, src)
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_FeatureChild_Rule proto.InternalMessageInfo

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) GetChildren() []*GherkinDocument_Feature_FeatureChild_RuleChild {
	if m != nil {
		return m.Children
	}
	return nil
}

type GherkinDocument_Feature_FeatureChild_RuleChild struct {
	// Types that are valid to be assigned to Value:
	//	*GherkinDocument_Feature_FeatureChild_RuleChild_Background
	//	*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario
	Value isGherkinDocument_Feature_FeatureChild_RuleChild_Value `protobuf_oneof:"value"`
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Reset() {
	*m = GherkinDocument_Feature_FeatureChild_RuleChild{}
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) String() string {
	return proto.CompactTextString(m)
}
func (*GherkinDocument_Feature_FeatureChild_RuleChild) ProtoMessage() {}
func (*GherkinDocument_Feature_FeatureChild_RuleChild) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 1, 1}
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_FeatureChild_RuleChild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild_RuleChild.Merge(m, src)
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_FeatureChild_RuleChild.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_FeatureChild_RuleChild proto.InternalMessageInfo

type isGherkinDocument_Feature_FeatureChild_RuleChild_Value interface {
	isGherkinDocument_Feature_FeatureChild_RuleChild_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GherkinDocument_Feature_FeatureChild_RuleChild_Background struct {
	Background *GherkinDocument_Feature_Background `protobuf:"bytes,1,opt,name=background,proto3,oneof"`
}
type GherkinDocument_Feature_FeatureChild_RuleChild_Scenario struct {
	Scenario *GherkinDocument_Feature_Scenario `protobuf:"bytes,2,opt,name=scenario,proto3,oneof"`
}

func (*GherkinDocument_Feature_FeatureChild_RuleChild_Background) isGherkinDocument_Feature_FeatureChild_RuleChild_Value() {
}
func (*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) isGherkinDocument_Feature_FeatureChild_RuleChild_Value() {
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) GetValue() isGherkinDocument_Feature_FeatureChild_RuleChild_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) GetBackground() *GherkinDocument_Feature_Background {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_RuleChild_Background); ok {
		return x.Background
	}
	return nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) GetScenario() *GherkinDocument_Feature_Scenario {
	if x, ok := m.GetValue().(*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario); ok {
		return x.Scenario
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GherkinDocument_Feature_FeatureChild_RuleChild) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GherkinDocument_Feature_FeatureChild_RuleChild_Background)(nil),
		(*GherkinDocument_Feature_FeatureChild_RuleChild_Scenario)(nil),
	}
}

type GherkinDocument_Feature_Background struct {
	// The location of the `Background` keyword
	Location    *Location                       `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Keyword     string                          `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                          `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description string                          `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Steps       []*GherkinDocument_Feature_Step `protobuf:"bytes,5,rep,name=steps,proto3" json:"steps,omitempty"`
}

func (m *GherkinDocument_Feature_Background) Reset()         { *m = GherkinDocument_Feature_Background{} }
func (m *GherkinDocument_Feature_Background) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Background) ProtoMessage()    {}
func (*GherkinDocument_Feature_Background) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 2}
}
func (m *GherkinDocument_Feature_Background) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Background) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Background.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Background) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Background.Merge(m, src)
}
func (m *GherkinDocument_Feature_Background) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Background) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Background.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Background proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Background) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Background) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Background) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_Background) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_Background) GetSteps() []*GherkinDocument_Feature_Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

type GherkinDocument_Feature_Scenario struct {
	// The location of the `Scenario` keyword
	Location    *Location                                    `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Tags        []*GherkinDocument_Feature_Tag               `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	Keyword     string                                       `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                                       `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Description string                                       `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Steps       []*GherkinDocument_Feature_Step              `protobuf:"bytes,6,rep,name=steps,proto3" json:"steps,omitempty"`
	Examples    []*GherkinDocument_Feature_Scenario_Examples `protobuf:"bytes,7,rep,name=examples,proto3" json:"examples,omitempty"`
	Id          string                                       `protobuf:"bytes,8,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GherkinDocument_Feature_Scenario) Reset()         { *m = GherkinDocument_Feature_Scenario{} }
func (m *GherkinDocument_Feature_Scenario) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Scenario) ProtoMessage()    {}
func (*GherkinDocument_Feature_Scenario) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 3}
}
func (m *GherkinDocument_Feature_Scenario) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Scenario) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Scenario.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Scenario) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Scenario.Merge(m, src)
}
func (m *GherkinDocument_Feature_Scenario) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Scenario) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Scenario.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Scenario proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Scenario) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetTags() []*GherkinDocument_Feature_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario) GetSteps() []*GherkinDocument_Feature_Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetExamples() []*GherkinDocument_Feature_Scenario_Examples {
	if m != nil {
		return m.Examples
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type GherkinDocument_Feature_Scenario_Examples struct {
	// The location of the `Examples` keyword
	Location    *Location                           `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Tags        []*GherkinDocument_Feature_Tag      `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
	Keyword     string                              `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string                              `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Description string                              `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	TableHeader *GherkinDocument_Feature_TableRow   `protobuf:"bytes,6,opt,name=table_header,json=tableHeader,proto3" json:"table_header,omitempty"`
	TableBody   []*GherkinDocument_Feature_TableRow `protobuf:"bytes,7,rep,name=table_body,json=tableBody,proto3" json:"table_body,omitempty"`
}

func (m *GherkinDocument_Feature_Scenario_Examples) Reset() {
	*m = GherkinDocument_Feature_Scenario_Examples{}
}
func (m *GherkinDocument_Feature_Scenario_Examples) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Scenario_Examples) ProtoMessage()    {}
func (*GherkinDocument_Feature_Scenario_Examples) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 3, 0}
}
func (m *GherkinDocument_Feature_Scenario_Examples) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Scenario_Examples) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Scenario_Examples.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Scenario_Examples) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Scenario_Examples.Merge(m, src)
}
func (m *GherkinDocument_Feature_Scenario_Examples) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Scenario_Examples) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Scenario_Examples.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Scenario_Examples proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Scenario_Examples) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetTags() []*GherkinDocument_Feature_Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetTableHeader() *GherkinDocument_Feature_TableRow {
	if m != nil {
		return m.TableHeader
	}
	return nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) GetTableBody() []*GherkinDocument_Feature_TableRow {
	if m != nil {
		return m.TableBody
	}
	return nil
}

// A row in a table
type GherkinDocument_Feature_TableRow struct {
	// The location of the first cell in the row
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// Cells in the row
	Cells []*GherkinDocument_Feature_TableRow_TableCell `protobuf:"bytes,2,rep,name=cells,proto3" json:"cells,omitempty"`
	Id    string                                        `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GherkinDocument_Feature_TableRow) Reset()         { *m = GherkinDocument_Feature_TableRow{} }
func (m *GherkinDocument_Feature_TableRow) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_TableRow) ProtoMessage()    {}
func (*GherkinDocument_Feature_TableRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 4}
}
func (m *GherkinDocument_Feature_TableRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_TableRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_TableRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_TableRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_TableRow.Merge(m, src)
}
func (m *GherkinDocument_Feature_TableRow) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_TableRow) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_TableRow.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_TableRow proto.InternalMessageInfo

func (m *GherkinDocument_Feature_TableRow) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_TableRow) GetCells() []*GherkinDocument_Feature_TableRow_TableCell {
	if m != nil {
		return m.Cells
	}
	return nil
}

func (m *GherkinDocument_Feature_TableRow) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// A cell in a `TableRow`
type GherkinDocument_Feature_TableRow_TableCell struct {
	// The location of the cell
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	// The value of the cell
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *GherkinDocument_Feature_TableRow_TableCell) Reset() {
	*m = GherkinDocument_Feature_TableRow_TableCell{}
}
func (m *GherkinDocument_Feature_TableRow_TableCell) String() string {
	return proto.CompactTextString(m)
}
func (*GherkinDocument_Feature_TableRow_TableCell) ProtoMessage() {}
func (*GherkinDocument_Feature_TableRow_TableCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 4, 0}
}
func (m *GherkinDocument_Feature_TableRow_TableCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_TableRow_TableCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_TableRow_TableCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_TableRow_TableCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_TableRow_TableCell.Merge(m, src)
}
func (m *GherkinDocument_Feature_TableRow_TableCell) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_TableRow_TableCell) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_TableRow_TableCell.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_TableRow_TableCell proto.InternalMessageInfo

func (m *GherkinDocument_Feature_TableRow_TableCell) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_TableRow_TableCell) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// A step
type GherkinDocument_Feature_Step struct {
	// The location of the steps' `keyword`
	Location *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Keyword  string    `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Text     string    `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	// Types that are valid to be assigned to Argument:
	//	*GherkinDocument_Feature_Step_DocString_
	//	*GherkinDocument_Feature_Step_DataTable_
	Argument isGherkinDocument_Feature_Step_Argument `protobuf_oneof:"argument"`
	// Unique ID to be able to reference the Step from PickleStep
	Id string `protobuf:"bytes,7,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GherkinDocument_Feature_Step) Reset()         { *m = GherkinDocument_Feature_Step{} }
func (m *GherkinDocument_Feature_Step) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Step) ProtoMessage()    {}
func (*GherkinDocument_Feature_Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 5}
}
func (m *GherkinDocument_Feature_Step) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Step.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Step.Merge(m, src)
}
func (m *GherkinDocument_Feature_Step) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Step) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Step.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Step proto.InternalMessageInfo

type isGherkinDocument_Feature_Step_Argument interface {
	isGherkinDocument_Feature_Step_Argument()
	MarshalTo([]byte) (int, error)
	Size() int
}

type GherkinDocument_Feature_Step_DocString_ struct {
	DocString *GherkinDocument_Feature_Step_DocString `protobuf:"bytes,5,opt,name=doc_string,json=docString,proto3,oneof"`
}
type GherkinDocument_Feature_Step_DataTable_ struct {
	DataTable *GherkinDocument_Feature_Step_DataTable `protobuf:"bytes,6,opt,name=data_table,json=dataTable,proto3,oneof"`
}

func (*GherkinDocument_Feature_Step_DocString_) isGherkinDocument_Feature_Step_Argument() {}
func (*GherkinDocument_Feature_Step_DataTable_) isGherkinDocument_Feature_Step_Argument() {}

func (m *GherkinDocument_Feature_Step) GetArgument() isGherkinDocument_Feature_Step_Argument {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *GherkinDocument_Feature_Step) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *GherkinDocument_Feature_Step) GetDocString() *GherkinDocument_Feature_Step_DocString {
	if x, ok := m.GetArgument().(*GherkinDocument_Feature_Step_DocString_); ok {
		return x.DocString
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetDataTable() *GherkinDocument_Feature_Step_DataTable {
	if x, ok := m.GetArgument().(*GherkinDocument_Feature_Step_DataTable_); ok {
		return x.DataTable
	}
	return nil
}

func (m *GherkinDocument_Feature_Step) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*GherkinDocument_Feature_Step) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*GherkinDocument_Feature_Step_DocString_)(nil),
		(*GherkinDocument_Feature_Step_DataTable_)(nil),
	}
}

type GherkinDocument_Feature_Step_DataTable struct {
	Location *Location                           `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	Rows     []*GherkinDocument_Feature_TableRow `protobuf:"bytes,2,rep,name=rows,proto3" json:"rows,omitempty"`
}

func (m *GherkinDocument_Feature_Step_DataTable) Reset() {
	*m = GherkinDocument_Feature_Step_DataTable{}
}
func (m *GherkinDocument_Feature_Step_DataTable) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Step_DataTable) ProtoMessage()    {}
func (*GherkinDocument_Feature_Step_DataTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 5, 0}
}
func (m *GherkinDocument_Feature_Step_DataTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Step_DataTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Step_DataTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Step_DataTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Step_DataTable.Merge(m, src)
}
func (m *GherkinDocument_Feature_Step_DataTable) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Step_DataTable) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Step_DataTable.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Step_DataTable proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Step_DataTable) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Step_DataTable) GetRows() []*GherkinDocument_Feature_TableRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

type GherkinDocument_Feature_Step_DocString struct {
	Location    *Location `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
	ContentType string    `protobuf:"bytes,2,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	Content     string    `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	Delimiter   string    `protobuf:"bytes,4,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
}

func (m *GherkinDocument_Feature_Step_DocString) Reset() {
	*m = GherkinDocument_Feature_Step_DocString{}
}
func (m *GherkinDocument_Feature_Step_DocString) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument_Feature_Step_DocString) ProtoMessage()    {}
func (*GherkinDocument_Feature_Step_DocString) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{7, 1, 5, 1}
}
func (m *GherkinDocument_Feature_Step_DocString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument_Feature_Step_DocString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument_Feature_Step_DocString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GherkinDocument_Feature_Step_DocString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument_Feature_Step_DocString.Merge(m, src)
}
func (m *GherkinDocument_Feature_Step_DocString) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument_Feature_Step_DocString) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument_Feature_Step_DocString.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument_Feature_Step_DocString proto.InternalMessageInfo

func (m *GherkinDocument_Feature_Step_DocString) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GherkinDocument_Feature_Step_DocString) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *GherkinDocument_Feature_Step_DocString) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *GherkinDocument_Feature_Step_DocString) GetDelimiter() string {
	if m != nil {
		return m.Delimiter
	}
	return ""
}

//*
// An attachment represents any kind of data associated with a line in a
// [Source](#io.cucumber.messages.Source) file. It can be used for:
//
// * Syntax errors during parse time
// * Screenshots captured and attached during execution
// * Logs captured and attached during execution
// * Runtime errors raised/thrown during execution (TODO: Conflicts with `TestResult#message`?)
type Attachment struct {
	Source *SourceReference `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Data   string           `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Media  *Media           `protobuf:"bytes,3,opt,name=media,proto3" json:"media,omitempty"`
}

func (m *Attachment) Reset()         { *m = Attachment{} }
func (m *Attachment) String() string { return proto.CompactTextString(m) }
func (*Attachment) ProtoMessage()    {}
func (*Attachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{8}
}
func (m *Attachment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Attachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Attachment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Attachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attachment.Merge(m, src)
}
func (m *Attachment) XXX_Size() int {
	return m.Size()
}
func (m *Attachment) XXX_DiscardUnknown() {
	xxx_messageInfo_Attachment.DiscardUnknown(m)
}

var xxx_messageInfo_Attachment proto.InternalMessageInfo

func (m *Attachment) GetSource() *SourceReference {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Attachment) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Attachment) GetMedia() *Media {
	if m != nil {
		return m.Media
	}
	return nil
}

//*
// A `Pickle` represents a test case Cucumber can *execute*. It is typically derived
// from another format, such as [GherkinDocument](#io.cucumber.messages.GherkinDocument).
// In the future a `Pickle` may be derived from other formats such as Markdown or
// Excel files.
//
// By making `Pickle` the main data structure Cucumber uses for execution, the
// implementation of Cucumber itself becomes simpler, as it doesn't have to deal
// with the complex structure of a [GherkinDocument](#io.cucumber.messages.GherkinDocument).
type Pickle struct {
	//*
	// A unique id for the pickle. This is a [SHA1](https://en.wikipedia.org/wiki/SHA-1) hash
	// from the source data and the `locations` of the pickle.
	// This ID will change if source the file is modified.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// The uri of the source file
	Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	// The name of the pickle
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The language of the pickle
	Language string `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	// One or more steps
	Steps []*Pickle_PickleStep `protobuf:"bytes,5,rep,name=steps,proto3" json:"steps,omitempty"`
	//*
	// One or more tags. If this pickle is constructed from a Gherkin document,
	// It includes inherited tags from the `Feature` as well.
	Tags []*Pickle_PickleTag `protobuf:"bytes,6,rep,name=tags,proto3" json:"tags,omitempty"`
	//*
	// Points to the source locations of the pickle. The last one represents the unique
	// id of the pickle. A pickle constructed from `Examples` will have the first
	// sourceId originating from the `Scenario`, and the second from the table row.
	SourceIds []string `protobuf:"bytes,8,rep,name=sourceIds,proto3" json:"sourceIds,omitempty"`
}

func (m *Pickle) Reset()         { *m = Pickle{} }
func (m *Pickle) String() string { return proto.CompactTextString(m) }
func (*Pickle) ProtoMessage()    {}
func (*Pickle) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{9}
}
func (m *Pickle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pickle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pickle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pickle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pickle.Merge(m, src)
}
func (m *Pickle) XXX_Size() int {
	return m.Size()
}
func (m *Pickle) XXX_DiscardUnknown() {
	xxx_messageInfo_Pickle.DiscardUnknown(m)
}

var xxx_messageInfo_Pickle proto.InternalMessageInfo

func (m *Pickle) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Pickle) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Pickle) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pickle) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Pickle) GetSteps() []*Pickle_PickleStep {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Pickle) GetTags() []*Pickle_PickleTag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Pickle) GetSourceIds() []string {
	if m != nil {
		return m.SourceIds
	}
	return nil
}

//*
// A tag
type Pickle_PickleTag struct {
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Pickle_PickleTag) Reset()         { *m = Pickle_PickleTag{} }
func (m *Pickle_PickleTag) String() string { return proto.CompactTextString(m) }
func (*Pickle_PickleTag) ProtoMessage()    {}
func (*Pickle_PickleTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{9, 0}
}
func (m *Pickle_PickleTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pickle_PickleTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pickle_PickleTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pickle_PickleTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pickle_PickleTag.Merge(m, src)
}
func (m *Pickle_PickleTag) XXX_Size() int {
	return m.Size()
}
func (m *Pickle_PickleTag) XXX_DiscardUnknown() {
	xxx_messageInfo_Pickle_PickleTag.DiscardUnknown(m)
}

var xxx_messageInfo_Pickle_PickleTag proto.InternalMessageInfo

func (m *Pickle_PickleTag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

//*
// An executable step
type Pickle_PickleStep struct {
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// An optional argument
	Argument *PickleStepArgument `protobuf:"bytes,5,opt,name=argument,proto3" json:"argument,omitempty"`
	// A unique ID for the PickleStep
	Id string `protobuf:"bytes,6,opt,name=id,proto3" json:"id,omitempty"`
	// References the scenario step where the PickleStep originates from
	// DEPRECATED - use sourceIds
	StepId string `protobuf:"bytes,7,opt,name=stepId,proto3" json:"stepId,omitempty"`
	// References the IDs of the source of the step. For Gherkin, this can be
	// the ID of a Step, and possibly also the ID of a TableRow
	SourceIds []string `protobuf:"bytes,8,rep,name=sourceIds,proto3" json:"sourceIds,omitempty"`
}

func (m *Pickle_PickleStep) Reset()         { *m = Pickle_PickleStep{} }
func (m *Pickle_PickleStep) String() string { return proto.CompactTextString(m) }
func (*Pickle_PickleStep) ProtoMessage()    {}
func (*Pickle_PickleStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{9, 1}
}
func (m *Pickle_PickleStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pickle_PickleStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pickle_PickleStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pickle_PickleStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pickle_PickleStep.Merge(m, src)
}
func (m *Pickle_PickleStep) XXX_Size() int {
	return m.Size()
}
func (m *Pickle_PickleStep) XXX_DiscardUnknown() {
	xxx_messageInfo_Pickle_PickleStep.DiscardUnknown(m)
}

var xxx_messageInfo_Pickle_PickleStep proto.InternalMessageInfo

func (m *Pickle_PickleStep) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Pickle_PickleStep) GetArgument() *PickleStepArgument {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *Pickle_PickleStep) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Pickle_PickleStep) GetStepId() string {
	if m != nil {
		return m.StepId
	}
	return ""
}

func (m *Pickle_PickleStep) GetSourceIds() []string {
	if m != nil {
		return m.SourceIds
	}
	return nil
}

//*
// A wrapper for either a doc string or a table.
type PickleStepArgument struct {
	// Types that are valid to be assigned to Message:
	//	*PickleStepArgument_DocString
	//	*PickleStepArgument_DataTable
	Message isPickleStepArgument_Message `protobuf_oneof:"message"`
}

func (m *PickleStepArgument) Reset()         { *m = PickleStepArgument{} }
func (m *PickleStepArgument) String() string { return proto.CompactTextString(m) }
func (*PickleStepArgument) ProtoMessage()    {}
func (*PickleStepArgument) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{10}
}
func (m *PickleStepArgument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStepArgument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStepArgument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleStepArgument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStepArgument.Merge(m, src)
}
func (m *PickleStepArgument) XXX_Size() int {
	return m.Size()
}
func (m *PickleStepArgument) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStepArgument.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStepArgument proto.InternalMessageInfo

type isPickleStepArgument_Message interface {
	isPickleStepArgument_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PickleStepArgument_DocString struct {
	DocString *PickleStepArgument_PickleDocString `protobuf:"bytes,1,opt,name=doc_string,json=docString,proto3,oneof"`
}
type PickleStepArgument_DataTable struct {
	DataTable *PickleStepArgument_PickleTable `protobuf:"bytes,2,opt,name=data_table,json=dataTable,proto3,oneof"`
}

func (*PickleStepArgument_DocString) isPickleStepArgument_Message() {}
func (*PickleStepArgument_DataTable) isPickleStepArgument_Message() {}

func (m *PickleStepArgument) GetMessage() isPickleStepArgument_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *PickleStepArgument) GetDocString() *PickleStepArgument_PickleDocString {
	if x, ok := m.GetMessage().(*PickleStepArgument_DocString); ok {
		return x.DocString
	}
	return nil
}

func (m *PickleStepArgument) GetDataTable() *PickleStepArgument_PickleTable {
	if x, ok := m.GetMessage().(*PickleStepArgument_DataTable); ok {
		return x.DataTable
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PickleStepArgument) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PickleStepArgument_DocString)(nil),
		(*PickleStepArgument_DataTable)(nil),
	}
}

type PickleStepArgument_PickleDocString struct {
	ContentType string `protobuf:"bytes,2,opt,name=contentType,proto3" json:"contentType,omitempty"`
	Content     string `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *PickleStepArgument_PickleDocString) Reset()         { *m = PickleStepArgument_PickleDocString{} }
func (m *PickleStepArgument_PickleDocString) String() string { return proto.CompactTextString(m) }
func (*PickleStepArgument_PickleDocString) ProtoMessage()    {}
func (*PickleStepArgument_PickleDocString) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{10, 0}
}
func (m *PickleStepArgument_PickleDocString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStepArgument_PickleDocString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStepArgument_PickleDocString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleStepArgument_PickleDocString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStepArgument_PickleDocString.Merge(m, src)
}
func (m *PickleStepArgument_PickleDocString) XXX_Size() int {
	return m.Size()
}
func (m *PickleStepArgument_PickleDocString) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStepArgument_PickleDocString.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStepArgument_PickleDocString proto.InternalMessageInfo

func (m *PickleStepArgument_PickleDocString) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *PickleStepArgument_PickleDocString) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type PickleStepArgument_PickleTable struct {
	Rows []*PickleStepArgument_PickleTable_PickleTableRow `protobuf:"bytes,1,rep,name=rows,proto3" json:"rows,omitempty"`
}

func (m *PickleStepArgument_PickleTable) Reset()         { *m = PickleStepArgument_PickleTable{} }
func (m *PickleStepArgument_PickleTable) String() string { return proto.CompactTextString(m) }
func (*PickleStepArgument_PickleTable) ProtoMessage()    {}
func (*PickleStepArgument_PickleTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{10, 1}
}
func (m *PickleStepArgument_PickleTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStepArgument_PickleTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStepArgument_PickleTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleStepArgument_PickleTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStepArgument_PickleTable.Merge(m, src)
}
func (m *PickleStepArgument_PickleTable) XXX_Size() int {
	return m.Size()
}
func (m *PickleStepArgument_PickleTable) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStepArgument_PickleTable.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStepArgument_PickleTable proto.InternalMessageInfo

func (m *PickleStepArgument_PickleTable) GetRows() []*PickleStepArgument_PickleTable_PickleTableRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

type PickleStepArgument_PickleTable_PickleTableRow struct {
	Cells []*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell `protobuf:"bytes,1,rep,name=cells,proto3" json:"cells,omitempty"`
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) Reset() {
	*m = PickleStepArgument_PickleTable_PickleTableRow{}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) String() string {
	return proto.CompactTextString(m)
}
func (*PickleStepArgument_PickleTable_PickleTableRow) ProtoMessage() {}
func (*PickleStepArgument_PickleTable_PickleTableRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{10, 1, 0}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow.Merge(m, src)
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) XXX_Size() int {
	return m.Size()
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow proto.InternalMessageInfo

func (m *PickleStepArgument_PickleTable_PickleTableRow) GetCells() []*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell {
	if m != nil {
		return m.Cells
	}
	return nil
}

type PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell struct {
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Reset() {
	*m = PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell{}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) String() string {
	return proto.CompactTextString(m)
}
func (*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) ProtoMessage() {}
func (*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{10, 1, 0, 0}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell.Merge(m, src)
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) XXX_Size() int {
	return m.Size()
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell proto.InternalMessageInfo

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type TestCase struct {
	Id        string               `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	PickleId  string               `protobuf:"bytes,2,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	TestSteps []*TestCase_TestStep `protobuf:"bytes,3,rep,name=testSteps,proto3" json:"testSteps,omitempty"`
}

func (m *TestCase) Reset()         { *m = TestCase{} }
func (m *TestCase) String() string { return proto.CompactTextString(m) }
func (*TestCase) ProtoMessage()    {}
func (*TestCase) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{11}
}
func (m *TestCase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCase.Merge(m, src)
}
func (m *TestCase) XXX_Size() int {
	return m.Size()
}
func (m *TestCase) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCase.DiscardUnknown(m)
}

var xxx_messageInfo_TestCase proto.InternalMessageInfo

func (m *TestCase) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestCase) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestCase) GetTestSteps() []*TestCase_TestStep {
	if m != nil {
		return m.TestSteps
	}
	return nil
}

type TestCase_TestStep struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Pointer to the PickleStep (if derived from a PickleStep)
	PickleStepId string `protobuf:"bytes,2,opt,name=pickleStepId,proto3" json:"pickleStepId,omitempty"`
	// Pointer to all the matching StepDefinitions (if derived from a PickleStep)
	StepDefinitionId []string `protobuf:"bytes,3,rep,name=stepDefinitionId,proto3" json:"stepDefinitionId,omitempty"`
	// All the arguments from the match (if derived from a PickleStep and there was exactly 1 StepDefinition)
	StepMatchArguments []*StepMatchArgument `protobuf:"bytes,4,rep,name=stepMatchArguments,proto3" json:"stepMatchArguments,omitempty"`
	// Pointer to the TestCaseHookDefinitionConfig (if derived from a Hook)
	HookId string `protobuf:"bytes,5,opt,name=hookId,proto3" json:"hookId,omitempty"`
}

func (m *TestCase_TestStep) Reset()         { *m = TestCase_TestStep{} }
func (m *TestCase_TestStep) String() string { return proto.CompactTextString(m) }
func (*TestCase_TestStep) ProtoMessage()    {}
func (*TestCase_TestStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{11, 0}
}
func (m *TestCase_TestStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCase_TestStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCase_TestStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCase_TestStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCase_TestStep.Merge(m, src)
}
func (m *TestCase_TestStep) XXX_Size() int {
	return m.Size()
}
func (m *TestCase_TestStep) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCase_TestStep.DiscardUnknown(m)
}

var xxx_messageInfo_TestCase_TestStep proto.InternalMessageInfo

func (m *TestCase_TestStep) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestCase_TestStep) GetPickleStepId() string {
	if m != nil {
		return m.PickleStepId
	}
	return ""
}

func (m *TestCase_TestStep) GetStepDefinitionId() []string {
	if m != nil {
		return m.StepDefinitionId
	}
	return nil
}

func (m *TestCase_TestStep) GetStepMatchArguments() []*StepMatchArgument {
	if m != nil {
		return m.StepMatchArguments
	}
	return nil
}

func (m *TestCase_TestStep) GetHookId() string {
	if m != nil {
		return m.HookId
	}
	return ""
}

type PickleAccepted struct {
	PickleId string `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
}

func (m *PickleAccepted) Reset()         { *m = PickleAccepted{} }
func (m *PickleAccepted) String() string { return proto.CompactTextString(m) }
func (*PickleAccepted) ProtoMessage()    {}
func (*PickleAccepted) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{12}
}
func (m *PickleAccepted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleAccepted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleAccepted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleAccepted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleAccepted.Merge(m, src)
}
func (m *PickleAccepted) XXX_Size() int {
	return m.Size()
}
func (m *PickleAccepted) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleAccepted.DiscardUnknown(m)
}

var xxx_messageInfo_PickleAccepted proto.InternalMessageInfo

func (m *PickleAccepted) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

type PickleRejected struct {
	PickleId string `protobuf:"bytes,2,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
}

func (m *PickleRejected) Reset()         { *m = PickleRejected{} }
func (m *PickleRejected) String() string { return proto.CompactTextString(m) }
func (*PickleRejected) ProtoMessage()    {}
func (*PickleRejected) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{13}
}
func (m *PickleRejected) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleRejected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleRejected.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PickleRejected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleRejected.Merge(m, src)
}
func (m *PickleRejected) XXX_Size() int {
	return m.Size()
}
func (m *PickleRejected) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleRejected.DiscardUnknown(m)
}

var xxx_messageInfo_PickleRejected proto.InternalMessageInfo

func (m *PickleRejected) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

type TestRunStarted struct {
	Timestamp *Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *TestRunStarted) Reset()         { *m = TestRunStarted{} }
func (m *TestRunStarted) String() string { return proto.CompactTextString(m) }
func (*TestRunStarted) ProtoMessage()    {}
func (*TestRunStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{14}
}
func (m *TestRunStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestRunStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestRunStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestRunStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestRunStarted.Merge(m, src)
}
func (m *TestRunStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestRunStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestRunStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestRunStarted proto.InternalMessageInfo

func (m *TestRunStarted) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestCasePreparedStep struct {
	SourceLocation *SourceReference `protobuf:"bytes,1,opt,name=sourceLocation,proto3" json:"sourceLocation,omitempty"`
	ActionLocation *SourceReference `protobuf:"bytes,2,opt,name=actionLocation,proto3" json:"actionLocation,omitempty"`
}

func (m *TestCasePreparedStep) Reset()         { *m = TestCasePreparedStep{} }
func (m *TestCasePreparedStep) String() string { return proto.CompactTextString(m) }
func (*TestCasePreparedStep) ProtoMessage()    {}
func (*TestCasePreparedStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{15}
}
func (m *TestCasePreparedStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCasePreparedStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCasePreparedStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCasePreparedStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCasePreparedStep.Merge(m, src)
}
func (m *TestCasePreparedStep) XXX_Size() int {
	return m.Size()
}
func (m *TestCasePreparedStep) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCasePreparedStep.DiscardUnknown(m)
}

var xxx_messageInfo_TestCasePreparedStep proto.InternalMessageInfo

func (m *TestCasePreparedStep) GetSourceLocation() *SourceReference {
	if m != nil {
		return m.SourceLocation
	}
	return nil
}

func (m *TestCasePreparedStep) GetActionLocation() *SourceReference {
	if m != nil {
		return m.ActionLocation
	}
	return nil
}

type TestCasePrepared struct {
	PickleId string                  `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Steps    []*TestCasePreparedStep `protobuf:"bytes,2,rep,name=steps,proto3" json:"steps,omitempty"`
}

func (m *TestCasePrepared) Reset()         { *m = TestCasePrepared{} }
func (m *TestCasePrepared) String() string { return proto.CompactTextString(m) }
func (*TestCasePrepared) ProtoMessage()    {}
func (*TestCasePrepared) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{16}
}
func (m *TestCasePrepared) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCasePrepared) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCasePrepared.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCasePrepared) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCasePrepared.Merge(m, src)
}
func (m *TestCasePrepared) XXX_Size() int {
	return m.Size()
}
func (m *TestCasePrepared) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCasePrepared.DiscardUnknown(m)
}

var xxx_messageInfo_TestCasePrepared proto.InternalMessageInfo

func (m *TestCasePrepared) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestCasePrepared) GetSteps() []*TestCasePreparedStep {
	if m != nil {
		return m.Steps
	}
	return nil
}

type TestCaseStarted struct {
	Timestamp *Timestamp                `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Platform  *TestCaseStarted_Platform `protobuf:"bytes,3,opt,name=platform,proto3" json:"platform,omitempty"`
	//*
	// The first attempt should have value 0, and for each retry the value
	// should increase by 1.
	Attempt    uint32 `protobuf:"varint,4,opt,name=attempt,proto3" json:"attempt,omitempty"`
	TestCaseId string `protobuf:"bytes,5,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
	//*
	// Because a `TestCase` can be run multiple times (in case of a retry),
	// we use this field to group messages relating to the same attempt.
	Id string `protobuf:"bytes,6,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *TestCaseStarted) Reset()         { *m = TestCaseStarted{} }
func (m *TestCaseStarted) String() string { return proto.CompactTextString(m) }
func (*TestCaseStarted) ProtoMessage()    {}
func (*TestCaseStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{17}
}
func (m *TestCaseStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCaseStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCaseStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCaseStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCaseStarted.Merge(m, src)
}
func (m *TestCaseStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestCaseStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCaseStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestCaseStarted proto.InternalMessageInfo

func (m *TestCaseStarted) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestCaseStarted) GetPlatform() *TestCaseStarted_Platform {
	if m != nil {
		return m.Platform
	}
	return nil
}

func (m *TestCaseStarted) GetAttempt() uint32 {
	if m != nil {
		return m.Attempt
	}
	return 0
}

func (m *TestCaseStarted) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

func (m *TestCaseStarted) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type TestCaseStarted_Platform struct {
	// The runner implementation. For example "SpecFlow", "Cucumber-JVM", "Behat" etc.
	Implementation string `protobuf:"bytes,1,opt,name=implementation,proto3" json:"implementation,omitempty"`
	// The version of the runner
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// The operating system
	Os string `protobuf:"bytes,3,opt,name=os,proto3" json:"os,omitempty"`
	// The CPU architecture
	Cpu string `protobuf:"bytes,4,opt,name=cpu,proto3" json:"cpu,omitempty"`
}

func (m *TestCaseStarted_Platform) Reset()         { *m = TestCaseStarted_Platform{} }
func (m *TestCaseStarted_Platform) String() string { return proto.CompactTextString(m) }
func (*TestCaseStarted_Platform) ProtoMessage()    {}
func (*TestCaseStarted_Platform) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{17, 0}
}
func (m *TestCaseStarted_Platform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCaseStarted_Platform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCaseStarted_Platform.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCaseStarted_Platform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCaseStarted_Platform.Merge(m, src)
}
func (m *TestCaseStarted_Platform) XXX_Size() int {
	return m.Size()
}
func (m *TestCaseStarted_Platform) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCaseStarted_Platform.DiscardUnknown(m)
}

var xxx_messageInfo_TestCaseStarted_Platform proto.InternalMessageInfo

func (m *TestCaseStarted_Platform) GetImplementation() string {
	if m != nil {
		return m.Implementation
	}
	return ""
}

func (m *TestCaseStarted_Platform) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *TestCaseStarted_Platform) GetOs() string {
	if m != nil {
		return m.Os
	}
	return ""
}

func (m *TestCaseStarted_Platform) GetCpu() string {
	if m != nil {
		return m.Cpu
	}
	return ""
}

type TestCaseFinished struct {
	Timestamp         *Timestamp  `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TestResult        *TestResult `protobuf:"bytes,3,opt,name=testResult,proto3" json:"testResult,omitempty"`
	TestCaseStartedId string      `protobuf:"bytes,5,opt,name=testCaseStartedId,proto3" json:"testCaseStartedId,omitempty"`
}

func (m *TestCaseFinished) Reset()         { *m = TestCaseFinished{} }
func (m *TestCaseFinished) String() string { return proto.CompactTextString(m) }
func (*TestCaseFinished) ProtoMessage()    {}
func (*TestCaseFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{18}
}
func (m *TestCaseFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCaseFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCaseFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCaseFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCaseFinished.Merge(m, src)
}
func (m *TestCaseFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestCaseFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCaseFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestCaseFinished proto.InternalMessageInfo

func (m *TestCaseFinished) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestCaseFinished) GetTestResult() *TestResult {
	if m != nil {
		return m.TestResult
	}
	return nil
}

func (m *TestCaseFinished) GetTestCaseStartedId() string {
	if m != nil {
		return m.TestCaseStartedId
	}
	return ""
}

// For each step, there will be a match
// DEPRECATED - replaced by TestStep
type TestStepMatched struct {
	PickleId                string               `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Index                   uint32               `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	StepDefinitionReference *SourceReference     `protobuf:"bytes,3,opt,name=stepDefinitionReference,proto3" json:"stepDefinitionReference,omitempty"`
	StepMatchArguments      []*StepMatchArgument `protobuf:"bytes,4,rep,name=stepMatchArguments,proto3" json:"stepMatchArguments,omitempty"`
}

func (m *TestStepMatched) Reset()         { *m = TestStepMatched{} }
func (m *TestStepMatched) String() string { return proto.CompactTextString(m) }
func (*TestStepMatched) ProtoMessage()    {}
func (*TestStepMatched) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{19}
}
func (m *TestStepMatched) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestStepMatched) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestStepMatched.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestStepMatched) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestStepMatched.Merge(m, src)
}
func (m *TestStepMatched) XXX_Size() int {
	return m.Size()
}
func (m *TestStepMatched) XXX_DiscardUnknown() {
	xxx_messageInfo_TestStepMatched.DiscardUnknown(m)
}

var xxx_messageInfo_TestStepMatched proto.InternalMessageInfo

func (m *TestStepMatched) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestStepMatched) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *TestStepMatched) GetStepDefinitionReference() *SourceReference {
	if m != nil {
		return m.StepDefinitionReference
	}
	return nil
}

func (m *TestStepMatched) GetStepMatchArguments() []*StepMatchArgument {
	if m != nil {
		return m.StepMatchArguments
	}
	return nil
}

type TestStepStarted struct {
	Timestamp         *Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TestStepId        string     `protobuf:"bytes,5,opt,name=testStepId,proto3" json:"testStepId,omitempty"`
	TestCaseStartedId string     `protobuf:"bytes,6,opt,name=testCaseStartedId,proto3" json:"testCaseStartedId,omitempty"`
}

func (m *TestStepStarted) Reset()         { *m = TestStepStarted{} }
func (m *TestStepStarted) String() string { return proto.CompactTextString(m) }
func (*TestStepStarted) ProtoMessage()    {}
func (*TestStepStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{20}
}
func (m *TestStepStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestStepStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestStepStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestStepStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestStepStarted.Merge(m, src)
}
func (m *TestStepStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestStepStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestStepStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestStepStarted proto.InternalMessageInfo

func (m *TestStepStarted) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestStepStarted) GetTestStepId() string {
	if m != nil {
		return m.TestStepId
	}
	return ""
}

func (m *TestStepStarted) GetTestCaseStartedId() string {
	if m != nil {
		return m.TestCaseStartedId
	}
	return ""
}

type TestStepFinished struct {
	TestResult        *TestResult `protobuf:"bytes,3,opt,name=testResult,proto3" json:"testResult,omitempty"`
	Timestamp         *Timestamp  `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TestStepId        string      `protobuf:"bytes,6,opt,name=testStepId,proto3" json:"testStepId,omitempty"`
	TestCaseStartedId string      `protobuf:"bytes,7,opt,name=testCaseStartedId,proto3" json:"testCaseStartedId,omitempty"`
}

func (m *TestStepFinished) Reset()         { *m = TestStepFinished{} }
func (m *TestStepFinished) String() string { return proto.CompactTextString(m) }
func (*TestStepFinished) ProtoMessage()    {}
func (*TestStepFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{21}
}
func (m *TestStepFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestStepFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestStepFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestStepFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestStepFinished.Merge(m, src)
}
func (m *TestStepFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestStepFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestStepFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestStepFinished proto.InternalMessageInfo

func (m *TestStepFinished) GetTestResult() *TestResult {
	if m != nil {
		return m.TestResult
	}
	return nil
}

func (m *TestStepFinished) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestStepFinished) GetTestStepId() string {
	if m != nil {
		return m.TestStepId
	}
	return ""
}

func (m *TestStepFinished) GetTestCaseStartedId() string {
	if m != nil {
		return m.TestCaseStartedId
	}
	return ""
}

// DEPRECATED: Replaced by TestStepStarted
type TestHookStarted struct {
	Timestamp  *Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TestCaseId string     `protobuf:"bytes,3,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
}

func (m *TestHookStarted) Reset()         { *m = TestHookStarted{} }
func (m *TestHookStarted) String() string { return proto.CompactTextString(m) }
func (*TestHookStarted) ProtoMessage()    {}
func (*TestHookStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{22}
}
func (m *TestHookStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestHookStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestHookStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestHookStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestHookStarted.Merge(m, src)
}
func (m *TestHookStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestHookStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestHookStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestHookStarted proto.InternalMessageInfo

func (m *TestHookStarted) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestHookStarted) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

// DEPRECATED: Replaced by TestStepFinished
type TestHookFinished struct {
	TestResult *TestResult `protobuf:"bytes,2,opt,name=testResult,proto3" json:"testResult,omitempty"`
	Timestamp  *Timestamp  `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	TestCaseId string      `protobuf:"bytes,4,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
}

func (m *TestHookFinished) Reset()         { *m = TestHookFinished{} }
func (m *TestHookFinished) String() string { return proto.CompactTextString(m) }
func (*TestHookFinished) ProtoMessage()    {}
func (*TestHookFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{23}
}
func (m *TestHookFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestHookFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestHookFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestHookFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestHookFinished.Merge(m, src)
}
func (m *TestHookFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestHookFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestHookFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestHookFinished proto.InternalMessageInfo

func (m *TestHookFinished) GetTestResult() *TestResult {
	if m != nil {
		return m.TestResult
	}
	return nil
}

func (m *TestHookFinished) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestHookFinished) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

type TestResult struct {
	Status        TestResult_Status `protobuf:"varint,1,opt,name=status,proto3,enum=io.cucumber.messages.TestResult_Status" json:"status,omitempty"`
	Message       string            `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Duration      *Duration         `protobuf:"bytes,4,opt,name=duration,proto3" json:"duration,omitempty"`
	WillBeRetried bool              `protobuf:"varint,5,opt,name=willBeRetried,proto3" json:"willBeRetried,omitempty"`
}

func (m *TestResult) Reset()         { *m = TestResult{} }
func (m *TestResult) String() string { return proto.CompactTextString(m) }
func (*TestResult) ProtoMessage()    {}
func (*TestResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{24}
}
func (m *TestResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestResult.Merge(m, src)
}
func (m *TestResult) XXX_Size() int {
	return m.Size()
}
func (m *TestResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TestResult.DiscardUnknown(m)
}

var xxx_messageInfo_TestResult proto.InternalMessageInfo

func (m *TestResult) GetStatus() TestResult_Status {
	if m != nil {
		return m.Status
	}
	return TestResult_UNKNOWN
}

func (m *TestResult) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TestResult) GetDuration() *Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *TestResult) GetWillBeRetried() bool {
	if m != nil {
		return m.WillBeRetried
	}
	return false
}

type TestRunFinished struct {
	// success = StrictModeEnabled ? (failed_count == 0 && ambiguous_count == 0 && undefined_count == 0 && pending_count == 0) : (failed_count == 0 && ambiguous_count == 0)
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Timestamp when the TestRun is finished
	Timestamp *Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *TestRunFinished) Reset()         { *m = TestRunFinished{} }
func (m *TestRunFinished) String() string { return proto.CompactTextString(m) }
func (*TestRunFinished) ProtoMessage()    {}
func (*TestRunFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{25}
}
func (m *TestRunFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestRunFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestRunFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestRunFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestRunFinished.Merge(m, src)
}
func (m *TestRunFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestRunFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestRunFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestRunFinished proto.InternalMessageInfo

func (m *TestRunFinished) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *TestRunFinished) GetTimestamp() *Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type CommandStart struct {
	BaseDirectory     string             `protobuf:"bytes,2,opt,name=baseDirectory,proto3" json:"baseDirectory,omitempty"`
	SourcesConfig     *SourcesConfig     `protobuf:"bytes,3,opt,name=sourcesConfig,proto3" json:"sourcesConfig,omitempty"`
	RuntimeConfig     *RuntimeConfig     `protobuf:"bytes,4,opt,name=runtimeConfig,proto3" json:"runtimeConfig,omitempty"`
	SupportCodeConfig *SupportCodeConfig `protobuf:"bytes,5,opt,name=supportCodeConfig,proto3" json:"supportCodeConfig,omitempty"`
}

func (m *CommandStart) Reset()         { *m = CommandStart{} }
func (m *CommandStart) String() string { return proto.CompactTextString(m) }
func (*CommandStart) ProtoMessage()    {}
func (*CommandStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{26}
}
func (m *CommandStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStart.Merge(m, src)
}
func (m *CommandStart) XXX_Size() int {
	return m.Size()
}
func (m *CommandStart) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStart.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStart proto.InternalMessageInfo

func (m *CommandStart) GetBaseDirectory() string {
	if m != nil {
		return m.BaseDirectory
	}
	return ""
}

func (m *CommandStart) GetSourcesConfig() *SourcesConfig {
	if m != nil {
		return m.SourcesConfig
	}
	return nil
}

func (m *CommandStart) GetRuntimeConfig() *RuntimeConfig {
	if m != nil {
		return m.RuntimeConfig
	}
	return nil
}

func (m *CommandStart) GetSupportCodeConfig() *SupportCodeConfig {
	if m != nil {
		return m.SupportCodeConfig
	}
	return nil
}

type SourcesConfig struct {
	AbsolutePaths []string             `protobuf:"bytes,1,rep,name=absolutePaths,proto3" json:"absolutePaths,omitempty"`
	Language      string               `protobuf:"bytes,2,opt,name=language,proto3" json:"language,omitempty"`
	Filters       *SourcesFilterConfig `protobuf:"bytes,3,opt,name=filters,proto3" json:"filters,omitempty"`
	Order         *SourcesOrder        `protobuf:"bytes,4,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *SourcesConfig) Reset()         { *m = SourcesConfig{} }
func (m *SourcesConfig) String() string { return proto.CompactTextString(m) }
func (*SourcesConfig) ProtoMessage()    {}
func (*SourcesConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{27}
}
func (m *SourcesConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourcesConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourcesConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourcesConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourcesConfig.Merge(m, src)
}
func (m *SourcesConfig) XXX_Size() int {
	return m.Size()
}
func (m *SourcesConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SourcesConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SourcesConfig proto.InternalMessageInfo

func (m *SourcesConfig) GetAbsolutePaths() []string {
	if m != nil {
		return m.AbsolutePaths
	}
	return nil
}

func (m *SourcesConfig) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *SourcesConfig) GetFilters() *SourcesFilterConfig {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *SourcesConfig) GetOrder() *SourcesOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

type SourcesFilterConfig struct {
	TagExpression          string               `protobuf:"bytes,1,opt,name=tagExpression,proto3" json:"tagExpression,omitempty"`
	NameRegularExpressions []string             `protobuf:"bytes,2,rep,name=nameRegularExpressions,proto3" json:"nameRegularExpressions,omitempty"`
	UriToLinesMapping      []*UriToLinesMapping `protobuf:"bytes,3,rep,name=uriToLinesMapping,proto3" json:"uriToLinesMapping,omitempty"`
}

func (m *SourcesFilterConfig) Reset()         { *m = SourcesFilterConfig{} }
func (m *SourcesFilterConfig) String() string { return proto.CompactTextString(m) }
func (*SourcesFilterConfig) ProtoMessage()    {}
func (*SourcesFilterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{28}
}
func (m *SourcesFilterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourcesFilterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourcesFilterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourcesFilterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourcesFilterConfig.Merge(m, src)
}
func (m *SourcesFilterConfig) XXX_Size() int {
	return m.Size()
}
func (m *SourcesFilterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SourcesFilterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SourcesFilterConfig proto.InternalMessageInfo

func (m *SourcesFilterConfig) GetTagExpression() string {
	if m != nil {
		return m.TagExpression
	}
	return ""
}

func (m *SourcesFilterConfig) GetNameRegularExpressions() []string {
	if m != nil {
		return m.NameRegularExpressions
	}
	return nil
}

func (m *SourcesFilterConfig) GetUriToLinesMapping() []*UriToLinesMapping {
	if m != nil {
		return m.UriToLinesMapping
	}
	return nil
}

type UriToLinesMapping struct {
	AbsolutePath string   `protobuf:"bytes,1,opt,name=absolutePath,proto3" json:"absolutePath,omitempty"`
	Lines        []uint64 `protobuf:"varint,2,rep,packed,name=lines,proto3" json:"lines,omitempty"`
}

func (m *UriToLinesMapping) Reset()         { *m = UriToLinesMapping{} }
func (m *UriToLinesMapping) String() string { return proto.CompactTextString(m) }
func (*UriToLinesMapping) ProtoMessage()    {}
func (*UriToLinesMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{29}
}
func (m *UriToLinesMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UriToLinesMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UriToLinesMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UriToLinesMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UriToLinesMapping.Merge(m, src)
}
func (m *UriToLinesMapping) XXX_Size() int {
	return m.Size()
}
func (m *UriToLinesMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_UriToLinesMapping.DiscardUnknown(m)
}

var xxx_messageInfo_UriToLinesMapping proto.InternalMessageInfo

func (m *UriToLinesMapping) GetAbsolutePath() string {
	if m != nil {
		return m.AbsolutePath
	}
	return ""
}

func (m *UriToLinesMapping) GetLines() []uint64 {
	if m != nil {
		return m.Lines
	}
	return nil
}

type SourcesOrder struct {
	Type SourcesOrderType `protobuf:"varint,1,opt,name=type,proto3,enum=io.cucumber.messages.SourcesOrderType" json:"type,omitempty"`
	Seed uint64           `protobuf:"varint,2,opt,name=seed,proto3" json:"seed,omitempty"`
}

func (m *SourcesOrder) Reset()         { *m = SourcesOrder{} }
func (m *SourcesOrder) String() string { return proto.CompactTextString(m) }
func (*SourcesOrder) ProtoMessage()    {}
func (*SourcesOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{30}
}
func (m *SourcesOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourcesOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourcesOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourcesOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourcesOrder.Merge(m, src)
}
func (m *SourcesOrder) XXX_Size() int {
	return m.Size()
}
func (m *SourcesOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_SourcesOrder.DiscardUnknown(m)
}

var xxx_messageInfo_SourcesOrder proto.InternalMessageInfo

func (m *SourcesOrder) GetType() SourcesOrderType {
	if m != nil {
		return m.Type
	}
	return SourcesOrderType_ORDER_OF_DEFINITION
}

func (m *SourcesOrder) GetSeed() uint64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

type RuntimeConfig struct {
	IsFailFast  bool   `protobuf:"varint,1,opt,name=isFailFast,proto3" json:"isFailFast,omitempty"`
	IsDryRun    bool   `protobuf:"varint,2,opt,name=isDryRun,proto3" json:"isDryRun,omitempty"`
	IsStrict    bool   `protobuf:"varint,3,opt,name=isStrict,proto3" json:"isStrict,omitempty"`
	MaxParallel uint64 `protobuf:"varint,4,opt,name=maxParallel,proto3" json:"maxParallel,omitempty"`
}

func (m *RuntimeConfig) Reset()         { *m = RuntimeConfig{} }
func (m *RuntimeConfig) String() string { return proto.CompactTextString(m) }
func (*RuntimeConfig) ProtoMessage()    {}
func (*RuntimeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{31}
}
func (m *RuntimeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuntimeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuntimeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RuntimeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuntimeConfig.Merge(m, src)
}
func (m *RuntimeConfig) XXX_Size() int {
	return m.Size()
}
func (m *RuntimeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RuntimeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RuntimeConfig proto.InternalMessageInfo

func (m *RuntimeConfig) GetIsFailFast() bool {
	if m != nil {
		return m.IsFailFast
	}
	return false
}

func (m *RuntimeConfig) GetIsDryRun() bool {
	if m != nil {
		return m.IsDryRun
	}
	return false
}

func (m *RuntimeConfig) GetIsStrict() bool {
	if m != nil {
		return m.IsStrict
	}
	return false
}

func (m *RuntimeConfig) GetMaxParallel() uint64 {
	if m != nil {
		return m.MaxParallel
	}
	return 0
}

type SupportCodeConfig struct {
	BeforeTestCaseHookDefinitionConfigs []*TestCaseHookDefinitionConfig `protobuf:"bytes,1,rep,name=beforeTestCaseHookDefinitionConfigs,proto3" json:"beforeTestCaseHookDefinitionConfigs,omitempty"`
	AfterTestCaseHookDefinitionConfigs  []*TestCaseHookDefinitionConfig `protobuf:"bytes,2,rep,name=afterTestCaseHookDefinitionConfigs,proto3" json:"afterTestCaseHookDefinitionConfigs,omitempty"`
	StepDefinitionConfigs               []*StepDefinitionConfig         `protobuf:"bytes,3,rep,name=stepDefinitionConfigs,proto3" json:"stepDefinitionConfigs,omitempty"`
	ParameterTypeConfigs                []*ParameterTypeConfig          `protobuf:"bytes,4,rep,name=parameterTypeConfigs,proto3" json:"parameterTypeConfigs,omitempty"`
}

func (m *SupportCodeConfig) Reset()         { *m = SupportCodeConfig{} }
func (m *SupportCodeConfig) String() string { return proto.CompactTextString(m) }
func (*SupportCodeConfig) ProtoMessage()    {}
func (*SupportCodeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{32}
}
func (m *SupportCodeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupportCodeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupportCodeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupportCodeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupportCodeConfig.Merge(m, src)
}
func (m *SupportCodeConfig) XXX_Size() int {
	return m.Size()
}
func (m *SupportCodeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SupportCodeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SupportCodeConfig proto.InternalMessageInfo

func (m *SupportCodeConfig) GetBeforeTestCaseHookDefinitionConfigs() []*TestCaseHookDefinitionConfig {
	if m != nil {
		return m.BeforeTestCaseHookDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetAfterTestCaseHookDefinitionConfigs() []*TestCaseHookDefinitionConfig {
	if m != nil {
		return m.AfterTestCaseHookDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetStepDefinitionConfigs() []*StepDefinitionConfig {
	if m != nil {
		return m.StepDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetParameterTypeConfigs() []*ParameterTypeConfig {
	if m != nil {
		return m.ParameterTypeConfigs
	}
	return nil
}

// TODO: Rename to Hook
type TestCaseHookDefinitionConfig struct {
	Id            string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	TagExpression string `protobuf:"bytes,2,opt,name=tagExpression,proto3" json:"tagExpression,omitempty"`
	// TODO: rename to sourceReference as Location is another type and this is ambiguous.
	Location *SourceReference `protobuf:"bytes,3,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *TestCaseHookDefinitionConfig) Reset()         { *m = TestCaseHookDefinitionConfig{} }
func (m *TestCaseHookDefinitionConfig) String() string { return proto.CompactTextString(m) }
func (*TestCaseHookDefinitionConfig) ProtoMessage()    {}
func (*TestCaseHookDefinitionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{33}
}
func (m *TestCaseHookDefinitionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCaseHookDefinitionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCaseHookDefinitionConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestCaseHookDefinitionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCaseHookDefinitionConfig.Merge(m, src)
}
func (m *TestCaseHookDefinitionConfig) XXX_Size() int {
	return m.Size()
}
func (m *TestCaseHookDefinitionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCaseHookDefinitionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TestCaseHookDefinitionConfig proto.InternalMessageInfo

func (m *TestCaseHookDefinitionConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestCaseHookDefinitionConfig) GetTagExpression() string {
	if m != nil {
		return m.TagExpression
	}
	return ""
}

func (m *TestCaseHookDefinitionConfig) GetLocation() *SourceReference {
	if m != nil {
		return m.Location
	}
	return nil
}

// TODO: Rename to StepDefinition
type StepDefinitionConfig struct {
	Id       string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Pattern  *StepDefinitionPattern `protobuf:"bytes,2,opt,name=pattern,proto3" json:"pattern,omitempty"`
	Location *SourceReference       `protobuf:"bytes,3,opt,name=location,proto3" json:"location,omitempty"`
}

func (m *StepDefinitionConfig) Reset()         { *m = StepDefinitionConfig{} }
func (m *StepDefinitionConfig) String() string { return proto.CompactTextString(m) }
func (*StepDefinitionConfig) ProtoMessage()    {}
func (*StepDefinitionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{34}
}
func (m *StepDefinitionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepDefinitionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepDefinitionConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepDefinitionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepDefinitionConfig.Merge(m, src)
}
func (m *StepDefinitionConfig) XXX_Size() int {
	return m.Size()
}
func (m *StepDefinitionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StepDefinitionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StepDefinitionConfig proto.InternalMessageInfo

func (m *StepDefinitionConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StepDefinitionConfig) GetPattern() *StepDefinitionPattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *StepDefinitionConfig) GetLocation() *SourceReference {
	if m != nil {
		return m.Location
	}
	return nil
}

type StepDefinitionPattern struct {
	Source string                    `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type   StepDefinitionPatternType `protobuf:"varint,2,opt,name=type,proto3,enum=io.cucumber.messages.StepDefinitionPatternType" json:"type,omitempty"`
}

func (m *StepDefinitionPattern) Reset()         { *m = StepDefinitionPattern{} }
func (m *StepDefinitionPattern) String() string { return proto.CompactTextString(m) }
func (*StepDefinitionPattern) ProtoMessage()    {}
func (*StepDefinitionPattern) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{35}
}
func (m *StepDefinitionPattern) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepDefinitionPattern) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepDefinitionPattern.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepDefinitionPattern) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepDefinitionPattern.Merge(m, src)
}
func (m *StepDefinitionPattern) XXX_Size() int {
	return m.Size()
}
func (m *StepDefinitionPattern) XXX_DiscardUnknown() {
	xxx_messageInfo_StepDefinitionPattern.DiscardUnknown(m)
}

var xxx_messageInfo_StepDefinitionPattern proto.InternalMessageInfo

func (m *StepDefinitionPattern) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *StepDefinitionPattern) GetType() StepDefinitionPatternType {
	if m != nil {
		return m.Type
	}
	return StepDefinitionPatternType_CUCUMBER_EXPRESSION
}

type ParameterTypeConfig struct {
	Name                            string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	RegularExpressions              []string `protobuf:"bytes,2,rep,name=regularExpressions,proto3" json:"regularExpressions,omitempty"`
	PreferForRegularExpressionMatch bool     `protobuf:"varint,3,opt,name=preferForRegularExpressionMatch,proto3" json:"preferForRegularExpressionMatch,omitempty"`
	UseForSnippets                  bool     `protobuf:"varint,4,opt,name=useForSnippets,proto3" json:"useForSnippets,omitempty"`
}

func (m *ParameterTypeConfig) Reset()         { *m = ParameterTypeConfig{} }
func (m *ParameterTypeConfig) String() string { return proto.CompactTextString(m) }
func (*ParameterTypeConfig) ProtoMessage()    {}
func (*ParameterTypeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{36}
}
func (m *ParameterTypeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParameterTypeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParameterTypeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParameterTypeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParameterTypeConfig.Merge(m, src)
}
func (m *ParameterTypeConfig) XXX_Size() int {
	return m.Size()
}
func (m *ParameterTypeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ParameterTypeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ParameterTypeConfig proto.InternalMessageInfo

func (m *ParameterTypeConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ParameterTypeConfig) GetRegularExpressions() []string {
	if m != nil {
		return m.RegularExpressions
	}
	return nil
}

func (m *ParameterTypeConfig) GetPreferForRegularExpressionMatch() bool {
	if m != nil {
		return m.PreferForRegularExpressionMatch
	}
	return false
}

func (m *ParameterTypeConfig) GetUseForSnippets() bool {
	if m != nil {
		return m.UseForSnippets
	}
	return false
}

type CommandActionComplete struct {
	CompletedId string `protobuf:"bytes,1,opt,name=completedId,proto3" json:"completedId,omitempty"`
	// Types that are valid to be assigned to Result:
	//	*CommandActionComplete_TestResult
	//	*CommandActionComplete_Snippet
	Result isCommandActionComplete_Result `protobuf_oneof:"result"`
}

func (m *CommandActionComplete) Reset()         { *m = CommandActionComplete{} }
func (m *CommandActionComplete) String() string { return proto.CompactTextString(m) }
func (*CommandActionComplete) ProtoMessage()    {}
func (*CommandActionComplete) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{37}
}
func (m *CommandActionComplete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandActionComplete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandActionComplete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandActionComplete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandActionComplete.Merge(m, src)
}
func (m *CommandActionComplete) XXX_Size() int {
	return m.Size()
}
func (m *CommandActionComplete) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandActionComplete.DiscardUnknown(m)
}

var xxx_messageInfo_CommandActionComplete proto.InternalMessageInfo

type isCommandActionComplete_Result interface {
	isCommandActionComplete_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CommandActionComplete_TestResult struct {
	TestResult *TestResult `protobuf:"bytes,2,opt,name=testResult,proto3,oneof"`
}
type CommandActionComplete_Snippet struct {
	Snippet string `protobuf:"bytes,3,opt,name=snippet,proto3,oneof"`
}

func (*CommandActionComplete_TestResult) isCommandActionComplete_Result() {}
func (*CommandActionComplete_Snippet) isCommandActionComplete_Result()    {}

func (m *CommandActionComplete) GetResult() isCommandActionComplete_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *CommandActionComplete) GetCompletedId() string {
	if m != nil {
		return m.CompletedId
	}
	return ""
}

func (m *CommandActionComplete) GetTestResult() *TestResult {
	if x, ok := m.GetResult().(*CommandActionComplete_TestResult); ok {
		return x.TestResult
	}
	return nil
}

func (m *CommandActionComplete) GetSnippet() string {
	if x, ok := m.GetResult().(*CommandActionComplete_Snippet); ok {
		return x.Snippet
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CommandActionComplete) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CommandActionComplete_TestResult)(nil),
		(*CommandActionComplete_Snippet)(nil),
	}
}

type CommandRunBeforeTestRunHooks struct {
	ActionId string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
}

func (m *CommandRunBeforeTestRunHooks) Reset()         { *m = CommandRunBeforeTestRunHooks{} }
func (m *CommandRunBeforeTestRunHooks) String() string { return proto.CompactTextString(m) }
func (*CommandRunBeforeTestRunHooks) ProtoMessage()    {}
func (*CommandRunBeforeTestRunHooks) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{38}
}
func (m *CommandRunBeforeTestRunHooks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunBeforeTestRunHooks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunBeforeTestRunHooks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandRunBeforeTestRunHooks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunBeforeTestRunHooks.Merge(m, src)
}
func (m *CommandRunBeforeTestRunHooks) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunBeforeTestRunHooks) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunBeforeTestRunHooks.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunBeforeTestRunHooks proto.InternalMessageInfo

func (m *CommandRunBeforeTestRunHooks) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

type CommandRunAfterTestRunHooks struct {
	ActionId string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
}

func (m *CommandRunAfterTestRunHooks) Reset()         { *m = CommandRunAfterTestRunHooks{} }
func (m *CommandRunAfterTestRunHooks) String() string { return proto.CompactTextString(m) }
func (*CommandRunAfterTestRunHooks) ProtoMessage()    {}
func (*CommandRunAfterTestRunHooks) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{39}
}
func (m *CommandRunAfterTestRunHooks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunAfterTestRunHooks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunAfterTestRunHooks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandRunAfterTestRunHooks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunAfterTestRunHooks.Merge(m, src)
}
func (m *CommandRunAfterTestRunHooks) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunAfterTestRunHooks) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunAfterTestRunHooks.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunAfterTestRunHooks proto.InternalMessageInfo

func (m *CommandRunAfterTestRunHooks) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

type CommandInitializeTestCase struct {
	ActionId string  `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	Pickle   *Pickle `protobuf:"bytes,3,opt,name=pickle,proto3" json:"pickle,omitempty"`
}

func (m *CommandInitializeTestCase) Reset()         { *m = CommandInitializeTestCase{} }
func (m *CommandInitializeTestCase) String() string { return proto.CompactTextString(m) }
func (*CommandInitializeTestCase) ProtoMessage()    {}
func (*CommandInitializeTestCase) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{40}
}
func (m *CommandInitializeTestCase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandInitializeTestCase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandInitializeTestCase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandInitializeTestCase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandInitializeTestCase.Merge(m, src)
}
func (m *CommandInitializeTestCase) XXX_Size() int {
	return m.Size()
}
func (m *CommandInitializeTestCase) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandInitializeTestCase.DiscardUnknown(m)
}

var xxx_messageInfo_CommandInitializeTestCase proto.InternalMessageInfo

func (m *CommandInitializeTestCase) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandInitializeTestCase) GetPickle() *Pickle {
	if m != nil {
		return m.Pickle
	}
	return nil
}

type CommandRunBeforeTestCaseHook struct {
	ActionId                 string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	TestCaseHookDefinitionId string `protobuf:"bytes,3,opt,name=testCaseHookDefinitionId,proto3" json:"testCaseHookDefinitionId,omitempty"`
	TestCaseId               string `protobuf:"bytes,5,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
}

func (m *CommandRunBeforeTestCaseHook) Reset()         { *m = CommandRunBeforeTestCaseHook{} }
func (m *CommandRunBeforeTestCaseHook) String() string { return proto.CompactTextString(m) }
func (*CommandRunBeforeTestCaseHook) ProtoMessage()    {}
func (*CommandRunBeforeTestCaseHook) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{41}
}
func (m *CommandRunBeforeTestCaseHook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunBeforeTestCaseHook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunBeforeTestCaseHook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandRunBeforeTestCaseHook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunBeforeTestCaseHook.Merge(m, src)
}
func (m *CommandRunBeforeTestCaseHook) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunBeforeTestCaseHook) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunBeforeTestCaseHook.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunBeforeTestCaseHook proto.InternalMessageInfo

func (m *CommandRunBeforeTestCaseHook) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandRunBeforeTestCaseHook) GetTestCaseHookDefinitionId() string {
	if m != nil {
		return m.TestCaseHookDefinitionId
	}
	return ""
}

func (m *CommandRunBeforeTestCaseHook) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

type CommandRunAfterTestCaseHook struct {
	ActionId                 string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	TestCaseHookDefinitionId string `protobuf:"bytes,3,opt,name=testCaseHookDefinitionId,proto3" json:"testCaseHookDefinitionId,omitempty"`
	TestCaseId               string `protobuf:"bytes,5,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
}

func (m *CommandRunAfterTestCaseHook) Reset()         { *m = CommandRunAfterTestCaseHook{} }
func (m *CommandRunAfterTestCaseHook) String() string { return proto.CompactTextString(m) }
func (*CommandRunAfterTestCaseHook) ProtoMessage()    {}
func (*CommandRunAfterTestCaseHook) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{42}
}
func (m *CommandRunAfterTestCaseHook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunAfterTestCaseHook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunAfterTestCaseHook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandRunAfterTestCaseHook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunAfterTestCaseHook.Merge(m, src)
}
func (m *CommandRunAfterTestCaseHook) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunAfterTestCaseHook) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunAfterTestCaseHook.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunAfterTestCaseHook proto.InternalMessageInfo

func (m *CommandRunAfterTestCaseHook) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandRunAfterTestCaseHook) GetTestCaseHookDefinitionId() string {
	if m != nil {
		return m.TestCaseHookDefinitionId
	}
	return ""
}

func (m *CommandRunAfterTestCaseHook) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

type CommandRunTestStep struct {
	ActionId           string               `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	StepDefinitionId   string               `protobuf:"bytes,3,opt,name=stepDefinitionId,proto3" json:"stepDefinitionId,omitempty"`
	StepMatchArguments []*StepMatchArgument `protobuf:"bytes,4,rep,name=stepMatchArguments,proto3" json:"stepMatchArguments,omitempty"`
	PickleStepArgument *PickleStepArgument  `protobuf:"bytes,6,opt,name=pickleStepArgument,proto3" json:"pickleStepArgument,omitempty"`
	TestCaseId         string               `protobuf:"bytes,7,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
}

func (m *CommandRunTestStep) Reset()         { *m = CommandRunTestStep{} }
func (m *CommandRunTestStep) String() string { return proto.CompactTextString(m) }
func (*CommandRunTestStep) ProtoMessage()    {}
func (*CommandRunTestStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{43}
}
func (m *CommandRunTestStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunTestStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunTestStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandRunTestStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunTestStep.Merge(m, src)
}
func (m *CommandRunTestStep) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunTestStep) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunTestStep.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunTestStep proto.InternalMessageInfo

func (m *CommandRunTestStep) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandRunTestStep) GetStepDefinitionId() string {
	if m != nil {
		return m.StepDefinitionId
	}
	return ""
}

func (m *CommandRunTestStep) GetStepMatchArguments() []*StepMatchArgument {
	if m != nil {
		return m.StepMatchArguments
	}
	return nil
}

func (m *CommandRunTestStep) GetPickleStepArgument() *PickleStepArgument {
	if m != nil {
		return m.PickleStepArgument
	}
	return nil
}

func (m *CommandRunTestStep) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

//*
// Represents a single argument extracted from a step match and passed to a step definition.
// This is used for the following purposes:
// - Construct an argument to pass to a step definition (possibly through a parameter type transform)
// - Highlight the matched parameter in rich formatters such as the HTML formatter
//
// This message closely matches the `Argument` class in the `cucumber-expressions` library.
type StepMatchArgument struct {
	ParameterTypeName string `protobuf:"bytes,2,opt,name=parameterTypeName,proto3" json:"parameterTypeName,omitempty"`
	//*
	// Represents the outermost capture group of an argument. This message closely matches the
	// `Group` class in the `cucumber-expressions` library.
	Group *StepMatchArgument_Group `protobuf:"bytes,5,opt,name=group,proto3" json:"group,omitempty"`
}

func (m *StepMatchArgument) Reset()         { *m = StepMatchArgument{} }
func (m *StepMatchArgument) String() string { return proto.CompactTextString(m) }
func (*StepMatchArgument) ProtoMessage()    {}
func (*StepMatchArgument) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{44}
}
func (m *StepMatchArgument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepMatchArgument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepMatchArgument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepMatchArgument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepMatchArgument.Merge(m, src)
}
func (m *StepMatchArgument) XXX_Size() int {
	return m.Size()
}
func (m *StepMatchArgument) XXX_DiscardUnknown() {
	xxx_messageInfo_StepMatchArgument.DiscardUnknown(m)
}

var xxx_messageInfo_StepMatchArgument proto.InternalMessageInfo

func (m *StepMatchArgument) GetParameterTypeName() string {
	if m != nil {
		return m.ParameterTypeName
	}
	return ""
}

func (m *StepMatchArgument) GetGroup() *StepMatchArgument_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type StepMatchArgument_Group struct {
	Start    uint32                     `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	Value    string                     `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Children []*StepMatchArgument_Group `protobuf:"bytes,3,rep,name=children,proto3" json:"children,omitempty"`
}

func (m *StepMatchArgument_Group) Reset()         { *m = StepMatchArgument_Group{} }
func (m *StepMatchArgument_Group) String() string { return proto.CompactTextString(m) }
func (*StepMatchArgument_Group) ProtoMessage()    {}
func (*StepMatchArgument_Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{44, 0}
}
func (m *StepMatchArgument_Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepMatchArgument_Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepMatchArgument_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepMatchArgument_Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepMatchArgument_Group.Merge(m, src)
}
func (m *StepMatchArgument_Group) XXX_Size() int {
	return m.Size()
}
func (m *StepMatchArgument_Group) XXX_DiscardUnknown() {
	xxx_messageInfo_StepMatchArgument_Group.DiscardUnknown(m)
}

var xxx_messageInfo_StepMatchArgument_Group proto.InternalMessageInfo

func (m *StepMatchArgument_Group) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *StepMatchArgument_Group) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *StepMatchArgument_Group) GetChildren() []*StepMatchArgument_Group {
	if m != nil {
		return m.Children
	}
	return nil
}

type CommandGenerateSnippet struct {
	ActionId             string                 `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	GeneratedExpressions []*GeneratedExpression `protobuf:"bytes,2,rep,name=generatedExpressions,proto3" json:"generatedExpressions,omitempty"`
	PickleStepArgument   *PickleStepArgument    `protobuf:"bytes,5,opt,name=pickleStepArgument,proto3" json:"pickleStepArgument,omitempty"`
}

func (m *CommandGenerateSnippet) Reset()         { *m = CommandGenerateSnippet{} }
func (m *CommandGenerateSnippet) String() string { return proto.CompactTextString(m) }
func (*CommandGenerateSnippet) ProtoMessage()    {}
func (*CommandGenerateSnippet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{45}
}
func (m *CommandGenerateSnippet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandGenerateSnippet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandGenerateSnippet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommandGenerateSnippet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandGenerateSnippet.Merge(m, src)
}
func (m *CommandGenerateSnippet) XXX_Size() int {
	return m.Size()
}
func (m *CommandGenerateSnippet) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandGenerateSnippet.DiscardUnknown(m)
}

var xxx_messageInfo_CommandGenerateSnippet proto.InternalMessageInfo

func (m *CommandGenerateSnippet) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandGenerateSnippet) GetGeneratedExpressions() []*GeneratedExpression {
	if m != nil {
		return m.GeneratedExpressions
	}
	return nil
}

func (m *CommandGenerateSnippet) GetPickleStepArgument() *PickleStepArgument {
	if m != nil {
		return m.PickleStepArgument
	}
	return nil
}

type GeneratedExpression struct {
	Text               string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	ParameterTypeNames []string `protobuf:"bytes,2,rep,name=parameterTypeNames,proto3" json:"parameterTypeNames,omitempty"`
}

func (m *GeneratedExpression) Reset()         { *m = GeneratedExpression{} }
func (m *GeneratedExpression) String() string { return proto.CompactTextString(m) }
func (*GeneratedExpression) ProtoMessage()    {}
func (*GeneratedExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dc296cbfe5ffcd5, []int{46}
}
func (m *GeneratedExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneratedExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeneratedExpression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeneratedExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneratedExpression.Merge(m, src)
}
func (m *GeneratedExpression) XXX_Size() int {
	return m.Size()
}
func (m *GeneratedExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneratedExpression.DiscardUnknown(m)
}

var xxx_messageInfo_GeneratedExpression proto.InternalMessageInfo

func (m *GeneratedExpression) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *GeneratedExpression) GetParameterTypeNames() []string {
	if m != nil {
		return m.ParameterTypeNames
	}
	return nil
}

func init() {
	proto.RegisterEnum("io.cucumber.messages.SourcesOrderType", SourcesOrderType_name, SourcesOrderType_value)
	proto.RegisterEnum("io.cucumber.messages.StepDefinitionPatternType", StepDefinitionPatternType_name, StepDefinitionPatternType_value)
	proto.RegisterEnum("io.cucumber.messages.Media_Encoding", Media_Encoding_name, Media_Encoding_value)
	proto.RegisterEnum("io.cucumber.messages.TestResult_Status", TestResult_Status_name, TestResult_Status_value)
	proto.RegisterType((*Timestamp)(nil), "io.cucumber.messages.Timestamp")
	proto.RegisterType((*Duration)(nil), "io.cucumber.messages.Duration")
	proto.RegisterType((*Envelope)(nil), "io.cucumber.messages.Envelope")
	proto.RegisterType((*Location)(nil), "io.cucumber.messages.Location")
	proto.RegisterType((*SourceReference)(nil), "io.cucumber.messages.SourceReference")
	proto.RegisterType((*Media)(nil), "io.cucumber.messages.Media")
	proto.RegisterType((*Source)(nil), "io.cucumber.messages.Source")
	proto.RegisterType((*GherkinDocument)(nil), "io.cucumber.messages.GherkinDocument")
	proto.RegisterType((*GherkinDocument_Comment)(nil), "io.cucumber.messages.GherkinDocument.Comment")
	proto.RegisterType((*GherkinDocument_Feature)(nil), "io.cucumber.messages.GherkinDocument.Feature")
	proto.RegisterType((*GherkinDocument_Feature_Tag)(nil), "io.cucumber.messages.GherkinDocument.Feature.Tag")
	proto.RegisterType((*GherkinDocument_Feature_FeatureChild)(nil), "io.cucumber.messages.GherkinDocument.Feature.FeatureChild")
	proto.RegisterType((*GherkinDocument_Feature_FeatureChild_Rule)(nil), "io.cucumber.messages.GherkinDocument.Feature.FeatureChild.Rule")
	proto.RegisterType((*GherkinDocument_Feature_FeatureChild_RuleChild)(nil), "io.cucumber.messages.GherkinDocument.Feature.FeatureChild.RuleChild")
	proto.RegisterType((*GherkinDocument_Feature_Background)(nil), "io.cucumber.messages.GherkinDocument.Feature.Background")
	proto.RegisterType((*GherkinDocument_Feature_Scenario)(nil), "io.cucumber.messages.GherkinDocument.Feature.Scenario")
	proto.RegisterType((*GherkinDocument_Feature_Scenario_Examples)(nil), "io.cucumber.messages.GherkinDocument.Feature.Scenario.Examples")
	proto.RegisterType((*GherkinDocument_Feature_TableRow)(nil), "io.cucumber.messages.GherkinDocument.Feature.TableRow")
	proto.RegisterType((*GherkinDocument_Feature_TableRow_TableCell)(nil), "io.cucumber.messages.GherkinDocument.Feature.TableRow.TableCell")
	proto.RegisterType((*GherkinDocument_Feature_Step)(nil), "io.cucumber.messages.GherkinDocument.Feature.Step")
	proto.RegisterType((*GherkinDocument_Feature_Step_DataTable)(nil), "io.cucumber.messages.GherkinDocument.Feature.Step.DataTable")
	proto.RegisterType((*GherkinDocument_Feature_Step_DocString)(nil), "io.cucumber.messages.GherkinDocument.Feature.Step.DocString")
	proto.RegisterType((*Attachment)(nil), "io.cucumber.messages.Attachment")
	proto.RegisterType((*Pickle)(nil), "io.cucumber.messages.Pickle")
	proto.RegisterType((*Pickle_PickleTag)(nil), "io.cucumber.messages.Pickle.PickleTag")
	proto.RegisterType((*Pickle_PickleStep)(nil), "io.cucumber.messages.Pickle.PickleStep")
	proto.RegisterType((*PickleStepArgument)(nil), "io.cucumber.messages.PickleStepArgument")
	proto.RegisterType((*PickleStepArgument_PickleDocString)(nil), "io.cucumber.messages.PickleStepArgument.PickleDocString")
	proto.RegisterType((*PickleStepArgument_PickleTable)(nil), "io.cucumber.messages.PickleStepArgument.PickleTable")
	proto.RegisterType((*PickleStepArgument_PickleTable_PickleTableRow)(nil), "io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow")
	proto.RegisterType((*PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell)(nil), "io.cucumber.messages.PickleStepArgument.PickleTable.PickleTableRow.PickleTableCell")
	proto.RegisterType((*TestCase)(nil), "io.cucumber.messages.TestCase")
	proto.RegisterType((*TestCase_TestStep)(nil), "io.cucumber.messages.TestCase.TestStep")
	proto.RegisterType((*PickleAccepted)(nil), "io.cucumber.messages.PickleAccepted")
	proto.RegisterType((*PickleRejected)(nil), "io.cucumber.messages.PickleRejected")
	proto.RegisterType((*TestRunStarted)(nil), "io.cucumber.messages.TestRunStarted")
	proto.RegisterType((*TestCasePreparedStep)(nil), "io.cucumber.messages.TestCasePreparedStep")
	proto.RegisterType((*TestCasePrepared)(nil), "io.cucumber.messages.TestCasePrepared")
	proto.RegisterType((*TestCaseStarted)(nil), "io.cucumber.messages.TestCaseStarted")
	proto.RegisterType((*TestCaseStarted_Platform)(nil), "io.cucumber.messages.TestCaseStarted.Platform")
	proto.RegisterType((*TestCaseFinished)(nil), "io.cucumber.messages.TestCaseFinished")
	proto.RegisterType((*TestStepMatched)(nil), "io.cucumber.messages.TestStepMatched")
	proto.RegisterType((*TestStepStarted)(nil), "io.cucumber.messages.TestStepStarted")
	proto.RegisterType((*TestStepFinished)(nil), "io.cucumber.messages.TestStepFinished")
	proto.RegisterType((*TestHookStarted)(nil), "io.cucumber.messages.TestHookStarted")
	proto.RegisterType((*TestHookFinished)(nil), "io.cucumber.messages.TestHookFinished")
	proto.RegisterType((*TestResult)(nil), "io.cucumber.messages.TestResult")
	proto.RegisterType((*TestRunFinished)(nil), "io.cucumber.messages.TestRunFinished")
	proto.RegisterType((*CommandStart)(nil), "io.cucumber.messages.CommandStart")
	proto.RegisterType((*SourcesConfig)(nil), "io.cucumber.messages.SourcesConfig")
	proto.RegisterType((*SourcesFilterConfig)(nil), "io.cucumber.messages.SourcesFilterConfig")
	proto.RegisterType((*UriToLinesMapping)(nil), "io.cucumber.messages.UriToLinesMapping")
	proto.RegisterType((*SourcesOrder)(nil), "io.cucumber.messages.SourcesOrder")
	proto.RegisterType((*RuntimeConfig)(nil), "io.cucumber.messages.RuntimeConfig")
	proto.RegisterType((*SupportCodeConfig)(nil), "io.cucumber.messages.SupportCodeConfig")
	proto.RegisterType((*TestCaseHookDefinitionConfig)(nil), "io.cucumber.messages.TestCaseHookDefinitionConfig")
	proto.RegisterType((*StepDefinitionConfig)(nil), "io.cucumber.messages.StepDefinitionConfig")
	proto.RegisterType((*StepDefinitionPattern)(nil), "io.cucumber.messages.StepDefinitionPattern")
	proto.RegisterType((*ParameterTypeConfig)(nil), "io.cucumber.messages.ParameterTypeConfig")
	proto.RegisterType((*CommandActionComplete)(nil), "io.cucumber.messages.CommandActionComplete")
	proto.RegisterType((*CommandRunBeforeTestRunHooks)(nil), "io.cucumber.messages.CommandRunBeforeTestRunHooks")
	proto.RegisterType((*CommandRunAfterTestRunHooks)(nil), "io.cucumber.messages.CommandRunAfterTestRunHooks")
	proto.RegisterType((*CommandInitializeTestCase)(nil), "io.cucumber.messages.CommandInitializeTestCase")
	proto.RegisterType((*CommandRunBeforeTestCaseHook)(nil), "io.cucumber.messages.CommandRunBeforeTestCaseHook")
	proto.RegisterType((*CommandRunAfterTestCaseHook)(nil), "io.cucumber.messages.CommandRunAfterTestCaseHook")
	proto.RegisterType((*CommandRunTestStep)(nil), "io.cucumber.messages.CommandRunTestStep")
	proto.RegisterType((*StepMatchArgument)(nil), "io.cucumber.messages.StepMatchArgument")
	proto.RegisterType((*StepMatchArgument_Group)(nil), "io.cucumber.messages.StepMatchArgument.Group")
	proto.RegisterType((*CommandGenerateSnippet)(nil), "io.cucumber.messages.CommandGenerateSnippet")
	proto.RegisterType((*GeneratedExpression)(nil), "io.cucumber.messages.GeneratedExpression")
}

func init() { proto.RegisterFile("messages.proto", fileDescriptor_4dc296cbfe5ffcd5) }

var fileDescriptor_4dc296cbfe5ffcd5 = []byte{
	// 3486 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5b, 0x4f, 0x6c, 0x1b, 0xc7,
	0xd5, 0xe7, 0xf2, 0xef, 0xf2, 0xc9, 0x92, 0xe9, 0xb1, 0xec, 0xd0, 0xb4, 0xa1, 0xe8, 0xdb, 0x24,
	0x8e, 0x3f, 0x27, 0x61, 0x10, 0x7f, 0x81, 0xbf, 0x7c, 0xfe, 0x12, 0xc4, 0x92, 0x48, 0x89, 0x72,
	0xac, 0x3f, 0x1d, 0x4a, 0x49, 0x9c, 0xc2, 0x55, 0x56, 0xcb, 0x91, 0xbc, 0xf1, 0x72, 0x77, 0xb1,
	0xbb, 0xf4, 0x9f, 0x1e, 0x7a, 0x28, 0xda, 0x43, 0x0f, 0xfd, 0x83, 0xe6, 0xd0, 0x5e, 0x93, 0x02,
	0x3d, 0x14, 0x28, 0x90, 0x43, 0x51, 0xa0, 0x68, 0xd1, 0x5b, 0x8b, 0xa2, 0x45, 0x81, 0x1c, 0x0b,
	0xa4, 0x87, 0xd4, 0xb9, 0xf5, 0xda, 0x5e, 0x7a, 0x28, 0x50, 0xcc, 0xbf, 0xe5, 0x2e, 0xb9, 0x5c,
	0x91, 0xa2, 0x53, 0x04, 0x3d, 0x89, 0x33, 0xfb, 0xde, 0x6f, 0xde, 0xbc, 0xf7, 0xe6, 0xcd, 0x7b,
	0x33, 0x23, 0x98, 0xeb, 0x12, 0xdf, 0xd7, 0x0f, 0x89, 0x5f, 0x77, 0x3d, 0x27, 0x70, 0xd0, 0xbc,
	0xe9, 0xd4, 0x8d, 0x9e, 0xd1, 0xeb, 0xee, 0x13, 0xaf, 0x2e, 0xbf, 0x69, 0xff, 0x0f, 0xe5, 0x1d,
	0xb3, 0x4b, 0xfc, 0x40, 0xef, 0xba, 0xa8, 0x0a, 0x25, 0x9f, 0x18, 0x8e, 0xdd, 0xf1, 0xab, 0xca,
	0xa2, 0x72, 0x29, 0x87, 0x65, 0x13, 0xcd, 0x43, 0xc1, 0xd6, 0x6d, 0xc7, 0xaf, 0x66, 0x17, 0x95,
	0x4b, 0x05, 0xcc, 0x1b, 0xda, 0x35, 0x50, 0x1b, 0x3d, 0x4f, 0x0f, 0x4c, 0xc7, 0x9e, 0x98, 0xf7,
	0xa7, 0x08, 0xd4, 0xa6, 0x7d, 0x8f, 0x58, 0x8e, 0x4b, 0xd0, 0x55, 0x28, 0xfa, 0x4e, 0xcf, 0x33,
	0x08, 0xe3, 0x9d, 0xb9, 0x72, 0xa1, 0x9e, 0x24, 0x6c, 0xbd, 0xcd, 0x68, 0x5a, 0x19, 0x2c, 0xa8,
	0xd1, 0x97, 0xe0, 0xe4, 0xe1, 0x1d, 0xe2, 0xdd, 0x35, 0xed, 0x86, 0x63, 0xf4, 0xba, 0xc4, 0x0e,
	0xd8, 0x20, 0x33, 0x57, 0x9e, 0x49, 0x06, 0x58, 0x8b, 0x13, 0xb7, 0x32, 0x78, 0x90, 0x9f, 0x8a,
	0xe2, 0x9a, 0xc6, 0x5d, 0x8b, 0x54, 0x73, 0x69, 0xa2, 0x6c, 0x33, 0x1a, 0x2a, 0x0a, 0xa7, 0x46,
	0xcb, 0x00, 0x7a, 0x10, 0xe8, 0xc6, 0x1d, 0x26, 0x45, 0x9e, 0xf1, 0x2e, 0x26, 0xf3, 0x2e, 0x85,
	0x74, 0xad, 0x0c, 0x8e, 0x70, 0xd1, 0xe9, 0x04, 0xc4, 0x0f, 0x56, 0x74, 0x9f, 0xb4, 0x03, 0xdd,
	0x0b, 0x48, 0xa7, 0x5a, 0x48, 0x9b, 0xce, 0x4e, 0x9c, 0x98, 0x4e, 0x67, 0x80, 0x5f, 0x42, 0xb6,
	0x03, 0xe2, 0x4a, 0xc8, 0xe2, 0x51, 0x90, 0x11, 0x62, 0x09, 0x19, 0xe9, 0x42, 0x3b, 0x50, 0x91,
	0x5d, 0xab, 0xa6, 0x6d, 0xfa, 0x77, 0x48, 0xa7, 0x5a, 0x62, 0x98, 0x17, 0xd3, 0x31, 0x25, 0x75,
	0x2b, 0x83, 0x87, 0x10, 0x24, 0x2a, 0x95, 0x3d, 0x44, 0x55, 0x8f, 0x42, 0x8d, 0x52, 0x4b, 0xd4,
	0x68, 0x9f, 0x9c, 0x7e, 0xcb, 0x71, 0xee, 0xca, 0xe9, 0x97, 0x8f, 0x9a, 0x7e, 0x84, 0x58, 0x4e,
	0x3f, 0xd2, 0x25, 0x05, 0xa5, 0x5d, 0xa1, 0xa0, 0x70, 0x94, 0xa0, 0x51, 0x6a, 0x29, 0x68, 0xb4,
	0x0f, 0x6d, 0xc2, 0x1c, 0x77, 0xa4, 0x25, 0xc3, 0x20, 0x2e, 0x95, 0x73, 0x86, 0x61, 0x3e, 0x9d,
	0xe6, 0x7e, 0x92, 0xb6, 0x95, 0xc1, 0x03, 0xdc, 0x7d, 0x3c, 0x4c, 0xde, 0x23, 0x06, 0xc5, 0x3b,
	0x71, 0x34, 0x9e, 0xa4, 0xed, 0xe3, 0xc9, 0x9e, 0xa8, 0x79, 0xb6, 0x3d, 0xe2, 0xea, 0x1e, 0xe9,
	0x54, 0x67, 0xc7, 0x31, 0x8f, 0xa4, 0x8e, 0x9a, 0x47, 0xf6, 0x51, 0x29, 0x69, 0x1f, 0xee, 0xd9,
	0xd2, 0x3a, 0x73, 0x69, 0x52, 0xee, 0xc4, 0x68, 0xa9, 0x94, 0x71, 0x6e, 0x69, 0x6e, 0xdc, 0xb3,
	0x43, 0xd3, 0x9c, 0x3c, 0xca, 0xdc, 0x11, 0x62, 0x69, 0xee, 0x48, 0x17, 0x6a, 0xc1, 0x09, 0xc3,
	0xe9, 0x76, 0x75, 0xbb, 0xc3, 0x06, 0xa9, 0x56, 0x18, 0x9e, 0x96, 0x8c, 0xb7, 0x12, 0xa1, 0x6c,
	0x65, 0x70, 0x8c, 0x13, 0x19, 0x70, 0x46, 0xb4, 0x97, 0x0c, 0x1a, 0x32, 0x57, 0x9c, 0xae, 0x6b,
	0x91, 0x80, 0x54, 0x4f, 0x31, 0xc8, 0xe7, 0x52, 0x21, 0xe3, 0x2c, 0xad, 0x0c, 0x4e, 0xc6, 0x42,
	0x0f, 0xe0, 0x82, 0xf8, 0x80, 0x7b, 0xf6, 0x32, 0x39, 0x70, 0x3c, 0x22, 0x26, 0x49, 0xdd, 0xcd,
	0xaf, 0x22, 0x36, 0xd6, 0x95, 0xd4, 0xb1, 0x12, 0x39, 0x5b, 0x19, 0x9c, 0x8a, 0x8c, 0x1c, 0x38,
	0x27, 0xbe, 0xaf, 0xdb, 0x66, 0x60, 0xea, 0x96, 0xf9, 0x55, 0x22, 0x9d, 0xa0, 0x7a, 0x9a, 0x0d,
	0xfb, 0x62, 0xea, 0xb0, 0xc3, 0x6c, 0xad, 0x0c, 0x1e, 0x8d, 0x39, 0x6a, 0xaa, 0x8c, 0xd1, 0x71,
	0xee, 0x56, 0xe7, 0x27, 0x9d, 0xaa, 0xe4, 0x1c, 0x35, 0x55, 0xf9, 0x1d, 0xbd, 0x03, 0xa8, 0xff,
	0x5d, 0x46, 0xb7, 0xea, 0x19, 0x36, 0xde, 0xa5, 0xa3, 0xc6, 0x93, 0xf4, 0xad, 0x0c, 0x4e, 0x40,
	0x41, 0x3d, 0x38, 0xdf, 0xef, 0x5d, 0x3a, 0x08, 0x88, 0x17, 0x9b, 0xd4, 0x59, 0x36, 0xc8, 0x4b,
	0x47, 0x0d, 0x32, 0xc4, 0xd8, 0xca, 0xe0, 0x34, 0xdc, 0x11, 0xc3, 0x86, 0x6e, 0xf3, 0xc4, 0x84,
	0xc3, 0x46, 0xbc, 0x26, 0x0d, 0x17, 0x1d, 0xc0, 0x59, 0xf1, 0x79, 0x8d, 0xd8, 0xc4, 0xd3, 0x03,
	0xd2, 0xb6, 0x4d, 0xd7, 0x25, 0x41, 0xb5, 0xca, 0x46, 0x7c, 0x3e, 0x75, 0xc4, 0x01, 0x9e, 0x56,
	0x06, 0x8f, 0x40, 0x43, 0x4f, 0x87, 0xab, 0xb8, 0xe9, 0x79, 0x8e, 0x57, 0x3d, 0xb7, 0xa8, 0x5c,
	0x2a, 0x47, 0x56, 0x28, 0xeb, 0x8d, 0x6e, 0x96, 0x1b, 0x7a, 0x60, 0xd0, 0xf0, 0x51, 0x1b, 0x67,
	0xb3, 0x14, 0xc4, 0xd1, 0xcd, 0x52, 0x74, 0xa1, 0x57, 0x41, 0x95, 0x51, 0xaf, 0x7a, 0x9e, 0x61,
	0x2d, 0xa4, 0xc7, 0xcb, 0x56, 0x06, 0x87, 0x1c, 0xcb, 0x65, 0x28, 0x09, 0x02, 0xed, 0x2a, 0xa8,
	0x37, 0x1d, 0x83, 0xe7, 0x5a, 0x08, 0xf2, 0x96, 0x69, 0xf3, 0x64, 0x69, 0x16, 0xb3, 0xdf, 0xe8,
	0x2c, 0x14, 0x0d, 0xc7, 0xea, 0x75, 0x6d, 0x96, 0x01, 0xcd, 0x62, 0xd1, 0xd2, 0xf6, 0xe0, 0x24,
	0x4f, 0x9b, 0x30, 0x39, 0x20, 0x1e, 0xb1, 0x0d, 0x82, 0x2a, 0x90, 0xeb, 0x79, 0x26, 0xe3, 0x2e,
	0x63, 0xfa, 0x13, 0x5d, 0x03, 0xd5, 0x12, 0xe0, 0x22, 0x81, 0x1a, 0x21, 0xa5, 0x14, 0x01, 0x87,
	0xf4, 0xda, 0x77, 0x14, 0x28, 0x6c, 0x90, 0x8e, 0xa9, 0xa3, 0xeb, 0xa0, 0x12, 0xdb, 0x70, 0x3a,
	0xa6, 0x7d, 0xc8, 0xc0, 0xe7, 0x46, 0xc5, 0x71, 0x46, 0x5e, 0x6f, 0x0a, 0x5a, 0x1c, 0x72, 0xa1,
	0xff, 0xa2, 0x66, 0xb2, 0x03, 0x62, 0x07, 0x7b, 0xc1, 0x43, 0x97, 0x30, 0x59, 0xca, 0x78, 0x46,
	0xf4, 0xed, 0x3c, 0x74, 0x89, 0xb6, 0x48, 0xd3, 0x46, 0x41, 0x0e, 0x50, 0x5c, 0x5e, 0x6a, 0x37,
	0xaf, 0xbe, 0x5c, 0xc9, 0x20, 0x15, 0xf2, 0xbb, 0x3b, 0xab, 0xaf, 0x54, 0x14, 0x4d, 0x87, 0x22,
	0x9f, 0x71, 0xc2, 0x44, 0x11, 0xe4, 0x3b, 0x7a, 0xa0, 0x0b, 0x60, 0xf6, 0x1b, 0xbd, 0x04, 0x85,
	0x2e, 0x15, 0x48, 0x24, 0x7c, 0xe7, 0x53, 0x64, 0xc6, 0x9c, 0x52, 0xfb, 0x4d, 0x0d, 0x4e, 0x0e,
	0xe4, 0x92, 0x09, 0x83, 0xad, 0x41, 0xe9, 0x80, 0xe8, 0x41, 0xcf, 0x23, 0x42, 0xa9, 0x2f, 0x8c,
	0x95, 0x95, 0xd6, 0x57, 0x39, 0x13, 0x96, 0xdc, 0x68, 0x1d, 0x54, 0xea, 0xa7, 0xc4, 0x0e, 0xfc,
	0x6a, 0x6e, 0x31, 0x37, 0x3e, 0xd2, 0x0a, 0xe7, 0xc2, 0x21, 0x7b, 0xed, 0x16, 0x94, 0x44, 0x67,
	0xcc, 0xe8, 0xca, 0x64, 0x46, 0xa7, 0x7a, 0x0c, 0xc8, 0x83, 0x40, 0xea, 0x91, 0xfe, 0xae, 0x7d,
	0x54, 0x85, 0x92, 0x10, 0x7d, 0x2a, 0xec, 0x26, 0xe4, 0x03, 0xfd, 0x90, 0x96, 0x0b, 0xb9, 0xd1,
	0x31, 0x67, 0x84, 0xce, 0xea, 0x3b, 0xfa, 0x21, 0x66, 0xec, 0xa8, 0x06, 0xaa, 0xa5, 0xdb, 0x87,
	0x3d, 0xfd, 0x90, 0xa7, 0xf2, 0x65, 0x1c, 0xb6, 0x69, 0xb1, 0x72, 0x97, 0x3c, 0xbc, 0xef, 0x78,
	0x1d, 0x96, 0xa9, 0x97, 0xb1, 0x6c, 0xd2, 0x89, 0xd9, 0x7a, 0x97, 0xb0, 0xbc, 0xbb, 0x8c, 0xd9,
	0x6f, 0xb4, 0x08, 0x33, 0x1d, 0xe2, 0x1b, 0x9e, 0xe9, 0xb2, 0xf9, 0x14, 0xb9, 0x53, 0x46, 0xba,
	0xd0, 0x9b, 0xa0, 0x1a, 0x77, 0x4c, 0xab, 0xe3, 0x11, 0xbb, 0x5a, 0x62, 0x62, 0x5f, 0x9b, 0x4c,
	0x6c, 0xf1, 0x77, 0x85, 0x82, 0xe0, 0x10, 0xab, 0xb6, 0x0b, 0xb9, 0x1d, 0xfd, 0x70, 0x5a, 0x4b,
	0xb1, 0x09, 0x65, 0xfb, 0x13, 0xaa, 0x7d, 0x5a, 0x80, 0x13, 0xd1, 0x11, 0xd1, 0x2e, 0xe4, 0xbd,
	0x9e, 0x25, 0xab, 0xaf, 0xd7, 0x8f, 0x2f, 0x7b, 0x1d, 0xf7, 0x58, 0x55, 0xc4, 0xe0, 0xd0, 0x3b,
	0x00, 0xfb, 0xba, 0x71, 0xf7, 0xd0, 0x73, 0x7a, 0x76, 0x47, 0xac, 0x81, 0x57, 0x26, 0x03, 0x5f,
	0x0e, 0xf9, 0x69, 0xad, 0xd4, 0x47, 0x43, 0x3b, 0xa0, 0xfa, 0x06, 0xb1, 0x75, 0xcf, 0x74, 0xc4,
	0xc2, 0xbd, 0x3a, 0x19, 0x72, 0x5b, 0x70, 0xd3, 0x80, 0x2b, 0x91, 0x6a, 0x7f, 0x57, 0x20, 0x4f,
	0xa7, 0x30, 0x95, 0xca, 0x23, 0xde, 0x95, 0x4d, 0xf6, 0xae, 0xdc, 0x68, 0xef, 0xca, 0x0f, 0x7b,
	0xd7, 0xbb, 0x11, 0xef, 0x2a, 0x30, 0xef, 0x6a, 0x4c, 0x69, 0xa1, 0x41, 0x3f, 0xfb, 0xad, 0x02,
	0xe5, 0xb0, 0x7f, 0xc0, 0x6c, 0xca, 0xe7, 0x66, 0xb6, 0xec, 0xe3, 0x32, 0xdb, 0x72, 0x09, 0x0a,
	0xf7, 0x74, 0xab, 0x47, 0xc2, 0x1f, 0xb5, 0x47, 0x0a, 0x40, 0x5f, 0x88, 0x2f, 0x94, 0x39, 0x5b,
	0x50, 0xf0, 0x03, 0xe2, 0xfa, 0xc2, 0x96, 0x57, 0x26, 0x9c, 0x7f, 0x40, 0x5c, 0xcc, 0x01, 0x6a,
	0x3f, 0x2e, 0x82, 0x2a, 0xf5, 0xf1, 0x45, 0x08, 0xb9, 0x11, 0x4d, 0xe5, 0x92, 0x35, 0x95, 0x1f,
	0xad, 0xa9, 0x42, 0x8a, 0xa6, 0x8a, 0x53, 0x6a, 0x0a, 0x7d, 0x19, 0x54, 0xf2, 0x40, 0xa7, 0x35,
	0x92, 0x2f, 0x02, 0xf4, 0xeb, 0xc7, 0x73, 0xbb, 0x7a, 0x53, 0xc0, 0xe0, 0x10, 0x10, 0xcd, 0x41,
	0xd6, 0xe4, 0x87, 0x15, 0x65, 0x9c, 0x35, 0x3b, 0xb5, 0xef, 0xe6, 0x40, 0x95, 0x64, 0xff, 0x89,
	0x66, 0xb9, 0x05, 0x27, 0x02, 0x7d, 0xdf, 0x22, 0x7b, 0x77, 0x88, 0xde, 0x21, 0x9e, 0x38, 0x50,
	0xba, 0x3a, 0xa9, 0x78, 0xfb, 0x16, 0xc1, 0xce, 0x7d, 0x3c, 0xc3, 0xb0, 0x5a, 0x0c, 0x0a, 0xed,
	0x02, 0x70, 0xe8, 0x7d, 0xa7, 0xf3, 0x50, 0x58, 0xea, 0xb8, 0xc0, 0x65, 0x86, 0xb4, 0xec, 0x74,
	0x1e, 0xd6, 0xbe, 0x9d, 0x05, 0x55, 0xf6, 0x4f, 0x65, 0x91, 0x37, 0xa1, 0x60, 0x10, 0xcb, 0x92,
	0x26, 0xb9, 0x7e, 0x3c, 0xd1, 0xf8, 0x8f, 0x15, 0x62, 0x59, 0x98, 0xc3, 0x09, 0x17, 0xca, 0x85,
	0x2e, 0x74, 0x1b, 0xca, 0x21, 0xcd, 0x54, 0x02, 0xcf, 0x8b, 0x80, 0x28, 0x42, 0x97, 0x88, 0x8e,
	0xdf, 0x2c, 0x40, 0x9e, 0x55, 0x9b, 0x9f, 0x5b, 0x5c, 0x64, 0xd9, 0x61, 0xae, 0x9f, 0x1d, 0xa2,
	0xdb, 0x00, 0x1d, 0xc7, 0xd8, 0xf3, 0x03, 0x8f, 0x96, 0x07, 0xfc, 0x58, 0xf3, 0xd5, 0xc9, 0x17,
	0x74, 0xbd, 0xe1, 0x18, 0x6d, 0x86, 0xd1, 0xca, 0xe0, 0x72, 0x47, 0x36, 0x18, 0xbc, 0x1e, 0xe8,
	0x7b, 0xcc, 0xe6, 0xc2, 0x23, 0x8f, 0x05, 0xaf, 0x07, 0x3a, 0xd3, 0x3c, 0x83, 0x97, 0x0d, 0x61,
	0x9f, 0x52, 0x68, 0x9f, 0xf7, 0x15, 0x28, 0x87, 0xa4, 0x53, 0x69, 0xf1, 0x06, 0xe4, 0x3d, 0xe7,
	0xbe, 0x74, 0xa8, 0xe3, 0xfa, 0x3a, 0xc3, 0xa8, 0x7d, 0x48, 0xa5, 0x0a, 0x55, 0x32, 0x8d, 0x54,
	0x47, 0x17, 0x62, 0xd4, 0xfc, 0xa2, 0x29, 0xa3, 0x8a, 0x68, 0xa2, 0x0b, 0x50, 0xee, 0x10, 0xcb,
	0xec, 0x9a, 0x01, 0xf1, 0x44, 0x68, 0xe9, 0x77, 0x2c, 0x03, 0xa8, 0xba, 0x77, 0xc8, 0xe6, 0xa1,
	0x7d, 0x5f, 0x01, 0xe8, 0x9f, 0x86, 0xa3, 0xd7, 0x06, 0xae, 0x01, 0x9e, 0x49, 0xbb, 0x06, 0x08,
	0xeb, 0xd9, 0xf0, 0x36, 0xe0, 0x31, 0x15, 0x77, 0x7f, 0xc9, 0x41, 0x91, 0x9f, 0x87, 0x0a, 0xb3,
	0x2b, 0xd2, 0xec, 0xb2, 0xc6, 0xcb, 0xc6, 0x0a, 0xca, 0xa1, 0x14, 0x20, 0x5a, 0x79, 0xe4, 0x07,
	0x2a, 0x8f, 0xd7, 0xe2, 0x9b, 0xff, 0xb3, 0x69, 0xc7, 0xb1, 0xe2, 0x4f, 0x74, 0x1f, 0xbb, 0x26,
	0x76, 0x04, 0xbe, 0x21, 0x5e, 0x1c, 0x83, 0xbb, 0xbf, 0x0d, 0x5c, 0x80, 0x32, 0x57, 0xd4, 0x7a,
	0xc7, 0xaf, 0xaa, 0x8b, 0x39, 0x6a, 0x96, 0xb0, 0xa3, 0xf6, 0x0c, 0x94, 0x43, 0x86, 0xa4, 0xa2,
	0xe1, 0x46, 0x5e, 0x55, 0x2a, 0xd9, 0xda, 0xaf, 0x15, 0x80, 0xbe, 0x58, 0xe1, 0x4a, 0x57, 0x22,
	0x2b, 0xbd, 0xd1, 0x37, 0xb0, 0x58, 0xe7, 0x97, 0xd2, 0xe4, 0xa4, 0x38, 0x4b, 0x82, 0x1e, 0x87,
	0x9c, 0x42, 0xf5, 0xc5, 0x50, 0xf5, 0x67, 0xa1, 0x48, 0x55, 0xb0, 0x2e, 0x57, 0xa1, 0x68, 0xa5,
	0xcf, 0xea, 0x46, 0x5e, 0xcd, 0x56, 0x72, 0x37, 0xf2, 0x6a, 0xae, 0x92, 0xbf, 0x91, 0x57, 0xf3,
	0x95, 0xc2, 0x8d, 0xbc, 0x5a, 0xaa, 0xa8, 0xda, 0xaf, 0xf2, 0x80, 0x86, 0x87, 0x47, 0xb7, 0x62,
	0x41, 0x2a, 0x35, 0xf3, 0x1d, 0xe6, 0x16, 0x5d, 0x23, 0x02, 0xd4, 0x6e, 0x2c, 0x40, 0xf1, 0xd4,
	0xf7, 0xe5, 0x09, 0xa1, 0x87, 0x03, 0x53, 0xad, 0x0d, 0x27, 0x07, 0x86, 0xa5, 0x1b, 0x78, 0x64,
	0x9d, 0x4e, 0xb4, 0x74, 0x85, 0x91, 0xdf, 0xcf, 0xc2, 0x4c, 0x64, 0x44, 0xf4, 0x96, 0x88, 0x51,
	0x0a, 0xf3, 0xba, 0x95, 0xe3, 0x48, 0x1d, 0xfd, 0xdd, 0x0f, 0x58, 0x3f, 0x51, 0x60, 0x2e, 0xfe,
	0x01, 0x99, 0x72, 0x87, 0xe5, 0x83, 0xb5, 0x1f, 0xc3, 0x60, 0xd1, 0x66, 0x64, 0xd3, 0xad, 0xbd,
	0x20, 0x75, 0xd7, 0xdf, 0x6a, 0x13, 0xb7, 0x4b, 0xae, 0x95, 0xe8, 0x61, 0xdc, 0x27, 0x34, 0x9f,
	0x90, 0xe7, 0xd0, 0x83, 0x41, 0xa2, 0x06, 0x2a, 0xbf, 0x3c, 0x59, 0x97, 0x1b, 0x63, 0xd8, 0x46,
	0x4d, 0x28, 0xcb, 0x13, 0x42, 0x79, 0x94, 0xf3, 0x6c, 0xfa, 0x79, 0x60, 0x78, 0xc8, 0x88, 0xfb,
	0x9c, 0xb5, 0x4f, 0x14, 0x3e, 0x3e, 0x5b, 0x83, 0x83, 0xe3, 0x6b, 0x70, 0xc2, 0x0d, 0xd5, 0x13,
	0xca, 0x10, 0xeb, 0x43, 0x97, 0xa1, 0x42, 0xd7, 0x4f, 0x83, 0x1c, 0x98, 0xb6, 0x49, 0x23, 0xfe,
	0x7a, 0x87, 0x89, 0x53, 0xc6, 0x43, 0xfd, 0xe8, 0x2d, 0x40, 0xbe, 0x3c, 0xd1, 0x94, 0xda, 0xf6,
	0xab, 0xf9, 0x34, 0xe1, 0xdb, 0x83, 0xf4, 0x38, 0x01, 0x82, 0x2e, 0xe9, 0x3b, 0x8e, 0x73, 0x77,
	0xbd, 0x23, 0x92, 0x4c, 0xd1, 0xd2, 0x9e, 0x97, 0x4e, 0x11, 0xde, 0x66, 0x45, 0x55, 0xaa, 0xc4,
	0x55, 0xda, 0xa7, 0x0e, 0xef, 0xaa, 0x52, 0x0c, 0xa0, 0x6d, 0xc1, 0x5c, 0xfc, 0x16, 0x09, 0xbd,
	0x06, 0xe5, 0x40, 0xde, 0x80, 0x8b, 0x25, 0xff, 0xe4, 0x08, 0x93, 0x48, 0x32, 0xdc, 0xe7, 0xd0,
	0x7e, 0xa6, 0xc0, 0xfc, 0xe0, 0x5d, 0x17, 0x33, 0xcb, 0x06, 0xcc, 0xf1, 0x38, 0x74, 0x33, 0xbe,
	0x09, 0x8f, 0xb9, 0xa9, 0x0d, 0x30, 0x53, 0x38, 0x9d, 0x5d, 0xf5, 0xdc, 0x8c, 0x1f, 0xd4, 0x8e,
	0x0b, 0x17, 0x67, 0xd6, 0x5c, 0xa8, 0x0c, 0x4a, 0x9d, 0xa6, 0x65, 0x74, 0x5d, 0xee, 0x5b, 0x3c,
	0x4f, 0xb9, 0x3c, 0xde, 0xa5, 0x5f, 0x64, 0xeb, 0xd2, 0xfe, 0x9c, 0x85, 0x93, 0x03, 0x17, 0xd6,
	0x71, 0xdd, 0x67, 0x27, 0xd5, 0x3d, 0xba, 0x01, 0xaa, 0x6b, 0xe9, 0xc1, 0x81, 0xe3, 0x75, 0xc5,
	0xfe, 0x5e, 0x1f, 0xeb, 0xa2, 0xbc, 0xbe, 0x2d, 0xb8, 0x70, 0xc8, 0x4f, 0x63, 0xa2, 0x1e, 0x04,
	0xa4, 0xeb, 0xf2, 0xcb, 0xfb, 0x59, 0x2c, 0x9b, 0x68, 0x01, 0x40, 0x1e, 0xc8, 0x87, 0xae, 0x1a,
	0xe9, 0x19, 0xdc, 0xa9, 0x6a, 0x36, 0xa8, 0x12, 0x1f, 0x5d, 0x84, 0x39, 0x93, 0xd6, 0x81, 0xd4,
	0xe1, 0xfb, 0x4e, 0x50, 0xc6, 0x03, 0xbd, 0x74, 0xf4, 0x7b, 0xc4, 0xf3, 0xa5, 0x59, 0xcb, 0x58,
	0x36, 0x29, 0xba, 0xe3, 0xcb, 0xca, 0xc0, 0xf1, 0x69, 0x0a, 0x62, 0xb8, 0x3d, 0x91, 0x57, 0xd0,
	0x9f, 0x3c, 0x3a, 0x69, 0x7f, 0x54, 0xfa, 0x16, 0x0d, 0x2f, 0x2f, 0xa7, 0xd4, 0xef, 0x75, 0x3e,
	0x73, 0x4c, 0xfc, 0x9e, 0x15, 0x08, 0x0d, 0x2f, 0xa6, 0xdc, 0xa4, 0x32, 0x3a, 0x1c, 0xe1, 0x41,
	0xcf, 0xc3, 0xa9, 0x81, 0x17, 0x09, 0xa1, 0x0a, 0x87, 0x3f, 0xf0, 0x99, 0xf0, 0x7d, 0x5a, 0xfb,
	0xa7, 0xc2, 0xdd, 0x25, 0x7a, 0x99, 0x92, 0xe6, 0xa0, 0xf3, 0x50, 0x30, 0xed, 0x0e, 0x79, 0x20,
	0xae, 0x3f, 0x78, 0x03, 0xed, 0xc1, 0x13, 0xf1, 0x78, 0x16, 0xae, 0x08, 0x31, 0x9d, 0x31, 0x97,
	0xcf, 0x28, 0x94, 0xcf, 0x2d, 0x38, 0x6a, 0x1f, 0x45, 0xe6, 0x9f, 0xb8, 0x5c, 0x72, 0x13, 0x9b,
	0x53, 0x38, 0xb2, 0xd8, 0x16, 0x22, 0x8e, 0x2c, 0x36, 0x85, 0x44, 0x63, 0x15, 0x8f, 0x32, 0x16,
	0x4f, 0xb0, 0xa8, 0xc9, 0xfe, 0x26, 0x5c, 0x30, 0xf6, 0xae, 0x63, 0x7a, 0x1f, 0x8a, 0xcd, 0x3a,
	0x3f, 0xe5, 0xac, 0x8b, 0xe3, 0xcd, 0xba, 0x34, 0xde, 0xac, 0x0b, 0x95, 0xa2, 0x76, 0x8f, 0xdb,
	0x29, 0xfa, 0x44, 0x64, 0xca, 0x65, 0x17, 0x0f, 0x38, 0xb9, 0xc1, 0x80, 0x23, 0x16, 0xfc, 0x2f,
	0x84, 0xb6, 0x63, 0xcf, 0x48, 0xe2, 0xda, 0xce, 0x4e, 0xab, 0xed, 0xdc, 0x94, 0xb2, 0xe7, 0x47,
	0xc8, 0xfe, 0xf3, 0x2c, 0x40, 0x7f, 0x7c, 0xf4, 0x3a, 0xcd, 0xed, 0xf5, 0xa0, 0xe7, 0x8b, 0x6b,
	0xc3, 0x67, 0x8f, 0x92, 0xb8, 0xde, 0x66, 0xe4, 0x58, 0xb0, 0xd1, 0xf0, 0x29, 0xa8, 0x64, 0xf8,
	0x14, 0x4d, 0x5a, 0x04, 0x77, 0xc4, 0x13, 0x35, 0xe1, 0x3b, 0x23, 0x8a, 0x60, 0xf9, 0x90, 0x0d,
	0x87, 0xf4, 0xe8, 0x69, 0x98, 0xbd, 0x6f, 0x5a, 0xd6, 0x32, 0xc1, 0x24, 0xf0, 0x4c, 0xf1, 0x18,
	0x4b, 0xc5, 0xf1, 0x4e, 0x8d, 0x40, 0x91, 0x4b, 0x83, 0x66, 0xa0, 0xb4, 0xbb, 0xf9, 0xc6, 0xe6,
	0xd6, 0x5b, 0x9b, 0x95, 0x0c, 0x02, 0x28, 0x6e, 0x2f, 0xb5, 0xdb, 0xcd, 0x46, 0x45, 0xa1, 0x1f,
	0xda, 0x6f, 0xac, 0x6f, 0x6f, 0x37, 0x1b, 0x95, 0x2c, 0x6d, 0x6c, 0x37, 0x37, 0x1b, 0xeb, 0x9b,
	0x6b, 0x95, 0x1c, 0x9a, 0x85, 0xf2, 0xee, 0x66, 0xa3, 0xb9, 0xba, 0xbe, 0xd9, 0x6c, 0x54, 0xf2,
	0xb4, 0xb9, 0xb4, 0xb1, 0xbc, 0xbe, 0xb6, 0xbb, 0xb5, 0xdb, 0xae, 0x14, 0x28, 0xc6, 0xea, 0xd2,
	0xfa, 0xcd, 0x66, 0xa3, 0x52, 0xe4, 0x35, 0x8c, 0xf6, 0x1e, 0x77, 0xb6, 0xe8, 0x03, 0x95, 0x2a,
	0x94, 0xfc, 0x9e, 0x61, 0x10, 0x9f, 0x6b, 0x4f, 0xc5, 0xb2, 0x39, 0xa5, 0x1b, 0x6a, 0x1f, 0x64,
	0xe1, 0x44, 0xf4, 0x41, 0x0b, 0xd5, 0xc7, 0xbe, 0xee, 0x93, 0x86, 0xe9, 0x11, 0x23, 0x70, 0xbc,
	0x87, 0x42, 0xd7, 0xf1, 0x4e, 0xb4, 0x0e, 0xb3, 0x3c, 0x75, 0xf1, 0x57, 0x1c, 0xfb, 0xc0, 0x3c,
	0x14, 0x4e, 0xf4, 0x54, 0x5a, 0xa0, 0x15, 0xa4, 0x38, 0xce, 0x49, 0xa1, 0xbc, 0x9e, 0x4d, 0x25,
	0x12, 0x50, 0xf9, 0x34, 0x28, 0x1c, 0x25, 0xc5, 0x71, 0x4e, 0xb4, 0x0b, 0xa7, 0xfc, 0x9e, 0xeb,
	0x3a, 0x5e, 0xb0, 0xe2, 0x74, 0x24, 0x1c, 0xaf, 0x4e, 0x47, 0x85, 0xe9, 0x41, 0x72, 0x3c, 0x8c,
	0xa0, 0x7d, 0xac, 0xc0, 0x6c, 0x6c, 0x0a, 0x54, 0x49, 0xfa, 0xbe, 0xef, 0x58, 0xbd, 0x80, 0x6c,
	0xeb, 0xc1, 0x1d, 0x5e, 0xc7, 0x94, 0x71, 0xbc, 0x33, 0x76, 0x44, 0x90, 0x1d, 0x38, 0x22, 0x58,
	0x81, 0xd2, 0x81, 0x69, 0x05, 0xc4, 0xf3, 0x85, 0xea, 0xfe, 0x3b, 0x55, 0x75, 0xab, 0x8c, 0x56,
	0x88, 0x28, 0x39, 0xd1, 0x2b, 0x50, 0x70, 0xbc, 0x8e, 0x38, 0x7f, 0x19, 0xf9, 0x5e, 0x49, 0x40,
	0x6c, 0x51, 0x4a, 0xcc, 0x19, 0xb4, 0xdf, 0x2b, 0x70, 0x3a, 0x01, 0x9a, 0x4e, 0x2c, 0xd0, 0x0f,
	0x9b, 0x0f, 0x5c, 0x8f, 0xf8, 0x7e, 0x3f, 0x93, 0x89, 0x77, 0xa2, 0xab, 0x70, 0xd6, 0xd6, 0xbb,
	0x04, 0x93, 0xc3, 0x9e, 0xa5, 0x7b, 0xfd, 0x0f, 0x3c, 0x71, 0x2c, 0xe3, 0x11, 0x5f, 0xa9, 0x7d,
	0x7a, 0x9e, 0xb9, 0xe3, 0xdc, 0x34, 0x6d, 0xe2, 0x6f, 0xe8, 0xae, 0x4b, 0x0b, 0xf0, 0xd4, 0x02,
	0x69, 0x77, 0x90, 0x1c, 0x0f, 0x23, 0x68, 0x1b, 0x70, 0x6a, 0x88, 0x8e, 0x16, 0x48, 0x51, 0x6b,
	0x88, 0x89, 0xc4, 0xfa, 0x68, 0x3a, 0x61, 0x51, 0x1e, 0x26, 0x76, 0x1e, 0xf3, 0x86, 0xf6, 0x15,
	0x38, 0x11, 0x55, 0x19, 0x3b, 0x8e, 0xa1, 0x35, 0x36, 0x0f, 0x5b, 0x17, 0x8f, 0x56, 0x32, 0x2d,
	0xbf, 0x31, 0xe3, 0x41, 0x08, 0xf2, 0x3e, 0x21, 0xbc, 0x42, 0xc9, 0x63, 0xf6, 0x5b, 0xfb, 0x96,
	0x02, 0xb3, 0x31, 0x37, 0xa6, 0xf1, 0xd4, 0xf4, 0x57, 0x75, 0xd3, 0x5a, 0xd5, 0xfd, 0x40, 0x2c,
	0xf0, 0x48, 0x0f, 0x75, 0x24, 0xd3, 0x6f, 0x78, 0x0f, 0x71, 0x8f, 0x67, 0x8e, 0x2a, 0x0e, 0xdb,
	0xfc, 0x5b, 0x3b, 0xf0, 0x4c, 0x83, 0x6f, 0xbc, 0xec, 0x1b, 0x6f, 0xa3, 0x45, 0x98, 0xe9, 0xea,
	0x0f, 0xb6, 0x75, 0x4f, 0xb7, 0x2c, 0x62, 0x31, 0x2f, 0xc9, 0xe3, 0x68, 0x97, 0xf6, 0x69, 0x0e,
	0x4e, 0x0d, 0xad, 0x01, 0xf4, 0x0d, 0x05, 0x9e, 0xda, 0x1f, 0x7a, 0x11, 0xd5, 0xcf, 0x8c, 0x38,
	0x99, 0xac, 0xde, 0xaf, 0x1c, 0xf1, 0xd6, 0x25, 0x81, 0x15, 0x8f, 0x03, 0x8f, 0xbe, 0xae, 0x80,
	0xa6, 0x0f, 0x3e, 0x62, 0x1a, 0x96, 0x22, 0x7b, 0x6c, 0x29, 0xc6, 0x40, 0x47, 0xef, 0xc2, 0x99,
	0x78, 0x5a, 0x28, 0x87, 0xcd, 0xa5, 0xd5, 0x48, 0xed, 0x04, 0x16, 0x9c, 0x0c, 0x84, 0x6e, 0xc3,
	0xbc, 0xab, 0x7b, 0x7a, 0x97, 0x04, 0xdc, 0x75, 0xe4, 0x00, 0x3c, 0xbf, 0x1c, 0x11, 0x17, 0xb6,
	0x87, 0x39, 0x70, 0x22, 0x8c, 0xf6, 0x03, 0x05, 0x2e, 0xa4, 0x4d, 0x71, 0xe8, 0x68, 0x61, 0x28,
	0x06, 0x64, 0x93, 0x62, 0xc0, 0x52, 0xe4, 0xe0, 0x79, 0xa2, 0x2c, 0xbb, 0xff, 0xa8, 0xe8, 0x23,
	0x05, 0xe6, 0x93, 0x14, 0x35, 0x24, 0x51, 0x13, 0x4a, 0x2e, 0x2d, 0xd4, 0x3c, 0x59, 0x0f, 0x3f,
	0x37, 0x8e, 0xd6, 0xb7, 0x39, 0x0b, 0x96, 0xbc, 0x8f, 0x43, 0xe4, 0x00, 0xce, 0x24, 0x0e, 0xc2,
	0x4e, 0x2e, 0xfb, 0xa7, 0xda, 0xe5, 0xf0, 0xb8, 0x7a, 0x45, 0x04, 0x8f, 0x2c, 0x0b, 0x1e, 0x2f,
	0x4e, 0x20, 0x77, 0x3f, 0x8a, 0x68, 0x7f, 0x50, 0xe0, 0x74, 0x82, 0xc1, 0xc3, 0x13, 0x5c, 0x25,
	0x72, 0x2e, 0x5d, 0x07, 0xe4, 0x8d, 0x8a, 0xcb, 0x09, 0x5f, 0x50, 0x0b, 0x9e, 0x74, 0x3d, 0x3a,
	0xd3, 0x55, 0xc7, 0x1b, 0x0a, 0xd9, 0xac, 0x5c, 0x11, 0x61, 0xe5, 0x28, 0x32, 0x5a, 0x06, 0xf7,
	0x7c, 0xb2, 0xea, 0x78, 0xe2, 0x3d, 0x9e, 0xcf, 0x02, 0x8e, 0x8a, 0x07, 0x7a, 0xb5, 0x1f, 0x29,
	0x70, 0x26, 0xf1, 0xc1, 0x2b, 0x3f, 0xd4, 0xe4, 0xbf, 0x3b, 0x61, 0xf5, 0x17, 0xed, 0x42, 0xcb,
	0xc7, 0x49, 0x7d, 0x5b, 0x99, 0x58, 0xf2, 0x5b, 0x83, 0x92, 0x2f, 0xde, 0x1f, 0xe6, 0xc4, 0x0b,
	0x41, 0xd9, 0xb1, 0xac, 0x42, 0xd1, 0x63, 0x54, 0xda, 0x35, 0xb8, 0x90, 0xf6, 0x52, 0x96, 0xc6,
	0x5d, 0x7e, 0xda, 0xd2, 0x2f, 0x53, 0x65, 0x5b, 0xfb, 0x3f, 0x38, 0x9f, 0xf2, 0x5c, 0x32, 0x95,
	0xd5, 0x87, 0x73, 0x23, 0x5f, 0xca, 0xa6, 0x31, 0xa2, 0x97, 0x27, 0xf9, 0x97, 0x06, 0xf9, 0x0f,
	0x0d, 0xbc, 0xc6, 0xd1, 0x3e, 0x54, 0x92, 0x27, 0x1b, 0x3e, 0x1c, 0x4d, 0x1b, 0xf8, 0x1a, 0x54,
	0x83, 0xc4, 0xf0, 0x12, 0x96, 0x35, 0x23, 0xbf, 0x1f, 0x75, 0xea, 0x12, 0x2b, 0x3c, 0x3f, 0x50,
	0x12, 0xb5, 0xfa, 0x85, 0x92, 0xf1, 0x97, 0x59, 0x40, 0xc3, 0x8f, 0x80, 0x53, 0x45, 0x4b, 0x3e,
	0xa4, 0x55, 0xfe, 0xbd, 0x87, 0xb4, 0x6f, 0x03, 0x72, 0x87, 0x0e, 0xdb, 0xc5, 0x05, 0xeb, 0xf8,
	0xf7, 0x3a, 0x09, 0x18, 0x03, 0xda, 0x2b, 0x8d, 0xd4, 0x1e, 0x2d, 0xb2, 0x7f, 0x98, 0x85, 0x53,
	0x43, 0xf2, 0xd2, 0xd2, 0x3d, 0xb6, 0xaf, 0x6d, 0xf6, 0xef, 0xac, 0x86, 0x3f, 0xa0, 0x15, 0x28,
	0x1c, 0x7a, 0x4e, 0xcf, 0x15, 0x69, 0xff, 0x0b, 0x63, 0x6a, 0xa5, 0xbe, 0x46, 0x99, 0x30, 0xe7,
	0xad, 0x7d, 0x0d, 0x0a, 0xac, 0x4d, 0x13, 0x44, 0x9f, 0xfd, 0x43, 0x00, 0x7f, 0x84, 0xcb, 0x1b,
	0xc9, 0xf7, 0x07, 0xec, 0xfd, 0xa6, 0x7c, 0xc0, 0x95, 0xfa, 0x7e, 0x73, 0xd4, 0xe0, 0x21, 0x7b,
	0x78, 0xfe, 0x10, 0x5e, 0x68, 0x69, 0xff, 0x50, 0xe0, 0x6c, 0xf2, 0x7b, 0xe8, 0x54, 0xe7, 0xba,
	0x0d, 0xf3, 0x87, 0x82, 0xbc, 0x33, 0xb8, 0x1d, 0x8c, 0x4c, 0x2d, 0xd6, 0x86, 0x39, 0x70, 0x22,
	0xcc, 0x08, 0xb7, 0x29, 0x4c, 0xef, 0x36, 0xb1, 0xb9, 0xdf, 0x82, 0xd3, 0x09, 0x22, 0x25, 0xde,
	0x4a, 0xd6, 0x01, 0x0d, 0xb9, 0x44, 0xb8, 0xf9, 0x0d, 0x7f, 0xb9, 0xfc, 0xbf, 0x50, 0x19, 0x4c,
	0xdc, 0xd1, 0x13, 0x70, 0x7a, 0x0b, 0x37, 0x9a, 0x78, 0x6f, 0x6b, 0x75, 0x8f, 0x15, 0xed, 0xeb,
	0x3b, 0xeb, 0x5b, 0xa2, 0xd8, 0xc7, 0x4b, 0x9b, 0x8d, 0xad, 0x8d, 0x8a, 0x72, 0xf9, 0x26, 0x9c,
	0x1b, 0xb9, 0x69, 0x53, 0x84, 0x95, 0xdd, 0x95, 0xdd, 0x8d, 0xe5, 0x26, 0xde, 0x6b, 0xbe, 0xbd,
	0x8d, 0x9b, 0xed, 0x36, 0x47, 0x38, 0x0b, 0x08, 0x37, 0xd7, 0x76, 0x6f, 0x2e, 0xc5, 0xfa, 0x95,
	0xe5, 0xab, 0xbf, 0x7b, 0xb4, 0xa0, 0x7c, 0xfc, 0x68, 0x41, 0xf9, 0xf4, 0xd1, 0x82, 0xf2, 0xbd,
	0xcf, 0x16, 0x32, 0x1f, 0x7f, 0xb6, 0x90, 0xf9, 0xd3, 0x67, 0x0b, 0x99, 0x77, 0x54, 0xa9, 0xb8,
	0xbf, 0x66, 0x4f, 0xad, 0x48, 0x65, 0x6e, 0x88, 0xbe, 0xfd, 0x22, 0xfb, 0xa7, 0xbf, 0xff, 0xf9,
	0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x52, 0x74, 0x93, 0x42, 0x06, 0x38, 0x00, 0x00,
}

func (m *Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nanos != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Nanos))
		i--
		dAtA[i] = 0x10
	}
	if m.Seconds != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Duration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Duration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Duration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nanos != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Nanos))
		i--
		dAtA[i] = 0x10
	}
	if m.Seconds != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Seconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Envelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Envelope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size := m.Message.Size()
			i -= size
			if _, err := m.Message.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Envelope_Source) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_GherkinDocument) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_GherkinDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.GherkinDocument != nil {
		{
			size, err := m.GherkinDocument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_Pickle) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_Pickle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Pickle != nil {
		{
			size, err := m.Pickle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_Attachment) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_Attachment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Attachment != nil {
		{
			size, err := m.Attachment.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestCaseStarted) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestCaseStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestCaseStarted != nil {
		{
			size, err := m.TestCaseStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestStepStarted) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestStepStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestStepStarted != nil {
		{
			size, err := m.TestStepStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestStepFinished) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestStepFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestStepFinished != nil {
		{
			size, err := m.TestStepFinished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestCaseFinished) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestCaseFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestCaseFinished != nil {
		{
			size, err := m.TestCaseFinished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestHookStarted) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestHookStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestHookStarted != nil {
		{
			size, err := m.TestHookStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestHookFinished) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestHookFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestHookFinished != nil {
		{
			size, err := m.TestHookFinished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_PickleAccepted) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_PickleAccepted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PickleAccepted != nil {
		{
			size, err := m.PickleAccepted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_PickleRejected) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_PickleRejected) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PickleRejected != nil {
		{
			size, err := m.PickleRejected.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestCasePrepared) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestCasePrepared) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestCasePrepared != nil {
		{
			size, err := m.TestCasePrepared.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestRunStarted) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestRunStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestRunStarted != nil {
		{
			size, err := m.TestRunStarted.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestRunFinished) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestRunFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestRunFinished != nil {
		{
			size, err := m.TestRunFinished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_CommandStart) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_CommandStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CommandStart != nil {
		{
			size, err := m.CommandStart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_CommandActionComplete) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_CommandActionComplete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CommandActionComplete != nil {
		{
			size, err := m.CommandActionComplete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_CommandRunBeforeTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_CommandRunBeforeTestRunHooks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CommandRunBeforeTestRunHooks != nil {
		{
			size, err := m.CommandRunBeforeTestRunHooks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_CommandInitializeTestCase) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_CommandInitializeTestCase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CommandInitializeTestCase != nil {
		{
			size, err := m.CommandInitializeTestCase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_CommandRunBeforeTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_CommandRunBeforeTestCaseHook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CommandRunBeforeTestCaseHook != nil {
		{
			size, err := m.CommandRunBeforeTestCaseHook.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_CommandRunTestStep) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_CommandRunTestStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CommandRunTestStep != nil {
		{
			size, err := m.CommandRunTestStep.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_CommandRunAfterTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_CommandRunAfterTestCaseHook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CommandRunAfterTestCaseHook != nil {
		{
			size, err := m.CommandRunAfterTestCaseHook.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_CommandRunAfterTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_CommandRunAfterTestRunHooks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CommandRunAfterTestRunHooks != nil {
		{
			size, err := m.CommandRunAfterTestRunHooks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_CommandGenerateSnippet) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_CommandGenerateSnippet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CommandGenerateSnippet != nil {
		{
			size, err := m.CommandGenerateSnippet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_CommandError) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_CommandError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.CommandError)
	copy(dAtA[i:], m.CommandError)
	i = encodeVarintMessages(dAtA, i, uint64(len(m.CommandError)))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xca
	return len(dAtA) - i, nil
}
func (m *Envelope_TestStepMatched) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestStepMatched) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestStepMatched != nil {
		{
			size, err := m.TestStepMatched.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_TestCase) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *Envelope_TestCase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestCase != nil {
		{
			size, err := m.TestCase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Column != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Column))
		i--
		dAtA[i] = 0x10
	}
	if m.Line != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Line))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SourceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Media) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Media) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Media) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Encoding != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Encoding))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Comments) > 0 {
		for iNdEx := len(m.Comments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Comments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Feature != nil {
		{
			size, err := m.Feature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Comment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Comment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Comment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_FeatureChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_FeatureChild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_FeatureChild_Rule_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *GherkinDocument_Feature_FeatureChild_Rule_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rule != nil {
		{
			size, err := m.Rule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_Background) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *GherkinDocument_Feature_FeatureChild_Background) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Background != nil {
		{
			size, err := m.Background.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_Scenario) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *GherkinDocument_Feature_FeatureChild_Scenario) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scenario != nil {
		{
			size, err := m.Scenario.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild_Rule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Background) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Background) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Background != nil {
		{
			size, err := m.Background.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Scenario != nil {
		{
			size, err := m.Scenario.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_Background) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Background) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Background) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Scenario) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Scenario) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Scenario) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Examples) > 0 {
		for iNdEx := len(m.Examples) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Examples[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Scenario_Examples) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Scenario_Examples) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TableBody) > 0 {
		for iNdEx := len(m.TableBody) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TableBody[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.TableHeader != nil {
		{
			size, err := m.TableHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_TableRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_TableRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_TableRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Cells) > 0 {
		for iNdEx := len(m.Cells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_TableRow_TableCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_TableRow_TableCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_TableRow_TableCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Step) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Argument != nil {
		{
			size := m.Argument.Size()
			i -= size
			if _, err := m.Argument.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyword) > 0 {
		i -= len(m.Keyword)
		copy(dAtA[i:], m.Keyword)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Step_DocString_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *GherkinDocument_Feature_Step_DocString_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DocString != nil {
		{
			size, err := m.DocString.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_Step_DataTable_) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *GherkinDocument_Feature_Step_DataTable_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DataTable != nil {
		{
			size, err := m.DataTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *GherkinDocument_Feature_Step_DataTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Step_DataTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Step_DataTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GherkinDocument_Feature_Step_DocString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument_Feature_Step_DocString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GherkinDocument_Feature_Step_DocString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Delimiter) > 0 {
		i -= len(m.Delimiter)
		copy(dAtA[i:], m.Delimiter)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Delimiter)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x12
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Attachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attachment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Attachment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pickle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pickle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pickle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SourceIds) > 0 {
		for iNdEx := len(m.SourceIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SourceIds[iNdEx])
			copy(dAtA[i:], m.SourceIds[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.SourceIds[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pickle_PickleTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pickle_PickleTag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pickle_PickleTag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Pickle_PickleStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pickle_PickleStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pickle_PickleStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SourceIds) > 0 {
		for iNdEx := len(m.SourceIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SourceIds[iNdEx])
			copy(dAtA[i:], m.SourceIds[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.SourceIds[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.StepId) > 0 {
		i -= len(m.StepId)
		copy(dAtA[i:], m.StepId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.StepId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x32
	}
	if m.Argument != nil {
		{
			size, err := m.Argument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PickleStepArgument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size := m.Message.Size()
			i -= size
			if _, err := m.Message.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *PickleStepArgument_DocString) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PickleStepArgument_DocString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DocString != nil {
		{
			size, err := m.DocString.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *PickleStepArgument_DataTable) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *PickleStepArgument_DataTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DataTable != nil {
		{
			size, err := m.DataTable.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PickleStepArgument_PickleDocString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleDocString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument_PickleDocString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *PickleStepArgument_PickleTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleTable) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument_PickleTable) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cells) > 0 {
		for iNdEx := len(m.Cells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestCase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestSteps) > 0 {
		for iNdEx := len(m.TestSteps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TestSteps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PickleId) > 0 {
		i -= len(m.PickleId)
		copy(dAtA[i:], m.PickleId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCase_TestStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCase_TestStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCase_TestStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HookId) > 0 {
		i -= len(m.HookId)
		copy(dAtA[i:], m.HookId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.HookId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StepMatchArguments) > 0 {
		for iNdEx := len(m.StepMatchArguments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StepMatchArguments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.StepDefinitionId) > 0 {
		for iNdEx := len(m.StepDefinitionId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StepDefinitionId[iNdEx])
			copy(dAtA[i:], m.StepDefinitionId[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.StepDefinitionId[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.PickleStepId) > 0 {
		i -= len(m.PickleStepId)
		copy(dAtA[i:], m.PickleStepId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleStepId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PickleAccepted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleAccepted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleAccepted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		i -= len(m.PickleId)
		copy(dAtA[i:], m.PickleId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PickleRejected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleRejected) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PickleRejected) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		i -= len(m.PickleId)
		copy(dAtA[i:], m.PickleId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestRunStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestRunStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestRunStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCasePreparedStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCasePreparedStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCasePreparedStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActionLocation != nil {
		{
			size, err := m.ActionLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SourceLocation != nil {
		{
			size, err := m.SourceLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCasePrepared) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCasePrepared) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCasePrepared) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PickleId) > 0 {
		i -= len(m.PickleId)
		copy(dAtA[i:], m.PickleId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCaseStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCaseStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TestCaseId) > 0 {
		i -= len(m.TestCaseId)
		copy(dAtA[i:], m.TestCaseId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Attempt != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Attempt))
		i--
		dAtA[i] = 0x20
	}
	if m.Platform != nil {
		{
			size, err := m.Platform.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestCaseStarted_Platform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseStarted_Platform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCaseStarted_Platform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cpu) > 0 {
		i -= len(m.Cpu)
		copy(dAtA[i:], m.Cpu)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Cpu)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Os) > 0 {
		i -= len(m.Os)
		copy(dAtA[i:], m.Os)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Os)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Implementation) > 0 {
		i -= len(m.Implementation)
		copy(dAtA[i:], m.Implementation)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Implementation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestCaseFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCaseFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseStartedId) > 0 {
		i -= len(m.TestCaseStartedId)
		copy(dAtA[i:], m.TestCaseStartedId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseStartedId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TestResult != nil {
		{
			size, err := m.TestResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestStepMatched) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestStepMatched) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestStepMatched) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StepMatchArguments) > 0 {
		for iNdEx := len(m.StepMatchArguments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StepMatchArguments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.StepDefinitionReference != nil {
		{
			size, err := m.StepDefinitionReference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Index != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PickleId) > 0 {
		i -= len(m.PickleId)
		copy(dAtA[i:], m.PickleId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TestStepStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestStepStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestStepStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseStartedId) > 0 {
		i -= len(m.TestCaseStartedId)
		copy(dAtA[i:], m.TestCaseStartedId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseStartedId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TestStepId) > 0 {
		i -= len(m.TestStepId)
		copy(dAtA[i:], m.TestStepId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestStepId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *TestStepFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestStepFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestStepFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseStartedId) > 0 {
		i -= len(m.TestCaseStartedId)
		copy(dAtA[i:], m.TestCaseStartedId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseStartedId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.TestStepId) > 0 {
		i -= len(m.TestStepId)
		copy(dAtA[i:], m.TestStepId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestStepId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TestResult != nil {
		{
			size, err := m.TestResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}

func (m *TestHookStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestHookStarted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestHookStarted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseId) > 0 {
		i -= len(m.TestCaseId)
		copy(dAtA[i:], m.TestCaseId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestHookFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestHookFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestHookFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseId) > 0 {
		i -= len(m.TestCaseId)
		copy(dAtA[i:], m.TestCaseId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TestResult != nil {
		{
			size, err := m.TestResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TestResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WillBeRetried {
		i--
		if m.WillBeRetried {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Duration != nil {
		{
			size, err := m.Duration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TestRunFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestRunFinished) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestRunFinished) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommandStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandStart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandStart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SupportCodeConfig != nil {
		{
			size, err := m.SupportCodeConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.RuntimeConfig != nil {
		{
			size, err := m.RuntimeConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SourcesConfig != nil {
		{
			size, err := m.SourcesConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BaseDirectory) > 0 {
		i -= len(m.BaseDirectory)
		copy(dAtA[i:], m.BaseDirectory)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.BaseDirectory)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SourcesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourcesConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourcesConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Filters != nil {
		{
			size, err := m.Filters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AbsolutePaths) > 0 {
		for iNdEx := len(m.AbsolutePaths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AbsolutePaths[iNdEx])
			copy(dAtA[i:], m.AbsolutePaths[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.AbsolutePaths[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SourcesFilterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourcesFilterConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourcesFilterConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UriToLinesMapping) > 0 {
		for iNdEx := len(m.UriToLinesMapping) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UriToLinesMapping[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.NameRegularExpressions) > 0 {
		for iNdEx := len(m.NameRegularExpressions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NameRegularExpressions[iNdEx])
			copy(dAtA[i:], m.NameRegularExpressions[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.NameRegularExpressions[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.TagExpression) > 0 {
		i -= len(m.TagExpression)
		copy(dAtA[i:], m.TagExpression)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TagExpression)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UriToLinesMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UriToLinesMapping) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UriToLinesMapping) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Lines) > 0 {
		dAtA77 := make([]byte, len(m.Lines)*10)
		var j76 int
		for _, num := range m.Lines {
			for num >= 1<<7 {
				dAtA77[j76] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j76++
			}
			dAtA77[j76] = uint8(num)
			j76++
		}
		i -= j76
		copy(dAtA[i:], dAtA77[:j76])
		i = encodeVarintMessages(dAtA, i, uint64(j76))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AbsolutePath) > 0 {
		i -= len(m.AbsolutePath)
		copy(dAtA[i:], m.AbsolutePath)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.AbsolutePath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SourcesOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourcesOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourcesOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seed != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Seed))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RuntimeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RuntimeConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxParallel != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.MaxParallel))
		i--
		dAtA[i] = 0x20
	}
	if m.IsStrict {
		i--
		if m.IsStrict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.IsDryRun {
		i--
		if m.IsDryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IsFailFast {
		i--
		if m.IsFailFast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SupportCodeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportCodeConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupportCodeConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParameterTypeConfigs) > 0 {
		for iNdEx := len(m.ParameterTypeConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ParameterTypeConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.StepDefinitionConfigs) > 0 {
		for iNdEx := len(m.StepDefinitionConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StepDefinitionConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AfterTestCaseHookDefinitionConfigs) > 0 {
		for iNdEx := len(m.AfterTestCaseHookDefinitionConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AfterTestCaseHookDefinitionConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.BeforeTestCaseHookDefinitionConfigs) > 0 {
		for iNdEx := len(m.BeforeTestCaseHookDefinitionConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BeforeTestCaseHookDefinitionConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TestCaseHookDefinitionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseHookDefinitionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestCaseHookDefinitionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TagExpression) > 0 {
		i -= len(m.TagExpression)
		copy(dAtA[i:], m.TagExpression)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TagExpression)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StepDefinitionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepDefinitionConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepDefinitionConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Pattern != nil {
		{
			size, err := m.Pattern.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StepDefinitionPattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepDefinitionPattern) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepDefinitionPattern) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParameterTypeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParameterTypeConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParameterTypeConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UseForSnippets {
		i--
		if m.UseForSnippets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.PreferForRegularExpressionMatch {
		i--
		if m.PreferForRegularExpressionMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.RegularExpressions) > 0 {
		for iNdEx := len(m.RegularExpressions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RegularExpressions[iNdEx])
			copy(dAtA[i:], m.RegularExpressions[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.RegularExpressions[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandActionComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandActionComplete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandActionComplete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != nil {
		{
			size := m.Result.Size()
			i -= size
			if _, err := m.Result.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.CompletedId) > 0 {
		i -= len(m.CompletedId)
		copy(dAtA[i:], m.CompletedId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.CompletedId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandActionComplete_TestResult) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *CommandActionComplete_TestResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TestResult != nil {
		{
			size, err := m.TestResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *CommandActionComplete_Snippet) MarshalTo(dAtA []byte) (int, error) {
	return m.MarshalToSizedBuffer(dAtA[:m.Size()])
}

func (m *CommandActionComplete_Snippet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Snippet)
	copy(dAtA[i:], m.Snippet)
	i = encodeVarintMessages(dAtA, i, uint64(len(m.Snippet)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *CommandRunBeforeTestRunHooks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunBeforeTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandRunBeforeTestRunHooks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandRunAfterTestRunHooks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunAfterTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandRunAfterTestRunHooks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandInitializeTestCase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandInitializeTestCase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandInitializeTestCase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pickle != nil {
		{
			size, err := m.Pickle.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandRunBeforeTestCaseHook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunBeforeTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandRunBeforeTestCaseHook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseId) > 0 {
		i -= len(m.TestCaseId)
		copy(dAtA[i:], m.TestCaseId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TestCaseHookDefinitionId) > 0 {
		i -= len(m.TestCaseHookDefinitionId)
		copy(dAtA[i:], m.TestCaseHookDefinitionId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseHookDefinitionId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandRunAfterTestCaseHook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunAfterTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandRunAfterTestCaseHook) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseId) > 0 {
		i -= len(m.TestCaseId)
		copy(dAtA[i:], m.TestCaseId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TestCaseHookDefinitionId) > 0 {
		i -= len(m.TestCaseHookDefinitionId)
		copy(dAtA[i:], m.TestCaseHookDefinitionId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseHookDefinitionId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommandRunTestStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunTestStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandRunTestStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TestCaseId) > 0 {
		i -= len(m.TestCaseId)
		copy(dAtA[i:], m.TestCaseId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.PickleStepArgument != nil {
		{
			size, err := m.PickleStepArgument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.StepMatchArguments) > 0 {
		for iNdEx := len(m.StepMatchArguments) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StepMatchArguments[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.StepDefinitionId) > 0 {
		i -= len(m.StepDefinitionId)
		copy(dAtA[i:], m.StepDefinitionId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.StepDefinitionId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StepMatchArgument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepMatchArgument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepMatchArgument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ParameterTypeName) > 0 {
		i -= len(m.ParameterTypeName)
		copy(dAtA[i:], m.ParameterTypeName)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ParameterTypeName)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *StepMatchArgument_Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepMatchArgument_Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepMatchArgument_Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for iNdEx := len(m.Children) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Children[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Start != 0 {
		i = encodeVarintMessages(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommandGenerateSnippet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandGenerateSnippet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommandGenerateSnippet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PickleStepArgument != nil {
		{
			size, err := m.PickleStepArgument.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessages(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GeneratedExpressions) > 0 {
		for iNdEx := len(m.GeneratedExpressions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GeneratedExpressions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMessages(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ActionId) > 0 {
		i -= len(m.ActionId)
		copy(dAtA[i:], m.ActionId)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GeneratedExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratedExpression) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeneratedExpression) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ParameterTypeNames) > 0 {
		for iNdEx := len(m.ParameterTypeNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ParameterTypeNames[iNdEx])
			copy(dAtA[i:], m.ParameterTypeNames[iNdEx])
			i = encodeVarintMessages(dAtA, i, uint64(len(m.ParameterTypeNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Text) > 0 {
		i -= len(m.Text)
		copy(dAtA[i:], m.Text)
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessages(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessages(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovMessages(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovMessages(uint64(m.Nanos))
	}
	return n
}

func (m *Duration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovMessages(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovMessages(uint64(m.Nanos))
	}
	return n
}

func (m *Envelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *Envelope_Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_GherkinDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GherkinDocument != nil {
		l = m.GherkinDocument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_Pickle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pickle != nil {
		l = m.Pickle.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_Attachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Attachment != nil {
		l = m.Attachment.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestCaseStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestCaseStarted != nil {
		l = m.TestCaseStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestStepStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestStepStarted != nil {
		l = m.TestStepStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestStepFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestStepFinished != nil {
		l = m.TestStepFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestCaseFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestCaseFinished != nil {
		l = m.TestCaseFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestHookStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestHookStarted != nil {
		l = m.TestHookStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestHookFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestHookFinished != nil {
		l = m.TestHookFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_PickleAccepted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PickleAccepted != nil {
		l = m.PickleAccepted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_PickleRejected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PickleRejected != nil {
		l = m.PickleRejected.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestCasePrepared) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestCasePrepared != nil {
		l = m.TestCasePrepared.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestRunStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestRunStarted != nil {
		l = m.TestRunStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestRunFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestRunFinished != nil {
		l = m.TestRunFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandStart != nil {
		l = m.CommandStart.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandActionComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandActionComplete != nil {
		l = m.CommandActionComplete.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandRunBeforeTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunBeforeTestRunHooks != nil {
		l = m.CommandRunBeforeTestRunHooks.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandInitializeTestCase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandInitializeTestCase != nil {
		l = m.CommandInitializeTestCase.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandRunBeforeTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunBeforeTestCaseHook != nil {
		l = m.CommandRunBeforeTestCaseHook.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandRunTestStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunTestStep != nil {
		l = m.CommandRunTestStep.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandRunAfterTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunAfterTestCaseHook != nil {
		l = m.CommandRunAfterTestCaseHook.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandRunAfterTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunAfterTestRunHooks != nil {
		l = m.CommandRunAfterTestRunHooks.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandGenerateSnippet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandGenerateSnippet != nil {
		l = m.CommandGenerateSnippet.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_CommandError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommandError)
	n += 2 + l + sovMessages(uint64(l))
	return n
}
func (m *Envelope_TestStepMatched) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestStepMatched != nil {
		l = m.TestStepMatched.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Envelope_TestCase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestCase != nil {
		l = m.TestCase.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Line != 0 {
		n += 1 + sovMessages(uint64(m.Line))
	}
	if m.Column != 0 {
		n += 1 + sovMessages(uint64(m.Column))
	}
	return n
}

func (m *SourceReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Media) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Encoding != 0 {
		n += 1 + sovMessages(uint64(m.Encoding))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Feature != nil {
		l = m.Feature.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Comments) > 0 {
		for _, e := range m.Comments {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Comment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild_Rule_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rule != nil {
		l = m.Rule.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_Background) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Background != nil {
		l = m.Background.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_Scenario) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scenario != nil {
		l = m.Scenario.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Background) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Background != nil {
		l = m.Background.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild_Scenario) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scenario != nil {
		l = m.Scenario.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_Background) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_Scenario) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Examples) > 0 {
		for _, e := range m.Examples {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_Scenario_Examples) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.TableHeader != nil {
		l = m.TableHeader.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.TableBody) > 0 {
		for _, e := range m.TableBody {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_TableRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Cells) > 0 {
		for _, e := range m.Cells {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_TableRow_TableCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_Step) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Argument != nil {
		n += m.Argument.Size()
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument_Feature_Step_DocString_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_Step_DataTable_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GherkinDocument_Feature_Step_DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GherkinDocument_Feature_Step_DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Delimiter)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Attachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Pickle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.SourceIds) > 0 {
		for _, s := range m.SourceIds {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *Pickle_PickleTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Pickle_PickleStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Argument != nil {
		l = m.Argument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.StepId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.SourceIds) > 0 {
		for _, s := range m.SourceIds {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleStepArgument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *PickleStepArgument_DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *PickleStepArgument_DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *PickleStepArgument_PickleDocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleStepArgument_PickleTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleStepArgument_PickleTable_PickleTableRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cells) > 0 {
		for _, e := range m.Cells {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.TestSteps) > 0 {
		for _, e := range m.TestSteps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestCase_TestStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.PickleStepId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.StepDefinitionId) > 0 {
		for _, s := range m.StepDefinitionId {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.StepMatchArguments) > 0 {
		for _, e := range m.StepMatchArguments {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.HookId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleAccepted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleRejected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestRunStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCasePreparedStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceLocation != nil {
		l = m.SourceLocation.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ActionLocation != nil {
		l = m.ActionLocation.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCasePrepared) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestCaseStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Platform != nil {
		l = m.Platform.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Attempt != 0 {
		n += 1 + sovMessages(uint64(m.Attempt))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCaseStarted_Platform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Implementation)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Os)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Cpu)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCaseFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseStartedId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestStepMatched) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovMessages(uint64(m.Index))
	}
	if m.StepDefinitionReference != nil {
		l = m.StepDefinitionReference.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.StepMatchArguments) > 0 {
		for _, e := range m.StepMatchArguments {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestStepStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestStepId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseStartedId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestStepFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestStepId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseStartedId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestHookStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestHookFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovMessages(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.WillBeRetried {
		n += 2
	}
	return n
}

func (m *TestRunFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseDirectory)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.SourcesConfig != nil {
		l = m.SourcesConfig.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.RuntimeConfig != nil {
		l = m.RuntimeConfig.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.SupportCodeConfig != nil {
		l = m.SupportCodeConfig.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *SourcesConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AbsolutePaths) > 0 {
		for _, s := range m.AbsolutePaths {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *SourcesFilterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TagExpression)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.NameRegularExpressions) > 0 {
		for _, s := range m.NameRegularExpressions {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.UriToLinesMapping) > 0 {
		for _, e := range m.UriToLinesMapping {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *UriToLinesMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AbsolutePath)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Lines) > 0 {
		l = 0
		for _, e := range m.Lines {
			l += sovMessages(uint64(e))
		}
		n += 1 + sovMessages(uint64(l)) + l
	}
	return n
}

func (m *SourcesOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	if m.Seed != 0 {
		n += 1 + sovMessages(uint64(m.Seed))
	}
	return n
}

func (m *RuntimeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsFailFast {
		n += 2
	}
	if m.IsDryRun {
		n += 2
	}
	if m.IsStrict {
		n += 2
	}
	if m.MaxParallel != 0 {
		n += 1 + sovMessages(uint64(m.MaxParallel))
	}
	return n
}

func (m *SupportCodeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BeforeTestCaseHookDefinitionConfigs) > 0 {
		for _, e := range m.BeforeTestCaseHookDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.AfterTestCaseHookDefinitionConfigs) > 0 {
		for _, e := range m.AfterTestCaseHookDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.StepDefinitionConfigs) > 0 {
		for _, e := range m.StepDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.ParameterTypeConfigs) > 0 {
		for _, e := range m.ParameterTypeConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestCaseHookDefinitionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TagExpression)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *StepDefinitionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *StepDefinitionPattern) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	return n
}

func (m *ParameterTypeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.RegularExpressions) > 0 {
		for _, s := range m.RegularExpressions {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.PreferForRegularExpressionMatch {
		n += 2
	}
	if m.UseForSnippets {
		n += 2
	}
	return n
}

func (m *CommandActionComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CompletedId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Result != nil {
		n += m.Result.Size()
	}
	return n
}

func (m *CommandActionComplete_TestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *CommandActionComplete_Snippet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Snippet)
	n += 1 + l + sovMessages(uint64(l))
	return n
}
func (m *CommandRunBeforeTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunAfterTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandInitializeTestCase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Pickle != nil {
		l = m.Pickle.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunBeforeTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseHookDefinitionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunAfterTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseHookDefinitionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunTestStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.StepDefinitionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.StepMatchArguments) > 0 {
		for _, e := range m.StepMatchArguments {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.PickleStepArgument != nil {
		l = m.PickleStepArgument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *StepMatchArgument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParameterTypeName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *StepMatchArgument_Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovMessages(uint64(m.Start))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *CommandGenerateSnippet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.GeneratedExpressions) > 0 {
		for _, e := range m.GeneratedExpressions {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.PickleStepArgument != nil {
		l = m.PickleStepArgument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GeneratedExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.ParameterTypeNames) > 0 {
		for _, s := range m.ParameterTypeNames {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func sovMessages(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessages(x uint64) (n int) {
	return sovMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Duration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Duration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Duration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Envelope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Envelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Envelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Source{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Source{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GherkinDocument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_GherkinDocument{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pickle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Pickle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Pickle{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Attachment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_Attachment{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCaseStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestCaseStarted{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestStepStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestStepStarted{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestStepFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestStepFinished{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCaseFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestCaseFinished{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestHookStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestHookStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestHookStarted{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestHookFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestHookFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestHookFinished{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleAccepted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleAccepted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_PickleAccepted{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleRejected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleRejected{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_PickleRejected{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCasePrepared", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCasePrepared{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestCasePrepared{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestRunStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestRunStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestRunStarted{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestRunFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestRunFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestRunFinished{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandStart{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandStart{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandActionComplete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandActionComplete{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandActionComplete{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunBeforeTestRunHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunBeforeTestRunHooks{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandRunBeforeTestRunHooks{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandInitializeTestCase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandInitializeTestCase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandInitializeTestCase{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunBeforeTestCaseHook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunBeforeTestCaseHook{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandRunBeforeTestCaseHook{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunTestStep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunTestStep{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandRunTestStep{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunAfterTestCaseHook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunAfterTestCaseHook{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandRunAfterTestCaseHook{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunAfterTestRunHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunAfterTestRunHooks{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandRunAfterTestRunHooks{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandGenerateSnippet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandGenerateSnippet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_CommandGenerateSnippet{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = &Envelope_CommandError{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepMatched", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestStepMatched{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestStepMatched{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Envelope_TestCase{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Media) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Media: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Media: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			m.Encoding = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encoding |= Media_Encoding(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &Media{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GherkinDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GherkinDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Feature == nil {
				m.Feature = &GherkinDocument_Feature{}
			}
			if err := m.Feature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comments = append(m.Comments, &GherkinDocument_Comment{})
			if err := m.Comments[len(m.Comments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Comment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Comment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Comment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Feature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Feature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &GherkinDocument_Feature_Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &GherkinDocument_Feature_FeatureChild{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_FeatureChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_FeatureChild_Rule{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_Rule_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Background{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_Background{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scenario", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Scenario{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_Scenario{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_FeatureChild_Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &GherkinDocument_Feature_FeatureChild_RuleChild{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_FeatureChild_RuleChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Background{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_RuleChild_Background{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scenario", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Scenario{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &GherkinDocument_Feature_FeatureChild_RuleChild_Scenario{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Background) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Background: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Background: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &GherkinDocument_Feature_Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Scenario) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Scenario: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Scenario: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &GherkinDocument_Feature_Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &GherkinDocument_Feature_Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Examples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Examples = append(m.Examples, &GherkinDocument_Feature_Scenario_Examples{})
			if err := m.Examples[len(m.Examples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Scenario_Examples) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Examples: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Examples: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &GherkinDocument_Feature_Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableHeader == nil {
				m.TableHeader = &GherkinDocument_Feature_TableRow{}
			}
			if err := m.TableHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableBody = append(m.TableBody, &GherkinDocument_Feature_TableRow{})
			if err := m.TableBody[len(m.TableBody)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_TableRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, &GherkinDocument_Feature_TableRow_TableCell{})
			if err := m.Cells[len(m.Cells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_TableRow_TableCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Step_DocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Argument = &GherkinDocument_Feature_Step_DocString_{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument_Feature_Step_DataTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Argument = &GherkinDocument_Feature_Step_DataTable_{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Step_DataTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &GherkinDocument_Feature_TableRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument_Feature_Step_DocString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delimiter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delimiter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SourceReference{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &Media{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pickle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pickle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pickle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &Pickle_PickleStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Pickle_PickleTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceIds = append(m.SourceIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pickle_PickleTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pickle_PickleStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Argument == nil {
				m.Argument = &PickleStepArgument{}
			}
			if err := m.Argument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceIds = append(m.SourceIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleStepArgument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleStepArgument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleStepArgument_PickleDocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &PickleStepArgument_DocString{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleStepArgument_PickleTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &PickleStepArgument_DataTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleDocString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleDocString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleDocString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &PickleStepArgument_PickleTable_PickleTableRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleTable_PickleTableRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTableRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTableRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, &PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell{})
			if err := m.Cells[len(m.Cells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStepArgument_PickleTable_PickleTableRow_PickleTableCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTableCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTableCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestSteps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestSteps = append(m.TestSteps, &TestCase_TestStep{})
			if err := m.TestSteps[len(m.TestSteps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCase_TestStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleStepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleStepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepDefinitionId = append(m.StepDefinitionId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepMatchArguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepMatchArguments = append(m.StepMatchArguments, &StepMatchArgument{})
			if err := m.StepMatchArguments[len(m.StepMatchArguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HookId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleAccepted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleAccepted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleAccepted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleRejected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleRejected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleRejected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestRunStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestRunStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestRunStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCasePreparedStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCasePreparedStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCasePreparedStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceLocation == nil {
				m.SourceLocation = &SourceReference{}
			}
			if err := m.SourceLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionLocation == nil {
				m.ActionLocation = &SourceReference{}
			}
			if err := m.ActionLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCasePrepared) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCasePrepared: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCasePrepared: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &TestCasePreparedStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Platform == nil {
				m.Platform = &TestCaseStarted_Platform{}
			}
			if err := m.Platform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attempt", wireType)
			}
			m.Attempt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attempt |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseStarted_Platform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Platform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Platform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Implementation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Implementation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Os = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpu = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestResult == nil {
				m.TestResult = &TestResult{}
			}
			if err := m.TestResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStartedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseStartedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestStepMatched) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStepMatched: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStepMatched: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StepDefinitionReference == nil {
				m.StepDefinitionReference = &SourceReference{}
			}
			if err := m.StepDefinitionReference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepMatchArguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepMatchArguments = append(m.StepMatchArguments, &StepMatchArgument{})
			if err := m.StepMatchArguments[len(m.StepMatchArguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestStepStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStepStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStepStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestStepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStartedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseStartedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestStepFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStepFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStepFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestResult == nil {
				m.TestResult = &TestResult{}
			}
			if err := m.TestResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestStepId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStartedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseStartedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestHookStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestHookStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestHookStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestHookFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestHookFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestHookFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestResult == nil {
				m.TestResult = &TestResult{}
			}
			if err := m.TestResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TestResult_Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &Duration{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WillBeRetried", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WillBeRetried = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestRunFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestRunFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestRunFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcesConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourcesConfig == nil {
				m.SourcesConfig = &SourcesConfig{}
			}
			if err := m.SourcesConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeConfig == nil {
				m.RuntimeConfig = &RuntimeConfig{}
			}
			if err := m.RuntimeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportCodeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SupportCodeConfig == nil {
				m.SupportCodeConfig = &SupportCodeConfig{}
			}
			if err := m.SupportCodeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourcesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourcesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourcesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsolutePaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsolutePaths = append(m.AbsolutePaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &SourcesFilterConfig{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &SourcesOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourcesFilterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourcesFilterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourcesFilterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameRegularExpressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameRegularExpressions = append(m.NameRegularExpressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UriToLinesMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UriToLinesMapping = append(m.UriToLinesMapping, &UriToLinesMapping{})
			if err := m.UriToLinesMapping[len(m.UriToLinesMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UriToLinesMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UriToLinesMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UriToLinesMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsolutePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsolutePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Lines = append(m.Lines, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMessages
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Lines) == 0 {
					m.Lines = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Lines = append(m.Lines, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lines", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourcesOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourcesOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourcesOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SourcesOrderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFailFast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFailFast = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDryRun = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStrict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStrict = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxParallel", wireType)
			}
			m.MaxParallel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxParallel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportCodeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportCodeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportCodeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeTestCaseHookDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeforeTestCaseHookDefinitionConfigs = append(m.BeforeTestCaseHookDefinitionConfigs, &TestCaseHookDefinitionConfig{})
			if err := m.BeforeTestCaseHookDefinitionConfigs[len(m.BeforeTestCaseHookDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterTestCaseHookDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterTestCaseHookDefinitionConfigs = append(m.AfterTestCaseHookDefinitionConfigs, &TestCaseHookDefinitionConfig{})
			if err := m.AfterTestCaseHookDefinitionConfigs[len(m.AfterTestCaseHookDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepDefinitionConfigs = append(m.StepDefinitionConfigs, &StepDefinitionConfig{})
			if err := m.StepDefinitionConfigs[len(m.StepDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeConfigs = append(m.ParameterTypeConfigs, &ParameterTypeConfig{})
			if err := m.ParameterTypeConfigs[len(m.ParameterTypeConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseHookDefinitionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseHookDefinitionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseHookDefinitionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &SourceReference{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepDefinitionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepDefinitionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepDefinitionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &StepDefinitionPattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &SourceReference{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepDefinitionPattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepDefinitionPattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepDefinitionPattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StepDefinitionPatternType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParameterTypeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParameterTypeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParameterTypeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegularExpressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegularExpressions = append(m.RegularExpressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferForRegularExpressionMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreferForRegularExpressionMatch = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseForSnippets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseForSnippets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandActionComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandActionComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandActionComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompletedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &CommandActionComplete_TestResult{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = &CommandActionComplete_Snippet{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunBeforeTestRunHooks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunBeforeTestRunHooks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunBeforeTestRunHooks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunAfterTestRunHooks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunAfterTestRunHooks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunAfterTestRunHooks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandInitializeTestCase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandInitializeTestCase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandInitializeTestCase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pickle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pickle == nil {
				m.Pickle = &Pickle{}
			}
			if err := m.Pickle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunBeforeTestCaseHook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunBeforeTestCaseHook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunBeforeTestCaseHook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseHookDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseHookDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunAfterTestCaseHook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunAfterTestCaseHook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunAfterTestCaseHook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseHookDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseHookDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunTestStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunTestStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunTestStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepMatchArguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepMatchArguments = append(m.StepMatchArguments, &StepMatchArgument{})
			if err := m.StepMatchArguments[len(m.StepMatchArguments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleStepArgument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PickleStepArgument == nil {
				m.PickleStepArgument = &PickleStepArgument{}
			}
			if err := m.PickleStepArgument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepMatchArgument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepMatchArgument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepMatchArgument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &StepMatchArgument_Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepMatchArgument_Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &StepMatchArgument_Group{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandGenerateSnippet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandGenerateSnippet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandGenerateSnippet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedExpressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedExpressions = append(m.GeneratedExpressions, &GeneratedExpression{})
			if err := m.GeneratedExpressions[len(m.GeneratedExpressions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleStepArgument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PickleStepArgument == nil {
				m.PickleStepArgument = &PickleStepArgument{}
			}
			if err := m.PickleStepArgument.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratedExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneratedExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneratedExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeNames = append(m.ParameterTypeNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessages
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMessages
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessages   = fmt.Errorf("proto: integer overflow")
)
