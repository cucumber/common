// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: messages.proto

package messages

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import types "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Status int32

const (
	Status_AMBIGUOUS Status = 0
	Status_FAILED    Status = 1
	Status_PASSED    Status = 2
	Status_PENDING   Status = 3
	Status_SKIPPED   Status = 4
	Status_UNDEFINED Status = 5
)

var Status_name = map[int32]string{
	0: "AMBIGUOUS",
	1: "FAILED",
	2: "PASSED",
	3: "PENDING",
	4: "SKIPPED",
	5: "UNDEFINED",
}
var Status_value = map[string]int32{
	"AMBIGUOUS": 0,
	"FAILED":    1,
	"PASSED":    2,
	"PENDING":   3,
	"SKIPPED":   4,
	"UNDEFINED": 5,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{0}
}

type SourcesOrderType int32

const (
	SourcesOrderType_ORDER_OF_DEFINITION SourcesOrderType = 0
	SourcesOrderType_RANDOM              SourcesOrderType = 1
)

var SourcesOrderType_name = map[int32]string{
	0: "ORDER_OF_DEFINITION",
	1: "RANDOM",
}
var SourcesOrderType_value = map[string]int32{
	"ORDER_OF_DEFINITION": 0,
	"RANDOM":              1,
}

func (x SourcesOrderType) String() string {
	return proto.EnumName(SourcesOrderType_name, int32(x))
}
func (SourcesOrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{1}
}

type StepDefinitionPatternType int32

const (
	StepDefinitionPatternType_CUCUMBER_EXPRESSION StepDefinitionPatternType = 0
	StepDefinitionPatternType_REGULAR_EXPRESSION  StepDefinitionPatternType = 1
)

var StepDefinitionPatternType_name = map[int32]string{
	0: "CUCUMBER_EXPRESSION",
	1: "REGULAR_EXPRESSION",
}
var StepDefinitionPatternType_value = map[string]int32{
	"CUCUMBER_EXPRESSION": 0,
	"REGULAR_EXPRESSION":  1,
}

func (x StepDefinitionPatternType) String() string {
	return proto.EnumName(StepDefinitionPatternType_name, int32(x))
}
func (StepDefinitionPatternType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{2}
}

// All messages sent between processes must be of type Wrapper
type Wrapper struct {
	// Types that are valid to be assigned to Message:
	//	*Wrapper_Source
	//	*Wrapper_GherkinDocument
	//	*Wrapper_Pickle
	//	*Wrapper_Attachment
	//	*Wrapper_TestCaseStarted
	//	*Wrapper_TestStepStarted
	//	*Wrapper_TestStepFinished
	//	*Wrapper_TestCaseFinished
	//	*Wrapper_TestHookStarted
	//	*Wrapper_TestHookFinished
	//	*Wrapper_PickleAccepted
	//	*Wrapper_PickleRejected
	//	*Wrapper_TestCasePrepared
	//	*Wrapper_TestRunStarted
	//	*Wrapper_TestRunFinished
	//	*Wrapper_CommandStart
	//	*Wrapper_CommandActionComplete
	//	*Wrapper_CommandRunBeforeTestRunHooks
	//	*Wrapper_CommandInitializeTestCase
	//	*Wrapper_CommandRunBeforeTestCaseHook
	//	*Wrapper_CommandRunTestStep
	//	*Wrapper_CommandRunAfterTestCaseHook
	//	*Wrapper_CommandRunAfterTestRunHooks
	//	*Wrapper_CommandGenerateSnippet
	//	*Wrapper_CommandError
	Message isWrapper_Message `protobuf_oneof:"message"`
}

func (m *Wrapper) Reset()         { *m = Wrapper{} }
func (m *Wrapper) String() string { return proto.CompactTextString(m) }
func (*Wrapper) ProtoMessage()    {}
func (*Wrapper) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{0}
}
func (m *Wrapper) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Wrapper) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Wrapper.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Wrapper) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Wrapper.Merge(dst, src)
}
func (m *Wrapper) XXX_Size() int {
	return m.Size()
}
func (m *Wrapper) XXX_DiscardUnknown() {
	xxx_messageInfo_Wrapper.DiscardUnknown(m)
}

var xxx_messageInfo_Wrapper proto.InternalMessageInfo

type isWrapper_Message interface {
	isWrapper_Message()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Wrapper_Source struct {
	Source *Source `protobuf:"bytes,1,opt,name=source,oneof"`
}
type Wrapper_GherkinDocument struct {
	GherkinDocument *GherkinDocument `protobuf:"bytes,2,opt,name=gherkinDocument,oneof"`
}
type Wrapper_Pickle struct {
	Pickle *Pickle `protobuf:"bytes,3,opt,name=pickle,oneof"`
}
type Wrapper_Attachment struct {
	Attachment *Attachment `protobuf:"bytes,4,opt,name=attachment,oneof"`
}
type Wrapper_TestCaseStarted struct {
	TestCaseStarted *TestCaseStarted `protobuf:"bytes,5,opt,name=testCaseStarted,oneof"`
}
type Wrapper_TestStepStarted struct {
	TestStepStarted *TestStepStarted `protobuf:"bytes,6,opt,name=testStepStarted,oneof"`
}
type Wrapper_TestStepFinished struct {
	TestStepFinished *TestStepFinished `protobuf:"bytes,7,opt,name=testStepFinished,oneof"`
}
type Wrapper_TestCaseFinished struct {
	TestCaseFinished *TestCaseFinished `protobuf:"bytes,8,opt,name=testCaseFinished,oneof"`
}
type Wrapper_TestHookStarted struct {
	TestHookStarted *TestHookStarted `protobuf:"bytes,9,opt,name=testHookStarted,oneof"`
}
type Wrapper_TestHookFinished struct {
	TestHookFinished *TestHookFinished `protobuf:"bytes,10,opt,name=testHookFinished,oneof"`
}
type Wrapper_PickleAccepted struct {
	PickleAccepted *PickleAccepted `protobuf:"bytes,11,opt,name=pickleAccepted,oneof"`
}
type Wrapper_PickleRejected struct {
	PickleRejected *PickleRejected `protobuf:"bytes,12,opt,name=pickleRejected,oneof"`
}
type Wrapper_TestCasePrepared struct {
	TestCasePrepared *TestCasePrepared `protobuf:"bytes,13,opt,name=testCasePrepared,oneof"`
}
type Wrapper_TestRunStarted struct {
	TestRunStarted *TestRunStarted `protobuf:"bytes,14,opt,name=testRunStarted,oneof"`
}
type Wrapper_TestRunFinished struct {
	TestRunFinished *TestRunFinished `protobuf:"bytes,15,opt,name=testRunFinished,oneof"`
}
type Wrapper_CommandStart struct {
	CommandStart *CommandStart `protobuf:"bytes,16,opt,name=commandStart,oneof"`
}
type Wrapper_CommandActionComplete struct {
	CommandActionComplete *CommandActionComplete `protobuf:"bytes,17,opt,name=commandActionComplete,oneof"`
}
type Wrapper_CommandRunBeforeTestRunHooks struct {
	CommandRunBeforeTestRunHooks *CommandRunBeforeTestRunHooks `protobuf:"bytes,18,opt,name=commandRunBeforeTestRunHooks,oneof"`
}
type Wrapper_CommandInitializeTestCase struct {
	CommandInitializeTestCase *CommandInitializeTestCase `protobuf:"bytes,19,opt,name=commandInitializeTestCase,oneof"`
}
type Wrapper_CommandRunBeforeTestCaseHook struct {
	CommandRunBeforeTestCaseHook *CommandRunBeforeTestCaseHook `protobuf:"bytes,20,opt,name=commandRunBeforeTestCaseHook,oneof"`
}
type Wrapper_CommandRunTestStep struct {
	CommandRunTestStep *CommandRunTestStep `protobuf:"bytes,21,opt,name=commandRunTestStep,oneof"`
}
type Wrapper_CommandRunAfterTestCaseHook struct {
	CommandRunAfterTestCaseHook *CommandRunAfterTestCaseHook `protobuf:"bytes,22,opt,name=commandRunAfterTestCaseHook,oneof"`
}
type Wrapper_CommandRunAfterTestRunHooks struct {
	CommandRunAfterTestRunHooks *CommandRunAfterTestRunHooks `protobuf:"bytes,23,opt,name=commandRunAfterTestRunHooks,oneof"`
}
type Wrapper_CommandGenerateSnippet struct {
	CommandGenerateSnippet *CommandGenerateSnippet `protobuf:"bytes,24,opt,name=commandGenerateSnippet,oneof"`
}
type Wrapper_CommandError struct {
	CommandError string `protobuf:"bytes,25,opt,name=commandError,proto3,oneof"`
}

func (*Wrapper_Source) isWrapper_Message()                       {}
func (*Wrapper_GherkinDocument) isWrapper_Message()              {}
func (*Wrapper_Pickle) isWrapper_Message()                       {}
func (*Wrapper_Attachment) isWrapper_Message()                   {}
func (*Wrapper_TestCaseStarted) isWrapper_Message()              {}
func (*Wrapper_TestStepStarted) isWrapper_Message()              {}
func (*Wrapper_TestStepFinished) isWrapper_Message()             {}
func (*Wrapper_TestCaseFinished) isWrapper_Message()             {}
func (*Wrapper_TestHookStarted) isWrapper_Message()              {}
func (*Wrapper_TestHookFinished) isWrapper_Message()             {}
func (*Wrapper_PickleAccepted) isWrapper_Message()               {}
func (*Wrapper_PickleRejected) isWrapper_Message()               {}
func (*Wrapper_TestCasePrepared) isWrapper_Message()             {}
func (*Wrapper_TestRunStarted) isWrapper_Message()               {}
func (*Wrapper_TestRunFinished) isWrapper_Message()              {}
func (*Wrapper_CommandStart) isWrapper_Message()                 {}
func (*Wrapper_CommandActionComplete) isWrapper_Message()        {}
func (*Wrapper_CommandRunBeforeTestRunHooks) isWrapper_Message() {}
func (*Wrapper_CommandInitializeTestCase) isWrapper_Message()    {}
func (*Wrapper_CommandRunBeforeTestCaseHook) isWrapper_Message() {}
func (*Wrapper_CommandRunTestStep) isWrapper_Message()           {}
func (*Wrapper_CommandRunAfterTestCaseHook) isWrapper_Message()  {}
func (*Wrapper_CommandRunAfterTestRunHooks) isWrapper_Message()  {}
func (*Wrapper_CommandGenerateSnippet) isWrapper_Message()       {}
func (*Wrapper_CommandError) isWrapper_Message()                 {}

func (m *Wrapper) GetMessage() isWrapper_Message {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *Wrapper) GetSource() *Source {
	if x, ok := m.GetMessage().(*Wrapper_Source); ok {
		return x.Source
	}
	return nil
}

func (m *Wrapper) GetGherkinDocument() *GherkinDocument {
	if x, ok := m.GetMessage().(*Wrapper_GherkinDocument); ok {
		return x.GherkinDocument
	}
	return nil
}

func (m *Wrapper) GetPickle() *Pickle {
	if x, ok := m.GetMessage().(*Wrapper_Pickle); ok {
		return x.Pickle
	}
	return nil
}

func (m *Wrapper) GetAttachment() *Attachment {
	if x, ok := m.GetMessage().(*Wrapper_Attachment); ok {
		return x.Attachment
	}
	return nil
}

func (m *Wrapper) GetTestCaseStarted() *TestCaseStarted {
	if x, ok := m.GetMessage().(*Wrapper_TestCaseStarted); ok {
		return x.TestCaseStarted
	}
	return nil
}

func (m *Wrapper) GetTestStepStarted() *TestStepStarted {
	if x, ok := m.GetMessage().(*Wrapper_TestStepStarted); ok {
		return x.TestStepStarted
	}
	return nil
}

func (m *Wrapper) GetTestStepFinished() *TestStepFinished {
	if x, ok := m.GetMessage().(*Wrapper_TestStepFinished); ok {
		return x.TestStepFinished
	}
	return nil
}

func (m *Wrapper) GetTestCaseFinished() *TestCaseFinished {
	if x, ok := m.GetMessage().(*Wrapper_TestCaseFinished); ok {
		return x.TestCaseFinished
	}
	return nil
}

func (m *Wrapper) GetTestHookStarted() *TestHookStarted {
	if x, ok := m.GetMessage().(*Wrapper_TestHookStarted); ok {
		return x.TestHookStarted
	}
	return nil
}

func (m *Wrapper) GetTestHookFinished() *TestHookFinished {
	if x, ok := m.GetMessage().(*Wrapper_TestHookFinished); ok {
		return x.TestHookFinished
	}
	return nil
}

func (m *Wrapper) GetPickleAccepted() *PickleAccepted {
	if x, ok := m.GetMessage().(*Wrapper_PickleAccepted); ok {
		return x.PickleAccepted
	}
	return nil
}

func (m *Wrapper) GetPickleRejected() *PickleRejected {
	if x, ok := m.GetMessage().(*Wrapper_PickleRejected); ok {
		return x.PickleRejected
	}
	return nil
}

func (m *Wrapper) GetTestCasePrepared() *TestCasePrepared {
	if x, ok := m.GetMessage().(*Wrapper_TestCasePrepared); ok {
		return x.TestCasePrepared
	}
	return nil
}

func (m *Wrapper) GetTestRunStarted() *TestRunStarted {
	if x, ok := m.GetMessage().(*Wrapper_TestRunStarted); ok {
		return x.TestRunStarted
	}
	return nil
}

func (m *Wrapper) GetTestRunFinished() *TestRunFinished {
	if x, ok := m.GetMessage().(*Wrapper_TestRunFinished); ok {
		return x.TestRunFinished
	}
	return nil
}

func (m *Wrapper) GetCommandStart() *CommandStart {
	if x, ok := m.GetMessage().(*Wrapper_CommandStart); ok {
		return x.CommandStart
	}
	return nil
}

func (m *Wrapper) GetCommandActionComplete() *CommandActionComplete {
	if x, ok := m.GetMessage().(*Wrapper_CommandActionComplete); ok {
		return x.CommandActionComplete
	}
	return nil
}

func (m *Wrapper) GetCommandRunBeforeTestRunHooks() *CommandRunBeforeTestRunHooks {
	if x, ok := m.GetMessage().(*Wrapper_CommandRunBeforeTestRunHooks); ok {
		return x.CommandRunBeforeTestRunHooks
	}
	return nil
}

func (m *Wrapper) GetCommandInitializeTestCase() *CommandInitializeTestCase {
	if x, ok := m.GetMessage().(*Wrapper_CommandInitializeTestCase); ok {
		return x.CommandInitializeTestCase
	}
	return nil
}

func (m *Wrapper) GetCommandRunBeforeTestCaseHook() *CommandRunBeforeTestCaseHook {
	if x, ok := m.GetMessage().(*Wrapper_CommandRunBeforeTestCaseHook); ok {
		return x.CommandRunBeforeTestCaseHook
	}
	return nil
}

func (m *Wrapper) GetCommandRunTestStep() *CommandRunTestStep {
	if x, ok := m.GetMessage().(*Wrapper_CommandRunTestStep); ok {
		return x.CommandRunTestStep
	}
	return nil
}

func (m *Wrapper) GetCommandRunAfterTestCaseHook() *CommandRunAfterTestCaseHook {
	if x, ok := m.GetMessage().(*Wrapper_CommandRunAfterTestCaseHook); ok {
		return x.CommandRunAfterTestCaseHook
	}
	return nil
}

func (m *Wrapper) GetCommandRunAfterTestRunHooks() *CommandRunAfterTestRunHooks {
	if x, ok := m.GetMessage().(*Wrapper_CommandRunAfterTestRunHooks); ok {
		return x.CommandRunAfterTestRunHooks
	}
	return nil
}

func (m *Wrapper) GetCommandGenerateSnippet() *CommandGenerateSnippet {
	if x, ok := m.GetMessage().(*Wrapper_CommandGenerateSnippet); ok {
		return x.CommandGenerateSnippet
	}
	return nil
}

func (m *Wrapper) GetCommandError() string {
	if x, ok := m.GetMessage().(*Wrapper_CommandError); ok {
		return x.CommandError
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Wrapper) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Wrapper_OneofMarshaler, _Wrapper_OneofUnmarshaler, _Wrapper_OneofSizer, []interface{}{
		(*Wrapper_Source)(nil),
		(*Wrapper_GherkinDocument)(nil),
		(*Wrapper_Pickle)(nil),
		(*Wrapper_Attachment)(nil),
		(*Wrapper_TestCaseStarted)(nil),
		(*Wrapper_TestStepStarted)(nil),
		(*Wrapper_TestStepFinished)(nil),
		(*Wrapper_TestCaseFinished)(nil),
		(*Wrapper_TestHookStarted)(nil),
		(*Wrapper_TestHookFinished)(nil),
		(*Wrapper_PickleAccepted)(nil),
		(*Wrapper_PickleRejected)(nil),
		(*Wrapper_TestCasePrepared)(nil),
		(*Wrapper_TestRunStarted)(nil),
		(*Wrapper_TestRunFinished)(nil),
		(*Wrapper_CommandStart)(nil),
		(*Wrapper_CommandActionComplete)(nil),
		(*Wrapper_CommandRunBeforeTestRunHooks)(nil),
		(*Wrapper_CommandInitializeTestCase)(nil),
		(*Wrapper_CommandRunBeforeTestCaseHook)(nil),
		(*Wrapper_CommandRunTestStep)(nil),
		(*Wrapper_CommandRunAfterTestCaseHook)(nil),
		(*Wrapper_CommandRunAfterTestRunHooks)(nil),
		(*Wrapper_CommandGenerateSnippet)(nil),
		(*Wrapper_CommandError)(nil),
	}
}

func _Wrapper_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Wrapper)
	// message
	switch x := m.Message.(type) {
	case *Wrapper_Source:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Source); err != nil {
			return err
		}
	case *Wrapper_GherkinDocument:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GherkinDocument); err != nil {
			return err
		}
	case *Wrapper_Pickle:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pickle); err != nil {
			return err
		}
	case *Wrapper_Attachment:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Attachment); err != nil {
			return err
		}
	case *Wrapper_TestCaseStarted:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestCaseStarted); err != nil {
			return err
		}
	case *Wrapper_TestStepStarted:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestStepStarted); err != nil {
			return err
		}
	case *Wrapper_TestStepFinished:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestStepFinished); err != nil {
			return err
		}
	case *Wrapper_TestCaseFinished:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestCaseFinished); err != nil {
			return err
		}
	case *Wrapper_TestHookStarted:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestHookStarted); err != nil {
			return err
		}
	case *Wrapper_TestHookFinished:
		_ = b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestHookFinished); err != nil {
			return err
		}
	case *Wrapper_PickleAccepted:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PickleAccepted); err != nil {
			return err
		}
	case *Wrapper_PickleRejected:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PickleRejected); err != nil {
			return err
		}
	case *Wrapper_TestCasePrepared:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestCasePrepared); err != nil {
			return err
		}
	case *Wrapper_TestRunStarted:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestRunStarted); err != nil {
			return err
		}
	case *Wrapper_TestRunFinished:
		_ = b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestRunFinished); err != nil {
			return err
		}
	case *Wrapper_CommandStart:
		_ = b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandStart); err != nil {
			return err
		}
	case *Wrapper_CommandActionComplete:
		_ = b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandActionComplete); err != nil {
			return err
		}
	case *Wrapper_CommandRunBeforeTestRunHooks:
		_ = b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunBeforeTestRunHooks); err != nil {
			return err
		}
	case *Wrapper_CommandInitializeTestCase:
		_ = b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandInitializeTestCase); err != nil {
			return err
		}
	case *Wrapper_CommandRunBeforeTestCaseHook:
		_ = b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunBeforeTestCaseHook); err != nil {
			return err
		}
	case *Wrapper_CommandRunTestStep:
		_ = b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunTestStep); err != nil {
			return err
		}
	case *Wrapper_CommandRunAfterTestCaseHook:
		_ = b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunAfterTestCaseHook); err != nil {
			return err
		}
	case *Wrapper_CommandRunAfterTestRunHooks:
		_ = b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandRunAfterTestRunHooks); err != nil {
			return err
		}
	case *Wrapper_CommandGenerateSnippet:
		_ = b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CommandGenerateSnippet); err != nil {
			return err
		}
	case *Wrapper_CommandError:
		_ = b.EncodeVarint(25<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.CommandError)
	case nil:
	default:
		return fmt.Errorf("Wrapper.Message has unexpected type %T", x)
	}
	return nil
}

func _Wrapper_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Wrapper)
	switch tag {
	case 1: // message.source
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Source)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_Source{msg}
		return true, err
	case 2: // message.gherkinDocument
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GherkinDocument)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_GherkinDocument{msg}
		return true, err
	case 3: // message.pickle
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Pickle)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_Pickle{msg}
		return true, err
	case 4: // message.attachment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Attachment)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_Attachment{msg}
		return true, err
	case 5: // message.testCaseStarted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestCaseStarted)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_TestCaseStarted{msg}
		return true, err
	case 6: // message.testStepStarted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestStepStarted)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_TestStepStarted{msg}
		return true, err
	case 7: // message.testStepFinished
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestStepFinished)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_TestStepFinished{msg}
		return true, err
	case 8: // message.testCaseFinished
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestCaseFinished)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_TestCaseFinished{msg}
		return true, err
	case 9: // message.testHookStarted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestHookStarted)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_TestHookStarted{msg}
		return true, err
	case 10: // message.testHookFinished
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestHookFinished)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_TestHookFinished{msg}
		return true, err
	case 11: // message.pickleAccepted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleAccepted)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_PickleAccepted{msg}
		return true, err
	case 12: // message.pickleRejected
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleRejected)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_PickleRejected{msg}
		return true, err
	case 13: // message.testCasePrepared
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestCasePrepared)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_TestCasePrepared{msg}
		return true, err
	case 14: // message.testRunStarted
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestRunStarted)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_TestRunStarted{msg}
		return true, err
	case 15: // message.testRunFinished
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestRunFinished)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_TestRunFinished{msg}
		return true, err
	case 16: // message.commandStart
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandStart)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_CommandStart{msg}
		return true, err
	case 17: // message.commandActionComplete
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandActionComplete)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_CommandActionComplete{msg}
		return true, err
	case 18: // message.commandRunBeforeTestRunHooks
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunBeforeTestRunHooks)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_CommandRunBeforeTestRunHooks{msg}
		return true, err
	case 19: // message.commandInitializeTestCase
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandInitializeTestCase)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_CommandInitializeTestCase{msg}
		return true, err
	case 20: // message.commandRunBeforeTestCaseHook
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunBeforeTestCaseHook)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_CommandRunBeforeTestCaseHook{msg}
		return true, err
	case 21: // message.commandRunTestStep
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunTestStep)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_CommandRunTestStep{msg}
		return true, err
	case 22: // message.commandRunAfterTestCaseHook
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunAfterTestCaseHook)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_CommandRunAfterTestCaseHook{msg}
		return true, err
	case 23: // message.commandRunAfterTestRunHooks
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandRunAfterTestRunHooks)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_CommandRunAfterTestRunHooks{msg}
		return true, err
	case 24: // message.commandGenerateSnippet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandGenerateSnippet)
		err := b.DecodeMessage(msg)
		m.Message = &Wrapper_CommandGenerateSnippet{msg}
		return true, err
	case 25: // message.commandError
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Message = &Wrapper_CommandError{x}
		return true, err
	default:
		return false, nil
	}
}

func _Wrapper_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Wrapper)
	// message
	switch x := m.Message.(type) {
	case *Wrapper_Source:
		s := proto.Size(x.Source)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_GherkinDocument:
		s := proto.Size(x.GherkinDocument)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_Pickle:
		s := proto.Size(x.Pickle)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_Attachment:
		s := proto.Size(x.Attachment)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_TestCaseStarted:
		s := proto.Size(x.TestCaseStarted)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_TestStepStarted:
		s := proto.Size(x.TestStepStarted)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_TestStepFinished:
		s := proto.Size(x.TestStepFinished)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_TestCaseFinished:
		s := proto.Size(x.TestCaseFinished)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_TestHookStarted:
		s := proto.Size(x.TestHookStarted)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_TestHookFinished:
		s := proto.Size(x.TestHookFinished)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_PickleAccepted:
		s := proto.Size(x.PickleAccepted)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_PickleRejected:
		s := proto.Size(x.PickleRejected)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_TestCasePrepared:
		s := proto.Size(x.TestCasePrepared)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_TestRunStarted:
		s := proto.Size(x.TestRunStarted)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_TestRunFinished:
		s := proto.Size(x.TestRunFinished)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_CommandStart:
		s := proto.Size(x.CommandStart)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_CommandActionComplete:
		s := proto.Size(x.CommandActionComplete)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_CommandRunBeforeTestRunHooks:
		s := proto.Size(x.CommandRunBeforeTestRunHooks)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_CommandInitializeTestCase:
		s := proto.Size(x.CommandInitializeTestCase)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_CommandRunBeforeTestCaseHook:
		s := proto.Size(x.CommandRunBeforeTestCaseHook)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_CommandRunTestStep:
		s := proto.Size(x.CommandRunTestStep)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_CommandRunAfterTestCaseHook:
		s := proto.Size(x.CommandRunAfterTestCaseHook)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_CommandRunAfterTestRunHooks:
		s := proto.Size(x.CommandRunAfterTestRunHooks)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_CommandGenerateSnippet:
		s := proto.Size(x.CommandGenerateSnippet)
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Wrapper_CommandError:
		n += 2 // tag and wire
		n += proto.SizeVarint(uint64(len(x.CommandError)))
		n += len(x.CommandError)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SourceReference struct {
	Uri      string    `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Location *Location `protobuf:"bytes,2,opt,name=location" json:"location,omitempty"`
}

func (m *SourceReference) Reset()         { *m = SourceReference{} }
func (m *SourceReference) String() string { return proto.CompactTextString(m) }
func (*SourceReference) ProtoMessage()    {}
func (*SourceReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{1}
}
func (m *SourceReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SourceReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceReference.Merge(dst, src)
}
func (m *SourceReference) XXX_Size() int {
	return m.Size()
}
func (m *SourceReference) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceReference.DiscardUnknown(m)
}

var xxx_messageInfo_SourceReference proto.InternalMessageInfo

func (m *SourceReference) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *SourceReference) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

type Location struct {
	Line   uint32 `protobuf:"varint,1,opt,name=line,proto3" json:"line,omitempty"`
	Column uint32 `protobuf:"varint,2,opt,name=column,proto3" json:"column,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{2}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(dst, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

func (m *Location) GetLine() uint32 {
	if m != nil {
		return m.Line
	}
	return 0
}

func (m *Location) GetColumn() uint32 {
	if m != nil {
		return m.Column
	}
	return 0
}

type Attachment struct {
	Source *SourceReference `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Data   string           `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Media  *Media           `protobuf:"bytes,3,opt,name=media" json:"media,omitempty"`
}

func (m *Attachment) Reset()         { *m = Attachment{} }
func (m *Attachment) String() string { return proto.CompactTextString(m) }
func (*Attachment) ProtoMessage()    {}
func (*Attachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{3}
}
func (m *Attachment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Attachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Attachment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Attachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attachment.Merge(dst, src)
}
func (m *Attachment) XXX_Size() int {
	return m.Size()
}
func (m *Attachment) XXX_DiscardUnknown() {
	xxx_messageInfo_Attachment.DiscardUnknown(m)
}

var xxx_messageInfo_Attachment proto.InternalMessageInfo

func (m *Attachment) GetSource() *SourceReference {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Attachment) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Attachment) GetMedia() *Media {
	if m != nil {
		return m.Media
	}
	return nil
}

type Media struct {
	Encoding    string `protobuf:"bytes,1,opt,name=encoding,proto3" json:"encoding,omitempty"`
	ContentType string `protobuf:"bytes,2,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
}

func (m *Media) Reset()         { *m = Media{} }
func (m *Media) String() string { return proto.CompactTextString(m) }
func (*Media) ProtoMessage()    {}
func (*Media) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{4}
}
func (m *Media) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Media) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Media.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Media) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Media.Merge(dst, src)
}
func (m *Media) XXX_Size() int {
	return m.Size()
}
func (m *Media) XXX_DiscardUnknown() {
	xxx_messageInfo_Media.DiscardUnknown(m)
}

var xxx_messageInfo_Media proto.InternalMessageInfo

func (m *Media) GetEncoding() string {
	if m != nil {
		return m.Encoding
	}
	return ""
}

func (m *Media) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

type Source struct {
	Uri   string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Data  string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Media *Media `protobuf:"bytes,3,opt,name=media" json:"media,omitempty"`
}

func (m *Source) Reset()         { *m = Source{} }
func (m *Source) String() string { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()    {}
func (*Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{5}
}
func (m *Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Source.Merge(dst, src)
}
func (m *Source) XXX_Size() int {
	return m.Size()
}
func (m *Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Source proto.InternalMessageInfo

func (m *Source) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Source) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *Source) GetMedia() *Media {
	if m != nil {
		return m.Media
	}
	return nil
}

type GherkinDocument struct {
	Uri      string     `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Feature  *Feature   `protobuf:"bytes,2,opt,name=feature" json:"feature,omitempty"`
	Comments []*Comment `protobuf:"bytes,3,rep,name=comments" json:"comments,omitempty"`
}

func (m *GherkinDocument) Reset()         { *m = GherkinDocument{} }
func (m *GherkinDocument) String() string { return proto.CompactTextString(m) }
func (*GherkinDocument) ProtoMessage()    {}
func (*GherkinDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{6}
}
func (m *GherkinDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GherkinDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GherkinDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GherkinDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GherkinDocument.Merge(dst, src)
}
func (m *GherkinDocument) XXX_Size() int {
	return m.Size()
}
func (m *GherkinDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_GherkinDocument.DiscardUnknown(m)
}

var xxx_messageInfo_GherkinDocument proto.InternalMessageInfo

func (m *GherkinDocument) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *GherkinDocument) GetFeature() *Feature {
	if m != nil {
		return m.Feature
	}
	return nil
}

func (m *GherkinDocument) GetComments() []*Comment {
	if m != nil {
		return m.Comments
	}
	return nil
}

type Feature struct {
	Location    *Location       `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Tags        []*Tag          `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
	Language    string          `protobuf:"bytes,3,opt,name=language,proto3" json:"language,omitempty"`
	Keyword     string          `protobuf:"bytes,4,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string          `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Description string          `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	Children    []*FeatureChild `protobuf:"bytes,7,rep,name=children" json:"children,omitempty"`
}

func (m *Feature) Reset()         { *m = Feature{} }
func (m *Feature) String() string { return proto.CompactTextString(m) }
func (*Feature) ProtoMessage()    {}
func (*Feature) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{7}
}
func (m *Feature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Feature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Feature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Feature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Feature.Merge(dst, src)
}
func (m *Feature) XXX_Size() int {
	return m.Size()
}
func (m *Feature) XXX_DiscardUnknown() {
	xxx_messageInfo_Feature.DiscardUnknown(m)
}

var xxx_messageInfo_Feature proto.InternalMessageInfo

func (m *Feature) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Feature) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Feature) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Feature) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *Feature) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Feature) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Feature) GetChildren() []*FeatureChild {
	if m != nil {
		return m.Children
	}
	return nil
}

type FeatureChild struct {
	// Types that are valid to be assigned to Value:
	//	*FeatureChild_Rule
	//	*FeatureChild_Background
	//	*FeatureChild_Scenario
	Value isFeatureChild_Value `protobuf_oneof:"value"`
}

func (m *FeatureChild) Reset()         { *m = FeatureChild{} }
func (m *FeatureChild) String() string { return proto.CompactTextString(m) }
func (*FeatureChild) ProtoMessage()    {}
func (*FeatureChild) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{8}
}
func (m *FeatureChild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeatureChild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeatureChild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FeatureChild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeatureChild.Merge(dst, src)
}
func (m *FeatureChild) XXX_Size() int {
	return m.Size()
}
func (m *FeatureChild) XXX_DiscardUnknown() {
	xxx_messageInfo_FeatureChild.DiscardUnknown(m)
}

var xxx_messageInfo_FeatureChild proto.InternalMessageInfo

type isFeatureChild_Value interface {
	isFeatureChild_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FeatureChild_Rule struct {
	Rule *Rule `protobuf:"bytes,1,opt,name=rule,oneof"`
}
type FeatureChild_Background struct {
	Background *Background `protobuf:"bytes,2,opt,name=background,oneof"`
}
type FeatureChild_Scenario struct {
	Scenario *Scenario `protobuf:"bytes,3,opt,name=scenario,oneof"`
}

func (*FeatureChild_Rule) isFeatureChild_Value()       {}
func (*FeatureChild_Background) isFeatureChild_Value() {}
func (*FeatureChild_Scenario) isFeatureChild_Value()   {}

func (m *FeatureChild) GetValue() isFeatureChild_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *FeatureChild) GetRule() *Rule {
	if x, ok := m.GetValue().(*FeatureChild_Rule); ok {
		return x.Rule
	}
	return nil
}

func (m *FeatureChild) GetBackground() *Background {
	if x, ok := m.GetValue().(*FeatureChild_Background); ok {
		return x.Background
	}
	return nil
}

func (m *FeatureChild) GetScenario() *Scenario {
	if x, ok := m.GetValue().(*FeatureChild_Scenario); ok {
		return x.Scenario
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FeatureChild) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FeatureChild_OneofMarshaler, _FeatureChild_OneofUnmarshaler, _FeatureChild_OneofSizer, []interface{}{
		(*FeatureChild_Rule)(nil),
		(*FeatureChild_Background)(nil),
		(*FeatureChild_Scenario)(nil),
	}
}

func _FeatureChild_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FeatureChild)
	// value
	switch x := m.Value.(type) {
	case *FeatureChild_Rule:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rule); err != nil {
			return err
		}
	case *FeatureChild_Background:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Background); err != nil {
			return err
		}
	case *FeatureChild_Scenario:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Scenario); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FeatureChild.Value has unexpected type %T", x)
	}
	return nil
}

func _FeatureChild_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FeatureChild)
	switch tag {
	case 1: // value.rule
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Rule)
		err := b.DecodeMessage(msg)
		m.Value = &FeatureChild_Rule{msg}
		return true, err
	case 2: // value.background
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Background)
		err := b.DecodeMessage(msg)
		m.Value = &FeatureChild_Background{msg}
		return true, err
	case 3: // value.scenario
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Scenario)
		err := b.DecodeMessage(msg)
		m.Value = &FeatureChild_Scenario{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FeatureChild_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FeatureChild)
	// value
	switch x := m.Value.(type) {
	case *FeatureChild_Rule:
		s := proto.Size(x.Rule)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FeatureChild_Background:
		s := proto.Size(x.Background)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FeatureChild_Scenario:
		s := proto.Size(x.Scenario)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Rule struct {
	Location    *Location    `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Keyword     string       `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string       `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description string       `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Children    []*RuleChild `protobuf:"bytes,5,rep,name=children" json:"children,omitempty"`
}

func (m *Rule) Reset()         { *m = Rule{} }
func (m *Rule) String() string { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()    {}
func (*Rule) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{9}
}
func (m *Rule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Rule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Rule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Rule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Rule.Merge(dst, src)
}
func (m *Rule) XXX_Size() int {
	return m.Size()
}
func (m *Rule) XXX_DiscardUnknown() {
	xxx_messageInfo_Rule.DiscardUnknown(m)
}

var xxx_messageInfo_Rule proto.InternalMessageInfo

func (m *Rule) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Rule) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *Rule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Rule) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Rule) GetChildren() []*RuleChild {
	if m != nil {
		return m.Children
	}
	return nil
}

type RuleChild struct {
	// Types that are valid to be assigned to Value:
	//	*RuleChild_Background
	//	*RuleChild_Scenario
	Value isRuleChild_Value `protobuf_oneof:"value"`
}

func (m *RuleChild) Reset()         { *m = RuleChild{} }
func (m *RuleChild) String() string { return proto.CompactTextString(m) }
func (*RuleChild) ProtoMessage()    {}
func (*RuleChild) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{10}
}
func (m *RuleChild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuleChild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuleChild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RuleChild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuleChild.Merge(dst, src)
}
func (m *RuleChild) XXX_Size() int {
	return m.Size()
}
func (m *RuleChild) XXX_DiscardUnknown() {
	xxx_messageInfo_RuleChild.DiscardUnknown(m)
}

var xxx_messageInfo_RuleChild proto.InternalMessageInfo

type isRuleChild_Value interface {
	isRuleChild_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RuleChild_Background struct {
	Background *Background `protobuf:"bytes,1,opt,name=background,oneof"`
}
type RuleChild_Scenario struct {
	Scenario *Scenario `protobuf:"bytes,2,opt,name=scenario,oneof"`
}

func (*RuleChild_Background) isRuleChild_Value() {}
func (*RuleChild_Scenario) isRuleChild_Value()   {}

func (m *RuleChild) GetValue() isRuleChild_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *RuleChild) GetBackground() *Background {
	if x, ok := m.GetValue().(*RuleChild_Background); ok {
		return x.Background
	}
	return nil
}

func (m *RuleChild) GetScenario() *Scenario {
	if x, ok := m.GetValue().(*RuleChild_Scenario); ok {
		return x.Scenario
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RuleChild) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RuleChild_OneofMarshaler, _RuleChild_OneofUnmarshaler, _RuleChild_OneofSizer, []interface{}{
		(*RuleChild_Background)(nil),
		(*RuleChild_Scenario)(nil),
	}
}

func _RuleChild_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RuleChild)
	// value
	switch x := m.Value.(type) {
	case *RuleChild_Background:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Background); err != nil {
			return err
		}
	case *RuleChild_Scenario:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Scenario); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RuleChild.Value has unexpected type %T", x)
	}
	return nil
}

func _RuleChild_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RuleChild)
	switch tag {
	case 1: // value.background
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Background)
		err := b.DecodeMessage(msg)
		m.Value = &RuleChild_Background{msg}
		return true, err
	case 2: // value.scenario
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Scenario)
		err := b.DecodeMessage(msg)
		m.Value = &RuleChild_Scenario{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RuleChild_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RuleChild)
	// value
	switch x := m.Value.(type) {
	case *RuleChild_Background:
		s := proto.Size(x.Background)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RuleChild_Scenario:
		s := proto.Size(x.Scenario)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Background struct {
	Location    *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Keyword     string    `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string    `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description string    `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Steps       []*Step   `protobuf:"bytes,5,rep,name=steps" json:"steps,omitempty"`
}

func (m *Background) Reset()         { *m = Background{} }
func (m *Background) String() string { return proto.CompactTextString(m) }
func (*Background) ProtoMessage()    {}
func (*Background) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{11}
}
func (m *Background) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Background) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Background.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Background) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Background.Merge(dst, src)
}
func (m *Background) XXX_Size() int {
	return m.Size()
}
func (m *Background) XXX_DiscardUnknown() {
	xxx_messageInfo_Background.DiscardUnknown(m)
}

var xxx_messageInfo_Background proto.InternalMessageInfo

func (m *Background) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Background) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *Background) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Background) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Background) GetSteps() []*Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

type Scenario struct {
	Location    *Location   `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Tags        []*Tag      `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
	Keyword     string      `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string      `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Description string      `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Steps       []*Step     `protobuf:"bytes,6,rep,name=steps" json:"steps,omitempty"`
	Examples    []*Examples `protobuf:"bytes,7,rep,name=examples" json:"examples,omitempty"`
}

func (m *Scenario) Reset()         { *m = Scenario{} }
func (m *Scenario) String() string { return proto.CompactTextString(m) }
func (*Scenario) ProtoMessage()    {}
func (*Scenario) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{12}
}
func (m *Scenario) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Scenario) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Scenario.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Scenario) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Scenario.Merge(dst, src)
}
func (m *Scenario) XXX_Size() int {
	return m.Size()
}
func (m *Scenario) XXX_DiscardUnknown() {
	xxx_messageInfo_Scenario.DiscardUnknown(m)
}

var xxx_messageInfo_Scenario proto.InternalMessageInfo

func (m *Scenario) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Scenario) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Scenario) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *Scenario) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Scenario) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Scenario) GetSteps() []*Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Scenario) GetExamples() []*Examples {
	if m != nil {
		return m.Examples
	}
	return nil
}

type Comment struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Text     string    `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *Comment) Reset()         { *m = Comment{} }
func (m *Comment) String() string { return proto.CompactTextString(m) }
func (*Comment) ProtoMessage()    {}
func (*Comment) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{13}
}
func (m *Comment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Comment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Comment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Comment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Comment.Merge(dst, src)
}
func (m *Comment) XXX_Size() int {
	return m.Size()
}
func (m *Comment) XXX_DiscardUnknown() {
	xxx_messageInfo_Comment.DiscardUnknown(m)
}

var xxx_messageInfo_Comment proto.InternalMessageInfo

func (m *Comment) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Comment) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type DataTable struct {
	Location *Location   `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Rows     []*TableRow `protobuf:"bytes,2,rep,name=rows" json:"rows,omitempty"`
}

func (m *DataTable) Reset()         { *m = DataTable{} }
func (m *DataTable) String() string { return proto.CompactTextString(m) }
func (*DataTable) ProtoMessage()    {}
func (*DataTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{14}
}
func (m *DataTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DataTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataTable.Merge(dst, src)
}
func (m *DataTable) XXX_Size() int {
	return m.Size()
}
func (m *DataTable) XXX_DiscardUnknown() {
	xxx_messageInfo_DataTable.DiscardUnknown(m)
}

var xxx_messageInfo_DataTable proto.InternalMessageInfo

func (m *DataTable) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DataTable) GetRows() []*TableRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

type DocString struct {
	Location    *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	ContentType string    `protobuf:"bytes,2,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	Content     string    `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	Delimiter   string    `protobuf:"bytes,4,opt,name=delimiter,proto3" json:"delimiter,omitempty"`
}

func (m *DocString) Reset()         { *m = DocString{} }
func (m *DocString) String() string { return proto.CompactTextString(m) }
func (*DocString) ProtoMessage()    {}
func (*DocString) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{15}
}
func (m *DocString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DocString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocString.Merge(dst, src)
}
func (m *DocString) XXX_Size() int {
	return m.Size()
}
func (m *DocString) XXX_DiscardUnknown() {
	xxx_messageInfo_DocString.DiscardUnknown(m)
}

var xxx_messageInfo_DocString proto.InternalMessageInfo

func (m *DocString) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DocString) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *DocString) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *DocString) GetDelimiter() string {
	if m != nil {
		return m.Delimiter
	}
	return ""
}

type Examples struct {
	Location    *Location   `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Tags        []*Tag      `protobuf:"bytes,2,rep,name=tags" json:"tags,omitempty"`
	Keyword     string      `protobuf:"bytes,3,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Name        string      `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Description string      `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	TableHeader *TableRow   `protobuf:"bytes,6,opt,name=table_header,json=tableHeader" json:"table_header,omitempty"`
	TableBody   []*TableRow `protobuf:"bytes,7,rep,name=table_body,json=tableBody" json:"table_body,omitempty"`
}

func (m *Examples) Reset()         { *m = Examples{} }
func (m *Examples) String() string { return proto.CompactTextString(m) }
func (*Examples) ProtoMessage()    {}
func (*Examples) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{16}
}
func (m *Examples) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Examples) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Examples.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Examples) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Examples.Merge(dst, src)
}
func (m *Examples) XXX_Size() int {
	return m.Size()
}
func (m *Examples) XXX_DiscardUnknown() {
	xxx_messageInfo_Examples.DiscardUnknown(m)
}

var xxx_messageInfo_Examples proto.InternalMessageInfo

func (m *Examples) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Examples) GetTags() []*Tag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Examples) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *Examples) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Examples) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Examples) GetTableHeader() *TableRow {
	if m != nil {
		return m.TableHeader
	}
	return nil
}

func (m *Examples) GetTableBody() []*TableRow {
	if m != nil {
		return m.TableBody
	}
	return nil
}

type Step struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Keyword  string    `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Text     string    `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	// Types that are valid to be assigned to Argument:
	//	*Step_DocString
	//	*Step_DataTable
	Argument isStep_Argument `protobuf_oneof:"argument"`
}

func (m *Step) Reset()         { *m = Step{} }
func (m *Step) String() string { return proto.CompactTextString(m) }
func (*Step) ProtoMessage()    {}
func (*Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{17}
}
func (m *Step) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Step.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Step.Merge(dst, src)
}
func (m *Step) XXX_Size() int {
	return m.Size()
}
func (m *Step) XXX_DiscardUnknown() {
	xxx_messageInfo_Step.DiscardUnknown(m)
}

var xxx_messageInfo_Step proto.InternalMessageInfo

type isStep_Argument interface {
	isStep_Argument()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Step_DocString struct {
	DocString *DocString `protobuf:"bytes,5,opt,name=doc_string,json=docString,oneof"`
}
type Step_DataTable struct {
	DataTable *DataTable `protobuf:"bytes,6,opt,name=data_table,json=dataTable,oneof"`
}

func (*Step_DocString) isStep_Argument() {}
func (*Step_DataTable) isStep_Argument() {}

func (m *Step) GetArgument() isStep_Argument {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *Step) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Step) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *Step) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Step) GetDocString() *DocString {
	if x, ok := m.GetArgument().(*Step_DocString); ok {
		return x.DocString
	}
	return nil
}

func (m *Step) GetDataTable() *DataTable {
	if x, ok := m.GetArgument().(*Step_DataTable); ok {
		return x.DataTable
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Step) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Step_OneofMarshaler, _Step_OneofUnmarshaler, _Step_OneofSizer, []interface{}{
		(*Step_DocString)(nil),
		(*Step_DataTable)(nil),
	}
}

func _Step_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Step)
	// argument
	switch x := m.Argument.(type) {
	case *Step_DocString:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DocString); err != nil {
			return err
		}
	case *Step_DataTable:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataTable); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Step.Argument has unexpected type %T", x)
	}
	return nil
}

func _Step_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Step)
	switch tag {
	case 5: // argument.doc_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DocString)
		err := b.DecodeMessage(msg)
		m.Argument = &Step_DocString{msg}
		return true, err
	case 6: // argument.data_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DataTable)
		err := b.DecodeMessage(msg)
		m.Argument = &Step_DataTable{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Step_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Step)
	// argument
	switch x := m.Argument.(type) {
	case *Step_DocString:
		s := proto.Size(x.DocString)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Step_DataTable:
		s := proto.Size(x.DataTable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TableCell struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Value    string    `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *TableCell) Reset()         { *m = TableCell{} }
func (m *TableCell) String() string { return proto.CompactTextString(m) }
func (*TableCell) ProtoMessage()    {}
func (*TableCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{18}
}
func (m *TableCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TableCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableCell.Merge(dst, src)
}
func (m *TableCell) XXX_Size() int {
	return m.Size()
}
func (m *TableCell) XXX_DiscardUnknown() {
	xxx_messageInfo_TableCell.DiscardUnknown(m)
}

var xxx_messageInfo_TableCell proto.InternalMessageInfo

func (m *TableCell) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *TableCell) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type TableRow struct {
	Location *Location    `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Cells    []*TableCell `protobuf:"bytes,2,rep,name=cells" json:"cells,omitempty"`
}

func (m *TableRow) Reset()         { *m = TableRow{} }
func (m *TableRow) String() string { return proto.CompactTextString(m) }
func (*TableRow) ProtoMessage()    {}
func (*TableRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{19}
}
func (m *TableRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TableRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableRow.Merge(dst, src)
}
func (m *TableRow) XXX_Size() int {
	return m.Size()
}
func (m *TableRow) XXX_DiscardUnknown() {
	xxx_messageInfo_TableRow.DiscardUnknown(m)
}

var xxx_messageInfo_TableRow proto.InternalMessageInfo

func (m *TableRow) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *TableRow) GetCells() []*TableCell {
	if m != nil {
		return m.Cells
	}
	return nil
}

type Tag struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Name     string    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Tag) Reset()         { *m = Tag{} }
func (m *Tag) String() string { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()    {}
func (*Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{20}
}
func (m *Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tag.Merge(dst, src)
}
func (m *Tag) XXX_Size() int {
	return m.Size()
}
func (m *Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Tag proto.InternalMessageInfo

func (m *Tag) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Tag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Pickle struct {
	Id        string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Uri       string        `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
	Name      string        `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Language  string        `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	Steps     []*PickleStep `protobuf:"bytes,5,rep,name=steps" json:"steps,omitempty"`
	Tags      []*PickleTag  `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
	Locations []*Location   `protobuf:"bytes,7,rep,name=locations" json:"locations,omitempty"`
}

func (m *Pickle) Reset()         { *m = Pickle{} }
func (m *Pickle) String() string { return proto.CompactTextString(m) }
func (*Pickle) ProtoMessage()    {}
func (*Pickle) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{21}
}
func (m *Pickle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pickle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pickle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Pickle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pickle.Merge(dst, src)
}
func (m *Pickle) XXX_Size() int {
	return m.Size()
}
func (m *Pickle) XXX_DiscardUnknown() {
	xxx_messageInfo_Pickle.DiscardUnknown(m)
}

var xxx_messageInfo_Pickle proto.InternalMessageInfo

func (m *Pickle) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Pickle) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *Pickle) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pickle) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *Pickle) GetSteps() []*PickleStep {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Pickle) GetTags() []*PickleTag {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Pickle) GetLocations() []*Location {
	if m != nil {
		return m.Locations
	}
	return nil
}

type PickleStep struct {
	Text      string      `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Locations []*Location `protobuf:"bytes,2,rep,name=locations" json:"locations,omitempty"`
	// Types that are valid to be assigned to Argument:
	//	*PickleStep_DocString
	//	*PickleStep_DataTable
	Argument isPickleStep_Argument `protobuf_oneof:"argument"`
}

func (m *PickleStep) Reset()         { *m = PickleStep{} }
func (m *PickleStep) String() string { return proto.CompactTextString(m) }
func (*PickleStep) ProtoMessage()    {}
func (*PickleStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{22}
}
func (m *PickleStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PickleStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleStep.Merge(dst, src)
}
func (m *PickleStep) XXX_Size() int {
	return m.Size()
}
func (m *PickleStep) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleStep.DiscardUnknown(m)
}

var xxx_messageInfo_PickleStep proto.InternalMessageInfo

type isPickleStep_Argument interface {
	isPickleStep_Argument()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PickleStep_DocString struct {
	DocString *PickleDocString `protobuf:"bytes,3,opt,name=doc_string,json=docString,oneof"`
}
type PickleStep_DataTable struct {
	DataTable *PickleTable `protobuf:"bytes,4,opt,name=data_table,json=dataTable,oneof"`
}

func (*PickleStep_DocString) isPickleStep_Argument() {}
func (*PickleStep_DataTable) isPickleStep_Argument() {}

func (m *PickleStep) GetArgument() isPickleStep_Argument {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *PickleStep) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *PickleStep) GetLocations() []*Location {
	if m != nil {
		return m.Locations
	}
	return nil
}

func (m *PickleStep) GetDocString() *PickleDocString {
	if x, ok := m.GetArgument().(*PickleStep_DocString); ok {
		return x.DocString
	}
	return nil
}

func (m *PickleStep) GetDataTable() *PickleTable {
	if x, ok := m.GetArgument().(*PickleStep_DataTable); ok {
		return x.DataTable
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PickleStep) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PickleStep_OneofMarshaler, _PickleStep_OneofUnmarshaler, _PickleStep_OneofSizer, []interface{}{
		(*PickleStep_DocString)(nil),
		(*PickleStep_DataTable)(nil),
	}
}

func _PickleStep_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PickleStep)
	// argument
	switch x := m.Argument.(type) {
	case *PickleStep_DocString:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DocString); err != nil {
			return err
		}
	case *PickleStep_DataTable:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataTable); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PickleStep.Argument has unexpected type %T", x)
	}
	return nil
}

func _PickleStep_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PickleStep)
	switch tag {
	case 3: // argument.doc_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleDocString)
		err := b.DecodeMessage(msg)
		m.Argument = &PickleStep_DocString{msg}
		return true, err
	case 4: // argument.data_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleTable)
		err := b.DecodeMessage(msg)
		m.Argument = &PickleStep_DataTable{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PickleStep_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PickleStep)
	// argument
	switch x := m.Argument.(type) {
	case *PickleStep_DocString:
		s := proto.Size(x.DocString)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PickleStep_DataTable:
		s := proto.Size(x.DataTable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PickleDocString struct {
	Location    *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	ContentType string    `protobuf:"bytes,2,opt,name=contentType,proto3" json:"contentType,omitempty"`
	Content     string    `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *PickleDocString) Reset()         { *m = PickleDocString{} }
func (m *PickleDocString) String() string { return proto.CompactTextString(m) }
func (*PickleDocString) ProtoMessage()    {}
func (*PickleDocString) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{23}
}
func (m *PickleDocString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleDocString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleDocString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PickleDocString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleDocString.Merge(dst, src)
}
func (m *PickleDocString) XXX_Size() int {
	return m.Size()
}
func (m *PickleDocString) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleDocString.DiscardUnknown(m)
}

var xxx_messageInfo_PickleDocString proto.InternalMessageInfo

func (m *PickleDocString) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *PickleDocString) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *PickleDocString) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type PickleTable struct {
	Rows []*PickleTableRow `protobuf:"bytes,1,rep,name=rows" json:"rows,omitempty"`
}

func (m *PickleTable) Reset()         { *m = PickleTable{} }
func (m *PickleTable) String() string { return proto.CompactTextString(m) }
func (*PickleTable) ProtoMessage()    {}
func (*PickleTable) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{24}
}
func (m *PickleTable) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleTable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleTable.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PickleTable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleTable.Merge(dst, src)
}
func (m *PickleTable) XXX_Size() int {
	return m.Size()
}
func (m *PickleTable) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleTable.DiscardUnknown(m)
}

var xxx_messageInfo_PickleTable proto.InternalMessageInfo

func (m *PickleTable) GetRows() []*PickleTableRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

type PickleTableCell struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Value    string    `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PickleTableCell) Reset()         { *m = PickleTableCell{} }
func (m *PickleTableCell) String() string { return proto.CompactTextString(m) }
func (*PickleTableCell) ProtoMessage()    {}
func (*PickleTableCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{25}
}
func (m *PickleTableCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleTableCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleTableCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PickleTableCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleTableCell.Merge(dst, src)
}
func (m *PickleTableCell) XXX_Size() int {
	return m.Size()
}
func (m *PickleTableCell) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleTableCell.DiscardUnknown(m)
}

var xxx_messageInfo_PickleTableCell proto.InternalMessageInfo

func (m *PickleTableCell) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *PickleTableCell) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type PickleTableRow struct {
	Cells []*PickleTableCell `protobuf:"bytes,1,rep,name=cells" json:"cells,omitempty"`
}

func (m *PickleTableRow) Reset()         { *m = PickleTableRow{} }
func (m *PickleTableRow) String() string { return proto.CompactTextString(m) }
func (*PickleTableRow) ProtoMessage()    {}
func (*PickleTableRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{26}
}
func (m *PickleTableRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleTableRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleTableRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PickleTableRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleTableRow.Merge(dst, src)
}
func (m *PickleTableRow) XXX_Size() int {
	return m.Size()
}
func (m *PickleTableRow) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleTableRow.DiscardUnknown(m)
}

var xxx_messageInfo_PickleTableRow proto.InternalMessageInfo

func (m *PickleTableRow) GetCells() []*PickleTableCell {
	if m != nil {
		return m.Cells
	}
	return nil
}

type PickleTag struct {
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	Name     string    `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *PickleTag) Reset()         { *m = PickleTag{} }
func (m *PickleTag) String() string { return proto.CompactTextString(m) }
func (*PickleTag) ProtoMessage()    {}
func (*PickleTag) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{27}
}
func (m *PickleTag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleTag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleTag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PickleTag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleTag.Merge(dst, src)
}
func (m *PickleTag) XXX_Size() int {
	return m.Size()
}
func (m *PickleTag) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleTag.DiscardUnknown(m)
}

var xxx_messageInfo_PickleTag proto.InternalMessageInfo

func (m *PickleTag) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *PickleTag) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PickleAccepted struct {
	PickleId string `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
}

func (m *PickleAccepted) Reset()         { *m = PickleAccepted{} }
func (m *PickleAccepted) String() string { return proto.CompactTextString(m) }
func (*PickleAccepted) ProtoMessage()    {}
func (*PickleAccepted) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{28}
}
func (m *PickleAccepted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleAccepted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleAccepted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PickleAccepted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleAccepted.Merge(dst, src)
}
func (m *PickleAccepted) XXX_Size() int {
	return m.Size()
}
func (m *PickleAccepted) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleAccepted.DiscardUnknown(m)
}

var xxx_messageInfo_PickleAccepted proto.InternalMessageInfo

func (m *PickleAccepted) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

type PickleRejected struct {
	PickleId string `protobuf:"bytes,2,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
}

func (m *PickleRejected) Reset()         { *m = PickleRejected{} }
func (m *PickleRejected) String() string { return proto.CompactTextString(m) }
func (*PickleRejected) ProtoMessage()    {}
func (*PickleRejected) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{29}
}
func (m *PickleRejected) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PickleRejected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PickleRejected.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PickleRejected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PickleRejected.Merge(dst, src)
}
func (m *PickleRejected) XXX_Size() int {
	return m.Size()
}
func (m *PickleRejected) XXX_DiscardUnknown() {
	xxx_messageInfo_PickleRejected.DiscardUnknown(m)
}

var xxx_messageInfo_PickleRejected proto.InternalMessageInfo

func (m *PickleRejected) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

type TestRunStarted struct {
}

func (m *TestRunStarted) Reset()         { *m = TestRunStarted{} }
func (m *TestRunStarted) String() string { return proto.CompactTextString(m) }
func (*TestRunStarted) ProtoMessage()    {}
func (*TestRunStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{30}
}
func (m *TestRunStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestRunStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestRunStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestRunStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestRunStarted.Merge(dst, src)
}
func (m *TestRunStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestRunStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestRunStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestRunStarted proto.InternalMessageInfo

type TestCasePreparedStep struct {
	SourceLocation *SourceReference `protobuf:"bytes,1,opt,name=sourceLocation" json:"sourceLocation,omitempty"`
	ActionLocation *SourceReference `protobuf:"bytes,2,opt,name=actionLocation" json:"actionLocation,omitempty"`
}

func (m *TestCasePreparedStep) Reset()         { *m = TestCasePreparedStep{} }
func (m *TestCasePreparedStep) String() string { return proto.CompactTextString(m) }
func (*TestCasePreparedStep) ProtoMessage()    {}
func (*TestCasePreparedStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{31}
}
func (m *TestCasePreparedStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCasePreparedStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCasePreparedStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestCasePreparedStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCasePreparedStep.Merge(dst, src)
}
func (m *TestCasePreparedStep) XXX_Size() int {
	return m.Size()
}
func (m *TestCasePreparedStep) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCasePreparedStep.DiscardUnknown(m)
}

var xxx_messageInfo_TestCasePreparedStep proto.InternalMessageInfo

func (m *TestCasePreparedStep) GetSourceLocation() *SourceReference {
	if m != nil {
		return m.SourceLocation
	}
	return nil
}

func (m *TestCasePreparedStep) GetActionLocation() *SourceReference {
	if m != nil {
		return m.ActionLocation
	}
	return nil
}

type TestCasePrepared struct {
	PickleId string                  `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Steps    []*TestCasePreparedStep `protobuf:"bytes,2,rep,name=steps" json:"steps,omitempty"`
}

func (m *TestCasePrepared) Reset()         { *m = TestCasePrepared{} }
func (m *TestCasePrepared) String() string { return proto.CompactTextString(m) }
func (*TestCasePrepared) ProtoMessage()    {}
func (*TestCasePrepared) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{32}
}
func (m *TestCasePrepared) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCasePrepared) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCasePrepared.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestCasePrepared) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCasePrepared.Merge(dst, src)
}
func (m *TestCasePrepared) XXX_Size() int {
	return m.Size()
}
func (m *TestCasePrepared) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCasePrepared.DiscardUnknown(m)
}

var xxx_messageInfo_TestCasePrepared proto.InternalMessageInfo

func (m *TestCasePrepared) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestCasePrepared) GetSteps() []*TestCasePreparedStep {
	if m != nil {
		return m.Steps
	}
	return nil
}

type TestCaseStarted struct {
	PickleId  string           `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Timestamp *types.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestCaseStarted) Reset()         { *m = TestCaseStarted{} }
func (m *TestCaseStarted) String() string { return proto.CompactTextString(m) }
func (*TestCaseStarted) ProtoMessage()    {}
func (*TestCaseStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{33}
}
func (m *TestCaseStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCaseStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCaseStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestCaseStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCaseStarted.Merge(dst, src)
}
func (m *TestCaseStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestCaseStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCaseStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestCaseStarted proto.InternalMessageInfo

func (m *TestCaseStarted) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestCaseStarted) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestCaseFinished struct {
	PickleId   string           `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Timestamp  *types.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	TestResult *TestResult      `protobuf:"bytes,3,opt,name=testResult" json:"testResult,omitempty"`
}

func (m *TestCaseFinished) Reset()         { *m = TestCaseFinished{} }
func (m *TestCaseFinished) String() string { return proto.CompactTextString(m) }
func (*TestCaseFinished) ProtoMessage()    {}
func (*TestCaseFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{34}
}
func (m *TestCaseFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCaseFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCaseFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestCaseFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCaseFinished.Merge(dst, src)
}
func (m *TestCaseFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestCaseFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCaseFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestCaseFinished proto.InternalMessageInfo

func (m *TestCaseFinished) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestCaseFinished) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *TestCaseFinished) GetTestResult() *TestResult {
	if m != nil {
		return m.TestResult
	}
	return nil
}

type TestStepStarted struct {
	PickleId  string           `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Index     uint32           `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Timestamp *types.Timestamp `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestStepStarted) Reset()         { *m = TestStepStarted{} }
func (m *TestStepStarted) String() string { return proto.CompactTextString(m) }
func (*TestStepStarted) ProtoMessage()    {}
func (*TestStepStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{35}
}
func (m *TestStepStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestStepStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestStepStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestStepStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestStepStarted.Merge(dst, src)
}
func (m *TestStepStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestStepStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestStepStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestStepStarted proto.InternalMessageInfo

func (m *TestStepStarted) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestStepStarted) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *TestStepStarted) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestStepFinished struct {
	PickleId   string           `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Index      uint32           `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	TestResult *TestResult      `protobuf:"bytes,3,opt,name=testResult" json:"testResult,omitempty"`
	Timestamp  *types.Timestamp `protobuf:"bytes,4,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestStepFinished) Reset()         { *m = TestStepFinished{} }
func (m *TestStepFinished) String() string { return proto.CompactTextString(m) }
func (*TestStepFinished) ProtoMessage()    {}
func (*TestStepFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{36}
}
func (m *TestStepFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestStepFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestStepFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestStepFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestStepFinished.Merge(dst, src)
}
func (m *TestStepFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestStepFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestStepFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestStepFinished proto.InternalMessageInfo

func (m *TestStepFinished) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestStepFinished) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *TestStepFinished) GetTestResult() *TestResult {
	if m != nil {
		return m.TestResult
	}
	return nil
}

func (m *TestStepFinished) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestHookStarted struct {
	PickleId  string           `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	Timestamp *types.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestHookStarted) Reset()         { *m = TestHookStarted{} }
func (m *TestHookStarted) String() string { return proto.CompactTextString(m) }
func (*TestHookStarted) ProtoMessage()    {}
func (*TestHookStarted) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{37}
}
func (m *TestHookStarted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestHookStarted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestHookStarted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestHookStarted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestHookStarted.Merge(dst, src)
}
func (m *TestHookStarted) XXX_Size() int {
	return m.Size()
}
func (m *TestHookStarted) XXX_DiscardUnknown() {
	xxx_messageInfo_TestHookStarted.DiscardUnknown(m)
}

var xxx_messageInfo_TestHookStarted proto.InternalMessageInfo

func (m *TestHookStarted) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestHookStarted) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestHookFinished struct {
	PickleId   string           `protobuf:"bytes,1,opt,name=pickleId,proto3" json:"pickleId,omitempty"`
	TestResult *TestResult      `protobuf:"bytes,2,opt,name=testResult" json:"testResult,omitempty"`
	Timestamp  *types.Timestamp `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *TestHookFinished) Reset()         { *m = TestHookFinished{} }
func (m *TestHookFinished) String() string { return proto.CompactTextString(m) }
func (*TestHookFinished) ProtoMessage()    {}
func (*TestHookFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{38}
}
func (m *TestHookFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestHookFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestHookFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestHookFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestHookFinished.Merge(dst, src)
}
func (m *TestHookFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestHookFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestHookFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestHookFinished proto.InternalMessageInfo

func (m *TestHookFinished) GetPickleId() string {
	if m != nil {
		return m.PickleId
	}
	return ""
}

func (m *TestHookFinished) GetTestResult() *TestResult {
	if m != nil {
		return m.TestResult
	}
	return nil
}

func (m *TestHookFinished) GetTimestamp() *types.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type TestResult struct {
	Status              Status `protobuf:"varint,1,opt,name=status,proto3,enum=io.cucumber.messages.Status" json:"status,omitempty"`
	Message             string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	DurationNanoseconds uint64 `protobuf:"varint,3,opt,name=durationNanoseconds,proto3" json:"durationNanoseconds,omitempty"`
}

func (m *TestResult) Reset()         { *m = TestResult{} }
func (m *TestResult) String() string { return proto.CompactTextString(m) }
func (*TestResult) ProtoMessage()    {}
func (*TestResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{39}
}
func (m *TestResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestResult.Merge(dst, src)
}
func (m *TestResult) XXX_Size() int {
	return m.Size()
}
func (m *TestResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TestResult.DiscardUnknown(m)
}

var xxx_messageInfo_TestResult proto.InternalMessageInfo

func (m *TestResult) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_AMBIGUOUS
}

func (m *TestResult) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TestResult) GetDurationNanoseconds() uint64 {
	if m != nil {
		return m.DurationNanoseconds
	}
	return 0
}

type TestRunFinished struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *TestRunFinished) Reset()         { *m = TestRunFinished{} }
func (m *TestRunFinished) String() string { return proto.CompactTextString(m) }
func (*TestRunFinished) ProtoMessage()    {}
func (*TestRunFinished) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{40}
}
func (m *TestRunFinished) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestRunFinished) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestRunFinished.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestRunFinished) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestRunFinished.Merge(dst, src)
}
func (m *TestRunFinished) XXX_Size() int {
	return m.Size()
}
func (m *TestRunFinished) XXX_DiscardUnknown() {
	xxx_messageInfo_TestRunFinished.DiscardUnknown(m)
}

var xxx_messageInfo_TestRunFinished proto.InternalMessageInfo

func (m *TestRunFinished) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type CommandStart struct {
	BaseDirectory     string             `protobuf:"bytes,2,opt,name=baseDirectory,proto3" json:"baseDirectory,omitempty"`
	SourcesConfig     *SourcesConfig     `protobuf:"bytes,3,opt,name=sourcesConfig" json:"sourcesConfig,omitempty"`
	RuntimeConfig     *RuntimeConfig     `protobuf:"bytes,4,opt,name=runtimeConfig" json:"runtimeConfig,omitempty"`
	SupportCodeConfig *SupportCodeConfig `protobuf:"bytes,5,opt,name=supportCodeConfig" json:"supportCodeConfig,omitempty"`
}

func (m *CommandStart) Reset()         { *m = CommandStart{} }
func (m *CommandStart) String() string { return proto.CompactTextString(m) }
func (*CommandStart) ProtoMessage()    {}
func (*CommandStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{41}
}
func (m *CommandStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandStart.Merge(dst, src)
}
func (m *CommandStart) XXX_Size() int {
	return m.Size()
}
func (m *CommandStart) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandStart.DiscardUnknown(m)
}

var xxx_messageInfo_CommandStart proto.InternalMessageInfo

func (m *CommandStart) GetBaseDirectory() string {
	if m != nil {
		return m.BaseDirectory
	}
	return ""
}

func (m *CommandStart) GetSourcesConfig() *SourcesConfig {
	if m != nil {
		return m.SourcesConfig
	}
	return nil
}

func (m *CommandStart) GetRuntimeConfig() *RuntimeConfig {
	if m != nil {
		return m.RuntimeConfig
	}
	return nil
}

func (m *CommandStart) GetSupportCodeConfig() *SupportCodeConfig {
	if m != nil {
		return m.SupportCodeConfig
	}
	return nil
}

type SourcesConfig struct {
	AbsolutePaths []string             `protobuf:"bytes,1,rep,name=absolutePaths" json:"absolutePaths,omitempty"`
	Language      string               `protobuf:"bytes,2,opt,name=language,proto3" json:"language,omitempty"`
	Filters       *SourcesFilterConfig `protobuf:"bytes,3,opt,name=filters" json:"filters,omitempty"`
	Order         *SourcesOrder        `protobuf:"bytes,4,opt,name=order" json:"order,omitempty"`
}

func (m *SourcesConfig) Reset()         { *m = SourcesConfig{} }
func (m *SourcesConfig) String() string { return proto.CompactTextString(m) }
func (*SourcesConfig) ProtoMessage()    {}
func (*SourcesConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{42}
}
func (m *SourcesConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourcesConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourcesConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SourcesConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourcesConfig.Merge(dst, src)
}
func (m *SourcesConfig) XXX_Size() int {
	return m.Size()
}
func (m *SourcesConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SourcesConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SourcesConfig proto.InternalMessageInfo

func (m *SourcesConfig) GetAbsolutePaths() []string {
	if m != nil {
		return m.AbsolutePaths
	}
	return nil
}

func (m *SourcesConfig) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *SourcesConfig) GetFilters() *SourcesFilterConfig {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *SourcesConfig) GetOrder() *SourcesOrder {
	if m != nil {
		return m.Order
	}
	return nil
}

type SourcesFilterConfig struct {
	TagExpression          string               `protobuf:"bytes,1,opt,name=tagExpression,proto3" json:"tagExpression,omitempty"`
	NameRegularExpressions []string             `protobuf:"bytes,2,rep,name=nameRegularExpressions" json:"nameRegularExpressions,omitempty"`
	UriToLinesMapping      []*UriToLinesMapping `protobuf:"bytes,3,rep,name=uriToLinesMapping" json:"uriToLinesMapping,omitempty"`
}

func (m *SourcesFilterConfig) Reset()         { *m = SourcesFilterConfig{} }
func (m *SourcesFilterConfig) String() string { return proto.CompactTextString(m) }
func (*SourcesFilterConfig) ProtoMessage()    {}
func (*SourcesFilterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{43}
}
func (m *SourcesFilterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourcesFilterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourcesFilterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SourcesFilterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourcesFilterConfig.Merge(dst, src)
}
func (m *SourcesFilterConfig) XXX_Size() int {
	return m.Size()
}
func (m *SourcesFilterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SourcesFilterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SourcesFilterConfig proto.InternalMessageInfo

func (m *SourcesFilterConfig) GetTagExpression() string {
	if m != nil {
		return m.TagExpression
	}
	return ""
}

func (m *SourcesFilterConfig) GetNameRegularExpressions() []string {
	if m != nil {
		return m.NameRegularExpressions
	}
	return nil
}

func (m *SourcesFilterConfig) GetUriToLinesMapping() []*UriToLinesMapping {
	if m != nil {
		return m.UriToLinesMapping
	}
	return nil
}

type UriToLinesMapping struct {
	AbsolutePath string   `protobuf:"bytes,1,opt,name=absolutePath,proto3" json:"absolutePath,omitempty"`
	Lines        []uint64 `protobuf:"varint,2,rep,packed,name=lines" json:"lines,omitempty"`
}

func (m *UriToLinesMapping) Reset()         { *m = UriToLinesMapping{} }
func (m *UriToLinesMapping) String() string { return proto.CompactTextString(m) }
func (*UriToLinesMapping) ProtoMessage()    {}
func (*UriToLinesMapping) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{44}
}
func (m *UriToLinesMapping) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UriToLinesMapping) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UriToLinesMapping.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UriToLinesMapping) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UriToLinesMapping.Merge(dst, src)
}
func (m *UriToLinesMapping) XXX_Size() int {
	return m.Size()
}
func (m *UriToLinesMapping) XXX_DiscardUnknown() {
	xxx_messageInfo_UriToLinesMapping.DiscardUnknown(m)
}

var xxx_messageInfo_UriToLinesMapping proto.InternalMessageInfo

func (m *UriToLinesMapping) GetAbsolutePath() string {
	if m != nil {
		return m.AbsolutePath
	}
	return ""
}

func (m *UriToLinesMapping) GetLines() []uint64 {
	if m != nil {
		return m.Lines
	}
	return nil
}

type SourcesOrder struct {
	Type SourcesOrderType `protobuf:"varint,1,opt,name=type,proto3,enum=io.cucumber.messages.SourcesOrderType" json:"type,omitempty"`
	Seed uint64           `protobuf:"varint,2,opt,name=seed,proto3" json:"seed,omitempty"`
}

func (m *SourcesOrder) Reset()         { *m = SourcesOrder{} }
func (m *SourcesOrder) String() string { return proto.CompactTextString(m) }
func (*SourcesOrder) ProtoMessage()    {}
func (*SourcesOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{45}
}
func (m *SourcesOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourcesOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourcesOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SourcesOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourcesOrder.Merge(dst, src)
}
func (m *SourcesOrder) XXX_Size() int {
	return m.Size()
}
func (m *SourcesOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_SourcesOrder.DiscardUnknown(m)
}

var xxx_messageInfo_SourcesOrder proto.InternalMessageInfo

func (m *SourcesOrder) GetType() SourcesOrderType {
	if m != nil {
		return m.Type
	}
	return SourcesOrderType_ORDER_OF_DEFINITION
}

func (m *SourcesOrder) GetSeed() uint64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

type RuntimeConfig struct {
	IsFailFast  bool   `protobuf:"varint,1,opt,name=isFailFast,proto3" json:"isFailFast,omitempty"`
	IsDryRun    bool   `protobuf:"varint,2,opt,name=isDryRun,proto3" json:"isDryRun,omitempty"`
	IsStrict    bool   `protobuf:"varint,3,opt,name=isStrict,proto3" json:"isStrict,omitempty"`
	MaxParallel uint64 `protobuf:"varint,4,opt,name=maxParallel,proto3" json:"maxParallel,omitempty"`
}

func (m *RuntimeConfig) Reset()         { *m = RuntimeConfig{} }
func (m *RuntimeConfig) String() string { return proto.CompactTextString(m) }
func (*RuntimeConfig) ProtoMessage()    {}
func (*RuntimeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{46}
}
func (m *RuntimeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RuntimeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RuntimeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RuntimeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RuntimeConfig.Merge(dst, src)
}
func (m *RuntimeConfig) XXX_Size() int {
	return m.Size()
}
func (m *RuntimeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RuntimeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RuntimeConfig proto.InternalMessageInfo

func (m *RuntimeConfig) GetIsFailFast() bool {
	if m != nil {
		return m.IsFailFast
	}
	return false
}

func (m *RuntimeConfig) GetIsDryRun() bool {
	if m != nil {
		return m.IsDryRun
	}
	return false
}

func (m *RuntimeConfig) GetIsStrict() bool {
	if m != nil {
		return m.IsStrict
	}
	return false
}

func (m *RuntimeConfig) GetMaxParallel() uint64 {
	if m != nil {
		return m.MaxParallel
	}
	return 0
}

type SupportCodeConfig struct {
	BeforeTestCaseHookDefinitionConfigs []*TestCaseHookDefinitionConfig `protobuf:"bytes,1,rep,name=beforeTestCaseHookDefinitionConfigs" json:"beforeTestCaseHookDefinitionConfigs,omitempty"`
	AfterTestCaseHookDefinitionConfigs  []*TestCaseHookDefinitionConfig `protobuf:"bytes,2,rep,name=afterTestCaseHookDefinitionConfigs" json:"afterTestCaseHookDefinitionConfigs,omitempty"`
	StepDefinitionConfigs               []*StepDefinitionConfig         `protobuf:"bytes,3,rep,name=stepDefinitionConfigs" json:"stepDefinitionConfigs,omitempty"`
	ParameterTypeConfigs                []*ParameterTypeConfig          `protobuf:"bytes,4,rep,name=parameterTypeConfigs" json:"parameterTypeConfigs,omitempty"`
}

func (m *SupportCodeConfig) Reset()         { *m = SupportCodeConfig{} }
func (m *SupportCodeConfig) String() string { return proto.CompactTextString(m) }
func (*SupportCodeConfig) ProtoMessage()    {}
func (*SupportCodeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{47}
}
func (m *SupportCodeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupportCodeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupportCodeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SupportCodeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupportCodeConfig.Merge(dst, src)
}
func (m *SupportCodeConfig) XXX_Size() int {
	return m.Size()
}
func (m *SupportCodeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SupportCodeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SupportCodeConfig proto.InternalMessageInfo

func (m *SupportCodeConfig) GetBeforeTestCaseHookDefinitionConfigs() []*TestCaseHookDefinitionConfig {
	if m != nil {
		return m.BeforeTestCaseHookDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetAfterTestCaseHookDefinitionConfigs() []*TestCaseHookDefinitionConfig {
	if m != nil {
		return m.AfterTestCaseHookDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetStepDefinitionConfigs() []*StepDefinitionConfig {
	if m != nil {
		return m.StepDefinitionConfigs
	}
	return nil
}

func (m *SupportCodeConfig) GetParameterTypeConfigs() []*ParameterTypeConfig {
	if m != nil {
		return m.ParameterTypeConfigs
	}
	return nil
}

type TestCaseHookDefinitionConfig struct {
	Id            string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	TagExpression string           `protobuf:"bytes,2,opt,name=tagExpression,proto3" json:"tagExpression,omitempty"`
	Location      *SourceReference `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
}

func (m *TestCaseHookDefinitionConfig) Reset()         { *m = TestCaseHookDefinitionConfig{} }
func (m *TestCaseHookDefinitionConfig) String() string { return proto.CompactTextString(m) }
func (*TestCaseHookDefinitionConfig) ProtoMessage()    {}
func (*TestCaseHookDefinitionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{48}
}
func (m *TestCaseHookDefinitionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestCaseHookDefinitionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestCaseHookDefinitionConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TestCaseHookDefinitionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCaseHookDefinitionConfig.Merge(dst, src)
}
func (m *TestCaseHookDefinitionConfig) XXX_Size() int {
	return m.Size()
}
func (m *TestCaseHookDefinitionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCaseHookDefinitionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TestCaseHookDefinitionConfig proto.InternalMessageInfo

func (m *TestCaseHookDefinitionConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TestCaseHookDefinitionConfig) GetTagExpression() string {
	if m != nil {
		return m.TagExpression
	}
	return ""
}

func (m *TestCaseHookDefinitionConfig) GetLocation() *SourceReference {
	if m != nil {
		return m.Location
	}
	return nil
}

type StepDefinitionConfig struct {
	Id       string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Pattern  *StepDefinitionPattern `protobuf:"bytes,2,opt,name=pattern" json:"pattern,omitempty"`
	Location *SourceReference       `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
}

func (m *StepDefinitionConfig) Reset()         { *m = StepDefinitionConfig{} }
func (m *StepDefinitionConfig) String() string { return proto.CompactTextString(m) }
func (*StepDefinitionConfig) ProtoMessage()    {}
func (*StepDefinitionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{49}
}
func (m *StepDefinitionConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepDefinitionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepDefinitionConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StepDefinitionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepDefinitionConfig.Merge(dst, src)
}
func (m *StepDefinitionConfig) XXX_Size() int {
	return m.Size()
}
func (m *StepDefinitionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_StepDefinitionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_StepDefinitionConfig proto.InternalMessageInfo

func (m *StepDefinitionConfig) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StepDefinitionConfig) GetPattern() *StepDefinitionPattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *StepDefinitionConfig) GetLocation() *SourceReference {
	if m != nil {
		return m.Location
	}
	return nil
}

type StepDefinitionPattern struct {
	Source string                    `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	Type   StepDefinitionPatternType `protobuf:"varint,2,opt,name=type,proto3,enum=io.cucumber.messages.StepDefinitionPatternType" json:"type,omitempty"`
}

func (m *StepDefinitionPattern) Reset()         { *m = StepDefinitionPattern{} }
func (m *StepDefinitionPattern) String() string { return proto.CompactTextString(m) }
func (*StepDefinitionPattern) ProtoMessage()    {}
func (*StepDefinitionPattern) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{50}
}
func (m *StepDefinitionPattern) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepDefinitionPattern) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepDefinitionPattern.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StepDefinitionPattern) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepDefinitionPattern.Merge(dst, src)
}
func (m *StepDefinitionPattern) XXX_Size() int {
	return m.Size()
}
func (m *StepDefinitionPattern) XXX_DiscardUnknown() {
	xxx_messageInfo_StepDefinitionPattern.DiscardUnknown(m)
}

var xxx_messageInfo_StepDefinitionPattern proto.InternalMessageInfo

func (m *StepDefinitionPattern) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *StepDefinitionPattern) GetType() StepDefinitionPatternType {
	if m != nil {
		return m.Type
	}
	return StepDefinitionPatternType_CUCUMBER_EXPRESSION
}

type ParameterTypeConfig struct {
	Name                            string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	RegularExpressions              []string `protobuf:"bytes,2,rep,name=regularExpressions" json:"regularExpressions,omitempty"`
	PreferForRegularExpressionMatch bool     `protobuf:"varint,3,opt,name=preferForRegularExpressionMatch,proto3" json:"preferForRegularExpressionMatch,omitempty"`
	UseForSnippets                  bool     `protobuf:"varint,4,opt,name=useForSnippets,proto3" json:"useForSnippets,omitempty"`
}

func (m *ParameterTypeConfig) Reset()         { *m = ParameterTypeConfig{} }
func (m *ParameterTypeConfig) String() string { return proto.CompactTextString(m) }
func (*ParameterTypeConfig) ProtoMessage()    {}
func (*ParameterTypeConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{51}
}
func (m *ParameterTypeConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParameterTypeConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParameterTypeConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ParameterTypeConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParameterTypeConfig.Merge(dst, src)
}
func (m *ParameterTypeConfig) XXX_Size() int {
	return m.Size()
}
func (m *ParameterTypeConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ParameterTypeConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ParameterTypeConfig proto.InternalMessageInfo

func (m *ParameterTypeConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ParameterTypeConfig) GetRegularExpressions() []string {
	if m != nil {
		return m.RegularExpressions
	}
	return nil
}

func (m *ParameterTypeConfig) GetPreferForRegularExpressionMatch() bool {
	if m != nil {
		return m.PreferForRegularExpressionMatch
	}
	return false
}

func (m *ParameterTypeConfig) GetUseForSnippets() bool {
	if m != nil {
		return m.UseForSnippets
	}
	return false
}

type CommandActionComplete struct {
	CompletedId string `protobuf:"bytes,1,opt,name=completedId,proto3" json:"completedId,omitempty"`
	// Types that are valid to be assigned to Result:
	//	*CommandActionComplete_TestResult
	//	*CommandActionComplete_Snippet
	Result isCommandActionComplete_Result `protobuf_oneof:"result"`
}

func (m *CommandActionComplete) Reset()         { *m = CommandActionComplete{} }
func (m *CommandActionComplete) String() string { return proto.CompactTextString(m) }
func (*CommandActionComplete) ProtoMessage()    {}
func (*CommandActionComplete) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{52}
}
func (m *CommandActionComplete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandActionComplete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandActionComplete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandActionComplete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandActionComplete.Merge(dst, src)
}
func (m *CommandActionComplete) XXX_Size() int {
	return m.Size()
}
func (m *CommandActionComplete) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandActionComplete.DiscardUnknown(m)
}

var xxx_messageInfo_CommandActionComplete proto.InternalMessageInfo

type isCommandActionComplete_Result interface {
	isCommandActionComplete_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CommandActionComplete_TestResult struct {
	TestResult *TestResult `protobuf:"bytes,2,opt,name=testResult,oneof"`
}
type CommandActionComplete_Snippet struct {
	Snippet string `protobuf:"bytes,3,opt,name=snippet,proto3,oneof"`
}

func (*CommandActionComplete_TestResult) isCommandActionComplete_Result() {}
func (*CommandActionComplete_Snippet) isCommandActionComplete_Result()    {}

func (m *CommandActionComplete) GetResult() isCommandActionComplete_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *CommandActionComplete) GetCompletedId() string {
	if m != nil {
		return m.CompletedId
	}
	return ""
}

func (m *CommandActionComplete) GetTestResult() *TestResult {
	if x, ok := m.GetResult().(*CommandActionComplete_TestResult); ok {
		return x.TestResult
	}
	return nil
}

func (m *CommandActionComplete) GetSnippet() string {
	if x, ok := m.GetResult().(*CommandActionComplete_Snippet); ok {
		return x.Snippet
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommandActionComplete) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommandActionComplete_OneofMarshaler, _CommandActionComplete_OneofUnmarshaler, _CommandActionComplete_OneofSizer, []interface{}{
		(*CommandActionComplete_TestResult)(nil),
		(*CommandActionComplete_Snippet)(nil),
	}
}

func _CommandActionComplete_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommandActionComplete)
	// result
	switch x := m.Result.(type) {
	case *CommandActionComplete_TestResult:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TestResult); err != nil {
			return err
		}
	case *CommandActionComplete_Snippet:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Snippet)
	case nil:
	default:
		return fmt.Errorf("CommandActionComplete.Result has unexpected type %T", x)
	}
	return nil
}

func _CommandActionComplete_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommandActionComplete)
	switch tag {
	case 2: // result.testResult
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TestResult)
		err := b.DecodeMessage(msg)
		m.Result = &CommandActionComplete_TestResult{msg}
		return true, err
	case 3: // result.snippet
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Result = &CommandActionComplete_Snippet{x}
		return true, err
	default:
		return false, nil
	}
}

func _CommandActionComplete_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommandActionComplete)
	// result
	switch x := m.Result.(type) {
	case *CommandActionComplete_TestResult:
		s := proto.Size(x.TestResult)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandActionComplete_Snippet:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Snippet)))
		n += len(x.Snippet)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CommandRunBeforeTestRunHooks struct {
	ActionId string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
}

func (m *CommandRunBeforeTestRunHooks) Reset()         { *m = CommandRunBeforeTestRunHooks{} }
func (m *CommandRunBeforeTestRunHooks) String() string { return proto.CompactTextString(m) }
func (*CommandRunBeforeTestRunHooks) ProtoMessage()    {}
func (*CommandRunBeforeTestRunHooks) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{53}
}
func (m *CommandRunBeforeTestRunHooks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunBeforeTestRunHooks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunBeforeTestRunHooks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandRunBeforeTestRunHooks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunBeforeTestRunHooks.Merge(dst, src)
}
func (m *CommandRunBeforeTestRunHooks) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunBeforeTestRunHooks) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunBeforeTestRunHooks.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunBeforeTestRunHooks proto.InternalMessageInfo

func (m *CommandRunBeforeTestRunHooks) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

type CommandRunAfterTestRunHooks struct {
	ActionId string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
}

func (m *CommandRunAfterTestRunHooks) Reset()         { *m = CommandRunAfterTestRunHooks{} }
func (m *CommandRunAfterTestRunHooks) String() string { return proto.CompactTextString(m) }
func (*CommandRunAfterTestRunHooks) ProtoMessage()    {}
func (*CommandRunAfterTestRunHooks) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{54}
}
func (m *CommandRunAfterTestRunHooks) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunAfterTestRunHooks) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunAfterTestRunHooks.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandRunAfterTestRunHooks) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunAfterTestRunHooks.Merge(dst, src)
}
func (m *CommandRunAfterTestRunHooks) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunAfterTestRunHooks) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunAfterTestRunHooks.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunAfterTestRunHooks proto.InternalMessageInfo

func (m *CommandRunAfterTestRunHooks) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

type CommandInitializeTestCase struct {
	ActionId   string  `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	TestCaseId string  `protobuf:"bytes,2,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
	Pickle     *Pickle `protobuf:"bytes,3,opt,name=pickle" json:"pickle,omitempty"`
}

func (m *CommandInitializeTestCase) Reset()         { *m = CommandInitializeTestCase{} }
func (m *CommandInitializeTestCase) String() string { return proto.CompactTextString(m) }
func (*CommandInitializeTestCase) ProtoMessage()    {}
func (*CommandInitializeTestCase) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{55}
}
func (m *CommandInitializeTestCase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandInitializeTestCase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandInitializeTestCase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandInitializeTestCase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandInitializeTestCase.Merge(dst, src)
}
func (m *CommandInitializeTestCase) XXX_Size() int {
	return m.Size()
}
func (m *CommandInitializeTestCase) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandInitializeTestCase.DiscardUnknown(m)
}

var xxx_messageInfo_CommandInitializeTestCase proto.InternalMessageInfo

func (m *CommandInitializeTestCase) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandInitializeTestCase) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

func (m *CommandInitializeTestCase) GetPickle() *Pickle {
	if m != nil {
		return m.Pickle
	}
	return nil
}

type CommandRunBeforeTestCaseHook struct {
	ActionId                 string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	TestCaseId               string `protobuf:"bytes,2,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
	TestCaseHookDefinitionId string `protobuf:"bytes,3,opt,name=testCaseHookDefinitionId,proto3" json:"testCaseHookDefinitionId,omitempty"`
}

func (m *CommandRunBeforeTestCaseHook) Reset()         { *m = CommandRunBeforeTestCaseHook{} }
func (m *CommandRunBeforeTestCaseHook) String() string { return proto.CompactTextString(m) }
func (*CommandRunBeforeTestCaseHook) ProtoMessage()    {}
func (*CommandRunBeforeTestCaseHook) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{56}
}
func (m *CommandRunBeforeTestCaseHook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunBeforeTestCaseHook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunBeforeTestCaseHook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandRunBeforeTestCaseHook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunBeforeTestCaseHook.Merge(dst, src)
}
func (m *CommandRunBeforeTestCaseHook) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunBeforeTestCaseHook) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunBeforeTestCaseHook.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunBeforeTestCaseHook proto.InternalMessageInfo

func (m *CommandRunBeforeTestCaseHook) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandRunBeforeTestCaseHook) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

func (m *CommandRunBeforeTestCaseHook) GetTestCaseHookDefinitionId() string {
	if m != nil {
		return m.TestCaseHookDefinitionId
	}
	return ""
}

type CommandRunAfterTestCaseHook struct {
	ActionId                 string `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	TestCaseId               string `protobuf:"bytes,2,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
	TestCaseHookDefinitionId string `protobuf:"bytes,3,opt,name=testCaseHookDefinitionId,proto3" json:"testCaseHookDefinitionId,omitempty"`
}

func (m *CommandRunAfterTestCaseHook) Reset()         { *m = CommandRunAfterTestCaseHook{} }
func (m *CommandRunAfterTestCaseHook) String() string { return proto.CompactTextString(m) }
func (*CommandRunAfterTestCaseHook) ProtoMessage()    {}
func (*CommandRunAfterTestCaseHook) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{57}
}
func (m *CommandRunAfterTestCaseHook) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunAfterTestCaseHook) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunAfterTestCaseHook.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandRunAfterTestCaseHook) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunAfterTestCaseHook.Merge(dst, src)
}
func (m *CommandRunAfterTestCaseHook) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunAfterTestCaseHook) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunAfterTestCaseHook.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunAfterTestCaseHook proto.InternalMessageInfo

func (m *CommandRunAfterTestCaseHook) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandRunAfterTestCaseHook) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

func (m *CommandRunAfterTestCaseHook) GetTestCaseHookDefinitionId() string {
	if m != nil {
		return m.TestCaseHookDefinitionId
	}
	return ""
}

type CommandRunTestStep struct {
	ActionId         string          `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	TestCaseId       string          `protobuf:"bytes,2,opt,name=testCaseId,proto3" json:"testCaseId,omitempty"`
	StepDefinitionId string          `protobuf:"bytes,3,opt,name=stepDefinitionId,proto3" json:"stepDefinitionId,omitempty"`
	PatternMatches   []*PatternMatch `protobuf:"bytes,4,rep,name=patternMatches" json:"patternMatches,omitempty"`
}

func (m *CommandRunTestStep) Reset()         { *m = CommandRunTestStep{} }
func (m *CommandRunTestStep) String() string { return proto.CompactTextString(m) }
func (*CommandRunTestStep) ProtoMessage()    {}
func (*CommandRunTestStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{58}
}
func (m *CommandRunTestStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandRunTestStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandRunTestStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandRunTestStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandRunTestStep.Merge(dst, src)
}
func (m *CommandRunTestStep) XXX_Size() int {
	return m.Size()
}
func (m *CommandRunTestStep) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandRunTestStep.DiscardUnknown(m)
}

var xxx_messageInfo_CommandRunTestStep proto.InternalMessageInfo

func (m *CommandRunTestStep) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandRunTestStep) GetTestCaseId() string {
	if m != nil {
		return m.TestCaseId
	}
	return ""
}

func (m *CommandRunTestStep) GetStepDefinitionId() string {
	if m != nil {
		return m.StepDefinitionId
	}
	return ""
}

func (m *CommandRunTestStep) GetPatternMatches() []*PatternMatch {
	if m != nil {
		return m.PatternMatches
	}
	return nil
}

type PatternMatch struct {
	Captures          []string `protobuf:"bytes,1,rep,name=captures" json:"captures,omitempty"`
	ParameterTypeName string   `protobuf:"bytes,2,opt,name=parameterTypeName,proto3" json:"parameterTypeName,omitempty"`
	// Types that are valid to be assigned to PickleArgument:
	//	*PatternMatch_DocString
	//	*PatternMatch_DataTable
	PickleArgument isPatternMatch_PickleArgument `protobuf_oneof:"pickleArgument"`
}

func (m *PatternMatch) Reset()         { *m = PatternMatch{} }
func (m *PatternMatch) String() string { return proto.CompactTextString(m) }
func (*PatternMatch) ProtoMessage()    {}
func (*PatternMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{59}
}
func (m *PatternMatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PatternMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PatternMatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PatternMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PatternMatch.Merge(dst, src)
}
func (m *PatternMatch) XXX_Size() int {
	return m.Size()
}
func (m *PatternMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_PatternMatch.DiscardUnknown(m)
}

var xxx_messageInfo_PatternMatch proto.InternalMessageInfo

type isPatternMatch_PickleArgument interface {
	isPatternMatch_PickleArgument()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PatternMatch_DocString struct {
	DocString *PickleDocString `protobuf:"bytes,3,opt,name=doc_string,json=docString,oneof"`
}
type PatternMatch_DataTable struct {
	DataTable *PickleTable `protobuf:"bytes,4,opt,name=data_table,json=dataTable,oneof"`
}

func (*PatternMatch_DocString) isPatternMatch_PickleArgument() {}
func (*PatternMatch_DataTable) isPatternMatch_PickleArgument() {}

func (m *PatternMatch) GetPickleArgument() isPatternMatch_PickleArgument {
	if m != nil {
		return m.PickleArgument
	}
	return nil
}

func (m *PatternMatch) GetCaptures() []string {
	if m != nil {
		return m.Captures
	}
	return nil
}

func (m *PatternMatch) GetParameterTypeName() string {
	if m != nil {
		return m.ParameterTypeName
	}
	return ""
}

func (m *PatternMatch) GetDocString() *PickleDocString {
	if x, ok := m.GetPickleArgument().(*PatternMatch_DocString); ok {
		return x.DocString
	}
	return nil
}

func (m *PatternMatch) GetDataTable() *PickleTable {
	if x, ok := m.GetPickleArgument().(*PatternMatch_DataTable); ok {
		return x.DataTable
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*PatternMatch) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _PatternMatch_OneofMarshaler, _PatternMatch_OneofUnmarshaler, _PatternMatch_OneofSizer, []interface{}{
		(*PatternMatch_DocString)(nil),
		(*PatternMatch_DataTable)(nil),
	}
}

func _PatternMatch_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*PatternMatch)
	// pickleArgument
	switch x := m.PickleArgument.(type) {
	case *PatternMatch_DocString:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DocString); err != nil {
			return err
		}
	case *PatternMatch_DataTable:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataTable); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("PatternMatch.PickleArgument has unexpected type %T", x)
	}
	return nil
}

func _PatternMatch_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*PatternMatch)
	switch tag {
	case 3: // pickleArgument.doc_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleDocString)
		err := b.DecodeMessage(msg)
		m.PickleArgument = &PatternMatch_DocString{msg}
		return true, err
	case 4: // pickleArgument.data_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleTable)
		err := b.DecodeMessage(msg)
		m.PickleArgument = &PatternMatch_DataTable{msg}
		return true, err
	default:
		return false, nil
	}
}

func _PatternMatch_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*PatternMatch)
	// pickleArgument
	switch x := m.PickleArgument.(type) {
	case *PatternMatch_DocString:
		s := proto.Size(x.DocString)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *PatternMatch_DataTable:
		s := proto.Size(x.DataTable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CommandGenerateSnippet struct {
	ActionId             string                 `protobuf:"bytes,1,opt,name=actionId,proto3" json:"actionId,omitempty"`
	GeneratedExpressions []*GeneratedExpression `protobuf:"bytes,2,rep,name=generatedExpressions" json:"generatedExpressions,omitempty"`
	// Types that are valid to be assigned to PickleArgument:
	//	*CommandGenerateSnippet_DocString
	//	*CommandGenerateSnippet_DataTable
	PickleArgument isCommandGenerateSnippet_PickleArgument `protobuf_oneof:"pickleArgument"`
}

func (m *CommandGenerateSnippet) Reset()         { *m = CommandGenerateSnippet{} }
func (m *CommandGenerateSnippet) String() string { return proto.CompactTextString(m) }
func (*CommandGenerateSnippet) ProtoMessage()    {}
func (*CommandGenerateSnippet) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{60}
}
func (m *CommandGenerateSnippet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommandGenerateSnippet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommandGenerateSnippet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CommandGenerateSnippet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandGenerateSnippet.Merge(dst, src)
}
func (m *CommandGenerateSnippet) XXX_Size() int {
	return m.Size()
}
func (m *CommandGenerateSnippet) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandGenerateSnippet.DiscardUnknown(m)
}

var xxx_messageInfo_CommandGenerateSnippet proto.InternalMessageInfo

type isCommandGenerateSnippet_PickleArgument interface {
	isCommandGenerateSnippet_PickleArgument()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CommandGenerateSnippet_DocString struct {
	DocString *PickleDocString `protobuf:"bytes,3,opt,name=doc_string,json=docString,oneof"`
}
type CommandGenerateSnippet_DataTable struct {
	DataTable *PickleTable `protobuf:"bytes,4,opt,name=data_table,json=dataTable,oneof"`
}

func (*CommandGenerateSnippet_DocString) isCommandGenerateSnippet_PickleArgument() {}
func (*CommandGenerateSnippet_DataTable) isCommandGenerateSnippet_PickleArgument() {}

func (m *CommandGenerateSnippet) GetPickleArgument() isCommandGenerateSnippet_PickleArgument {
	if m != nil {
		return m.PickleArgument
	}
	return nil
}

func (m *CommandGenerateSnippet) GetActionId() string {
	if m != nil {
		return m.ActionId
	}
	return ""
}

func (m *CommandGenerateSnippet) GetGeneratedExpressions() []*GeneratedExpression {
	if m != nil {
		return m.GeneratedExpressions
	}
	return nil
}

func (m *CommandGenerateSnippet) GetDocString() *PickleDocString {
	if x, ok := m.GetPickleArgument().(*CommandGenerateSnippet_DocString); ok {
		return x.DocString
	}
	return nil
}

func (m *CommandGenerateSnippet) GetDataTable() *PickleTable {
	if x, ok := m.GetPickleArgument().(*CommandGenerateSnippet_DataTable); ok {
		return x.DataTable
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CommandGenerateSnippet) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CommandGenerateSnippet_OneofMarshaler, _CommandGenerateSnippet_OneofUnmarshaler, _CommandGenerateSnippet_OneofSizer, []interface{}{
		(*CommandGenerateSnippet_DocString)(nil),
		(*CommandGenerateSnippet_DataTable)(nil),
	}
}

func _CommandGenerateSnippet_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CommandGenerateSnippet)
	// pickleArgument
	switch x := m.PickleArgument.(type) {
	case *CommandGenerateSnippet_DocString:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DocString); err != nil {
			return err
		}
	case *CommandGenerateSnippet_DataTable:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DataTable); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CommandGenerateSnippet.PickleArgument has unexpected type %T", x)
	}
	return nil
}

func _CommandGenerateSnippet_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CommandGenerateSnippet)
	switch tag {
	case 3: // pickleArgument.doc_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleDocString)
		err := b.DecodeMessage(msg)
		m.PickleArgument = &CommandGenerateSnippet_DocString{msg}
		return true, err
	case 4: // pickleArgument.data_table
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PickleTable)
		err := b.DecodeMessage(msg)
		m.PickleArgument = &CommandGenerateSnippet_DataTable{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CommandGenerateSnippet_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CommandGenerateSnippet)
	// pickleArgument
	switch x := m.PickleArgument.(type) {
	case *CommandGenerateSnippet_DocString:
		s := proto.Size(x.DocString)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CommandGenerateSnippet_DataTable:
		s := proto.Size(x.DataTable)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GeneratedExpression struct {
	Text               string   `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	ParameterTypeNames []string `protobuf:"bytes,2,rep,name=parameterTypeNames" json:"parameterTypeNames,omitempty"`
}

func (m *GeneratedExpression) Reset()         { *m = GeneratedExpression{} }
func (m *GeneratedExpression) String() string { return proto.CompactTextString(m) }
func (*GeneratedExpression) ProtoMessage()    {}
func (*GeneratedExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_messages_623254d195b64710, []int{61}
}
func (m *GeneratedExpression) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneratedExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeneratedExpression.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GeneratedExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneratedExpression.Merge(dst, src)
}
func (m *GeneratedExpression) XXX_Size() int {
	return m.Size()
}
func (m *GeneratedExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneratedExpression.DiscardUnknown(m)
}

var xxx_messageInfo_GeneratedExpression proto.InternalMessageInfo

func (m *GeneratedExpression) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *GeneratedExpression) GetParameterTypeNames() []string {
	if m != nil {
		return m.ParameterTypeNames
	}
	return nil
}

func init() {
	proto.RegisterType((*Wrapper)(nil), "io.cucumber.messages.Wrapper")
	proto.RegisterType((*SourceReference)(nil), "io.cucumber.messages.SourceReference")
	proto.RegisterType((*Location)(nil), "io.cucumber.messages.Location")
	proto.RegisterType((*Attachment)(nil), "io.cucumber.messages.Attachment")
	proto.RegisterType((*Media)(nil), "io.cucumber.messages.Media")
	proto.RegisterType((*Source)(nil), "io.cucumber.messages.Source")
	proto.RegisterType((*GherkinDocument)(nil), "io.cucumber.messages.GherkinDocument")
	proto.RegisterType((*Feature)(nil), "io.cucumber.messages.Feature")
	proto.RegisterType((*FeatureChild)(nil), "io.cucumber.messages.FeatureChild")
	proto.RegisterType((*Rule)(nil), "io.cucumber.messages.Rule")
	proto.RegisterType((*RuleChild)(nil), "io.cucumber.messages.RuleChild")
	proto.RegisterType((*Background)(nil), "io.cucumber.messages.Background")
	proto.RegisterType((*Scenario)(nil), "io.cucumber.messages.Scenario")
	proto.RegisterType((*Comment)(nil), "io.cucumber.messages.Comment")
	proto.RegisterType((*DataTable)(nil), "io.cucumber.messages.DataTable")
	proto.RegisterType((*DocString)(nil), "io.cucumber.messages.DocString")
	proto.RegisterType((*Examples)(nil), "io.cucumber.messages.Examples")
	proto.RegisterType((*Step)(nil), "io.cucumber.messages.Step")
	proto.RegisterType((*TableCell)(nil), "io.cucumber.messages.TableCell")
	proto.RegisterType((*TableRow)(nil), "io.cucumber.messages.TableRow")
	proto.RegisterType((*Tag)(nil), "io.cucumber.messages.Tag")
	proto.RegisterType((*Pickle)(nil), "io.cucumber.messages.Pickle")
	proto.RegisterType((*PickleStep)(nil), "io.cucumber.messages.PickleStep")
	proto.RegisterType((*PickleDocString)(nil), "io.cucumber.messages.PickleDocString")
	proto.RegisterType((*PickleTable)(nil), "io.cucumber.messages.PickleTable")
	proto.RegisterType((*PickleTableCell)(nil), "io.cucumber.messages.PickleTableCell")
	proto.RegisterType((*PickleTableRow)(nil), "io.cucumber.messages.PickleTableRow")
	proto.RegisterType((*PickleTag)(nil), "io.cucumber.messages.PickleTag")
	proto.RegisterType((*PickleAccepted)(nil), "io.cucumber.messages.PickleAccepted")
	proto.RegisterType((*PickleRejected)(nil), "io.cucumber.messages.PickleRejected")
	proto.RegisterType((*TestRunStarted)(nil), "io.cucumber.messages.TestRunStarted")
	proto.RegisterType((*TestCasePreparedStep)(nil), "io.cucumber.messages.TestCasePreparedStep")
	proto.RegisterType((*TestCasePrepared)(nil), "io.cucumber.messages.TestCasePrepared")
	proto.RegisterType((*TestCaseStarted)(nil), "io.cucumber.messages.TestCaseStarted")
	proto.RegisterType((*TestCaseFinished)(nil), "io.cucumber.messages.TestCaseFinished")
	proto.RegisterType((*TestStepStarted)(nil), "io.cucumber.messages.TestStepStarted")
	proto.RegisterType((*TestStepFinished)(nil), "io.cucumber.messages.TestStepFinished")
	proto.RegisterType((*TestHookStarted)(nil), "io.cucumber.messages.TestHookStarted")
	proto.RegisterType((*TestHookFinished)(nil), "io.cucumber.messages.TestHookFinished")
	proto.RegisterType((*TestResult)(nil), "io.cucumber.messages.TestResult")
	proto.RegisterType((*TestRunFinished)(nil), "io.cucumber.messages.TestRunFinished")
	proto.RegisterType((*CommandStart)(nil), "io.cucumber.messages.CommandStart")
	proto.RegisterType((*SourcesConfig)(nil), "io.cucumber.messages.SourcesConfig")
	proto.RegisterType((*SourcesFilterConfig)(nil), "io.cucumber.messages.SourcesFilterConfig")
	proto.RegisterType((*UriToLinesMapping)(nil), "io.cucumber.messages.UriToLinesMapping")
	proto.RegisterType((*SourcesOrder)(nil), "io.cucumber.messages.SourcesOrder")
	proto.RegisterType((*RuntimeConfig)(nil), "io.cucumber.messages.RuntimeConfig")
	proto.RegisterType((*SupportCodeConfig)(nil), "io.cucumber.messages.SupportCodeConfig")
	proto.RegisterType((*TestCaseHookDefinitionConfig)(nil), "io.cucumber.messages.TestCaseHookDefinitionConfig")
	proto.RegisterType((*StepDefinitionConfig)(nil), "io.cucumber.messages.StepDefinitionConfig")
	proto.RegisterType((*StepDefinitionPattern)(nil), "io.cucumber.messages.StepDefinitionPattern")
	proto.RegisterType((*ParameterTypeConfig)(nil), "io.cucumber.messages.ParameterTypeConfig")
	proto.RegisterType((*CommandActionComplete)(nil), "io.cucumber.messages.CommandActionComplete")
	proto.RegisterType((*CommandRunBeforeTestRunHooks)(nil), "io.cucumber.messages.CommandRunBeforeTestRunHooks")
	proto.RegisterType((*CommandRunAfterTestRunHooks)(nil), "io.cucumber.messages.CommandRunAfterTestRunHooks")
	proto.RegisterType((*CommandInitializeTestCase)(nil), "io.cucumber.messages.CommandInitializeTestCase")
	proto.RegisterType((*CommandRunBeforeTestCaseHook)(nil), "io.cucumber.messages.CommandRunBeforeTestCaseHook")
	proto.RegisterType((*CommandRunAfterTestCaseHook)(nil), "io.cucumber.messages.CommandRunAfterTestCaseHook")
	proto.RegisterType((*CommandRunTestStep)(nil), "io.cucumber.messages.CommandRunTestStep")
	proto.RegisterType((*PatternMatch)(nil), "io.cucumber.messages.PatternMatch")
	proto.RegisterType((*CommandGenerateSnippet)(nil), "io.cucumber.messages.CommandGenerateSnippet")
	proto.RegisterType((*GeneratedExpression)(nil), "io.cucumber.messages.GeneratedExpression")
	proto.RegisterEnum("io.cucumber.messages.Status", Status_name, Status_value)
	proto.RegisterEnum("io.cucumber.messages.SourcesOrderType", SourcesOrderType_name, SourcesOrderType_value)
	proto.RegisterEnum("io.cucumber.messages.StepDefinitionPatternType", StepDefinitionPatternType_name, StepDefinitionPatternType_value)
}
func (m *Wrapper) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Wrapper) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		nn1, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	return i, nil
}

func (m *Wrapper_Source) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Source.Size()))
		n2, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}
func (m *Wrapper_GherkinDocument) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.GherkinDocument != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.GherkinDocument.Size()))
		n3, err := m.GherkinDocument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *Wrapper_Pickle) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Pickle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Pickle.Size()))
		n4, err := m.Pickle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Wrapper_Attachment) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Attachment != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Attachment.Size()))
		n5, err := m.Attachment.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Wrapper_TestCaseStarted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestCaseStarted != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestCaseStarted.Size()))
		n6, err := m.TestCaseStarted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Wrapper_TestStepStarted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestStepStarted != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestStepStarted.Size()))
		n7, err := m.TestStepStarted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Wrapper_TestStepFinished) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestStepFinished != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestStepFinished.Size()))
		n8, err := m.TestStepFinished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Wrapper_TestCaseFinished) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestCaseFinished != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestCaseFinished.Size()))
		n9, err := m.TestCaseFinished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Wrapper_TestHookStarted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestHookStarted != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestHookStarted.Size()))
		n10, err := m.TestHookStarted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Wrapper_TestHookFinished) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestHookFinished != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestHookFinished.Size()))
		n11, err := m.TestHookFinished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Wrapper_PickleAccepted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PickleAccepted != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.PickleAccepted.Size()))
		n12, err := m.PickleAccepted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Wrapper_PickleRejected) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PickleRejected != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.PickleRejected.Size()))
		n13, err := m.PickleRejected.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *Wrapper_TestCasePrepared) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestCasePrepared != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestCasePrepared.Size()))
		n14, err := m.TestCasePrepared.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *Wrapper_TestRunStarted) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestRunStarted != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestRunStarted.Size()))
		n15, err := m.TestRunStarted.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *Wrapper_TestRunFinished) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestRunFinished != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestRunFinished.Size()))
		n16, err := m.TestRunFinished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *Wrapper_CommandStart) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandStart != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandStart.Size()))
		n17, err := m.CommandStart.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *Wrapper_CommandActionComplete) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandActionComplete != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandActionComplete.Size()))
		n18, err := m.CommandActionComplete.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *Wrapper_CommandRunBeforeTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunBeforeTestRunHooks != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandRunBeforeTestRunHooks.Size()))
		n19, err := m.CommandRunBeforeTestRunHooks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *Wrapper_CommandInitializeTestCase) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandInitializeTestCase != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandInitializeTestCase.Size()))
		n20, err := m.CommandInitializeTestCase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *Wrapper_CommandRunBeforeTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunBeforeTestCaseHook != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandRunBeforeTestCaseHook.Size()))
		n21, err := m.CommandRunBeforeTestCaseHook.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *Wrapper_CommandRunTestStep) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunTestStep != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandRunTestStep.Size()))
		n22, err := m.CommandRunTestStep.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *Wrapper_CommandRunAfterTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunAfterTestCaseHook != nil {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandRunAfterTestCaseHook.Size()))
		n23, err := m.CommandRunAfterTestCaseHook.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *Wrapper_CommandRunAfterTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandRunAfterTestRunHooks != nil {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandRunAfterTestRunHooks.Size()))
		n24, err := m.CommandRunAfterTestRunHooks.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *Wrapper_CommandGenerateSnippet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.CommandGenerateSnippet != nil {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.CommandGenerateSnippet.Size()))
		n25, err := m.CommandGenerateSnippet.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *Wrapper_CommandError) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xca
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.CommandError)))
	i += copy(dAtA[i:], m.CommandError)
	return i, nil
}
func (m *SourceReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceReference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if m.Location != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n26, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Line != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Line))
	}
	if m.Column != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Column))
	}
	return i, nil
}

func (m *Attachment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Attachment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Source.Size()))
		n27, err := m.Source.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Media != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Media.Size()))
		n28, err := m.Media.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *Media) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Media) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Encoding) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Encoding)))
		i += copy(dAtA[i:], m.Encoding)
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	return i, nil
}

func (m *Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Source) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Media != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Media.Size()))
		n29, err := m.Media.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *GherkinDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GherkinDocument) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if m.Feature != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Feature.Size()))
		n30, err := m.Feature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.Comments) > 0 {
		for _, msg := range m.Comments {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Feature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Feature) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n31, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FeatureChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeatureChild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn32, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn32
	}
	return i, nil
}

func (m *FeatureChild_Rule) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Rule != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Rule.Size()))
		n33, err := m.Rule.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}
func (m *FeatureChild_Background) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Background != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Background.Size()))
		n34, err := m.Background.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}
func (m *FeatureChild_Scenario) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Scenario != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Scenario.Size()))
		n35, err := m.Scenario.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}
func (m *Rule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Rule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n36, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RuleChild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuleChild) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn37, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn37
	}
	return i, nil
}

func (m *RuleChild_Background) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Background != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Background.Size()))
		n38, err := m.Background.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}
func (m *RuleChild_Scenario) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Scenario != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Scenario.Size()))
		n39, err := m.Scenario.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}
func (m *Background) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Background) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n40, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Scenario) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Scenario) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n41, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Examples) > 0 {
		for _, msg := range m.Examples {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Comment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Comment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n42, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	return i, nil
}

func (m *DataTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n43, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.Rows) > 0 {
		for _, msg := range m.Rows {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DocString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocString) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n44, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.Delimiter) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Delimiter)))
		i += copy(dAtA[i:], m.Delimiter)
	}
	return i, nil
}

func (m *Examples) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Examples) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n45, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.TableHeader != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TableHeader.Size()))
		n46, err := m.TableHeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.TableBody) > 0 {
		for _, msg := range m.TableBody {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Step) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Step) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n47, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.Argument != nil {
		nn48, err := m.Argument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn48
	}
	return i, nil
}

func (m *Step_DocString) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DocString != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DocString.Size()))
		n49, err := m.DocString.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	return i, nil
}
func (m *Step_DataTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataTable != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DataTable.Size()))
		n50, err := m.DataTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	return i, nil
}
func (m *TableCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableCell) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n51, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *TableRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableRow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n52, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if len(m.Cells) > 0 {
		for _, msg := range m.Cells {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n53, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Pickle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pickle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Uri) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, msg := range m.Tags {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Locations) > 0 {
		for _, msg := range m.Locations {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PickleStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleStep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.Locations) > 0 {
		for _, msg := range m.Locations {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Argument != nil {
		nn54, err := m.Argument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn54
	}
	return i, nil
}

func (m *PickleStep_DocString) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DocString != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DocString.Size()))
		n55, err := m.DocString.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}
func (m *PickleStep_DataTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataTable != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DataTable.Size()))
		n56, err := m.DataTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}
func (m *PickleDocString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleDocString) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n57, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *PickleTable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleTable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, msg := range m.Rows {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PickleTableCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleTableCell) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n58, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	return i, nil
}

func (m *PickleTableRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleTableRow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cells) > 0 {
		for _, msg := range m.Cells {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PickleTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n59, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *PickleAccepted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleAccepted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	return i, nil
}

func (m *PickleRejected) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PickleRejected) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	return i, nil
}

func (m *TestRunStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestRunStarted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TestCasePreparedStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCasePreparedStep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceLocation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.SourceLocation.Size()))
		n60, err := m.SourceLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.ActionLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.ActionLocation.Size()))
		n61, err := m.ActionLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}

func (m *TestCasePrepared) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCasePrepared) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if len(m.Steps) > 0 {
		for _, msg := range m.Steps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TestCaseStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseStarted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n62, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}

func (m *TestCaseFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseFinished) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n63, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.TestResult != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestResult.Size()))
		n64, err := m.TestResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}

func (m *TestStepStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestStepStarted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Index))
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n65, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}

func (m *TestStepFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestStepFinished) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Index))
	}
	if m.TestResult != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestResult.Size()))
		n66, err := m.TestResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n67, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}

func (m *TestHookStarted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestHookStarted) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n68, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}

func (m *TestHookFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestHookFinished) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PickleId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.PickleId)))
		i += copy(dAtA[i:], m.PickleId)
	}
	if m.TestResult != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestResult.Size()))
		n69, err := m.TestResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Timestamp.Size()))
		n70, err := m.Timestamp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	return i, nil
}

func (m *TestResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Status))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.DurationNanoseconds != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DurationNanoseconds))
	}
	return i, nil
}

func (m *TestRunFinished) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestRunFinished) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CommandStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BaseDirectory) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.BaseDirectory)))
		i += copy(dAtA[i:], m.BaseDirectory)
	}
	if m.SourcesConfig != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.SourcesConfig.Size()))
		n71, err := m.SourcesConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.RuntimeConfig != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.RuntimeConfig.Size()))
		n72, err := m.RuntimeConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.SupportCodeConfig != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.SupportCodeConfig.Size()))
		n73, err := m.SupportCodeConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}

func (m *SourcesConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourcesConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AbsolutePaths) > 0 {
		for _, s := range m.AbsolutePaths {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if m.Filters != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Filters.Size()))
		n74, err := m.Filters.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.Order != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Order.Size()))
		n75, err := m.Order.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	return i, nil
}

func (m *SourcesFilterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourcesFilterConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TagExpression) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TagExpression)))
		i += copy(dAtA[i:], m.TagExpression)
	}
	if len(m.NameRegularExpressions) > 0 {
		for _, s := range m.NameRegularExpressions {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.UriToLinesMapping) > 0 {
		for _, msg := range m.UriToLinesMapping {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UriToLinesMapping) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UriToLinesMapping) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AbsolutePath) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.AbsolutePath)))
		i += copy(dAtA[i:], m.AbsolutePath)
	}
	if len(m.Lines) > 0 {
		dAtA77 := make([]byte, len(m.Lines)*10)
		var j76 int
		for _, num := range m.Lines {
			for num >= 1<<7 {
				dAtA77[j76] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j76++
			}
			dAtA77[j76] = uint8(num)
			j76++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(j76))
		i += copy(dAtA[i:], dAtA77[:j76])
	}
	return i, nil
}

func (m *SourcesOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourcesOrder) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
	}
	if m.Seed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Seed))
	}
	return i, nil
}

func (m *RuntimeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RuntimeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsFailFast {
		dAtA[i] = 0x8
		i++
		if m.IsFailFast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsDryRun {
		dAtA[i] = 0x10
		i++
		if m.IsDryRun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsStrict {
		dAtA[i] = 0x18
		i++
		if m.IsStrict {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxParallel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.MaxParallel))
	}
	return i, nil
}

func (m *SupportCodeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupportCodeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BeforeTestCaseHookDefinitionConfigs) > 0 {
		for _, msg := range m.BeforeTestCaseHookDefinitionConfigs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AfterTestCaseHookDefinitionConfigs) > 0 {
		for _, msg := range m.AfterTestCaseHookDefinitionConfigs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StepDefinitionConfigs) > 0 {
		for _, msg := range m.StepDefinitionConfigs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ParameterTypeConfigs) > 0 {
		for _, msg := range m.ParameterTypeConfigs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TestCaseHookDefinitionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestCaseHookDefinitionConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.TagExpression) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TagExpression)))
		i += copy(dAtA[i:], m.TagExpression)
	}
	if m.Location != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n78, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}

func (m *StepDefinitionConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepDefinitionConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Pattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Pattern.Size()))
		n79, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.Location != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Location.Size()))
		n80, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}

func (m *StepDefinitionPattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepDefinitionPattern) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Source)))
		i += copy(dAtA[i:], m.Source)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *ParameterTypeConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParameterTypeConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.RegularExpressions) > 0 {
		for _, s := range m.RegularExpressions {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.PreferForRegularExpressionMatch {
		dAtA[i] = 0x18
		i++
		if m.PreferForRegularExpressionMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UseForSnippets {
		dAtA[i] = 0x20
		i++
		if m.UseForSnippets {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CommandActionComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandActionComplete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CompletedId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.CompletedId)))
		i += copy(dAtA[i:], m.CompletedId)
	}
	if m.Result != nil {
		nn81, err := m.Result.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn81
	}
	return i, nil
}

func (m *CommandActionComplete_TestResult) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.TestResult != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.TestResult.Size()))
		n82, err := m.TestResult.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	return i, nil
}
func (m *CommandActionComplete_Snippet) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.Snippet)))
	i += copy(dAtA[i:], m.Snippet)
	return i, nil
}
func (m *CommandRunBeforeTestRunHooks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunBeforeTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	return i, nil
}

func (m *CommandRunAfterTestRunHooks) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunAfterTestRunHooks) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	return i, nil
}

func (m *CommandInitializeTestCase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandInitializeTestCase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	if len(m.TestCaseId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i += copy(dAtA[i:], m.TestCaseId)
	}
	if m.Pickle != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Pickle.Size()))
		n83, err := m.Pickle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}

func (m *CommandRunBeforeTestCaseHook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunBeforeTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	if len(m.TestCaseId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i += copy(dAtA[i:], m.TestCaseId)
	}
	if len(m.TestCaseHookDefinitionId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseHookDefinitionId)))
		i += copy(dAtA[i:], m.TestCaseHookDefinitionId)
	}
	return i, nil
}

func (m *CommandRunAfterTestCaseHook) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunAfterTestCaseHook) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	if len(m.TestCaseId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i += copy(dAtA[i:], m.TestCaseId)
	}
	if len(m.TestCaseHookDefinitionId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseHookDefinitionId)))
		i += copy(dAtA[i:], m.TestCaseHookDefinitionId)
	}
	return i, nil
}

func (m *CommandRunTestStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandRunTestStep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	if len(m.TestCaseId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.TestCaseId)))
		i += copy(dAtA[i:], m.TestCaseId)
	}
	if len(m.StepDefinitionId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.StepDefinitionId)))
		i += copy(dAtA[i:], m.StepDefinitionId)
	}
	if len(m.PatternMatches) > 0 {
		for _, msg := range m.PatternMatches {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PatternMatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatternMatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Captures) > 0 {
		for _, s := range m.Captures {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ParameterTypeName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ParameterTypeName)))
		i += copy(dAtA[i:], m.ParameterTypeName)
	}
	if m.PickleArgument != nil {
		nn84, err := m.PickleArgument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn84
	}
	return i, nil
}

func (m *PatternMatch_DocString) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DocString != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DocString.Size()))
		n85, err := m.DocString.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	return i, nil
}
func (m *PatternMatch_DataTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataTable != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DataTable.Size()))
		n86, err := m.DataTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	return i, nil
}
func (m *CommandGenerateSnippet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommandGenerateSnippet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ActionId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.ActionId)))
		i += copy(dAtA[i:], m.ActionId)
	}
	if len(m.GeneratedExpressions) > 0 {
		for _, msg := range m.GeneratedExpressions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PickleArgument != nil {
		nn87, err := m.PickleArgument.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn87
	}
	return i, nil
}

func (m *CommandGenerateSnippet_DocString) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DocString != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DocString.Size()))
		n88, err := m.DocString.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	return i, nil
}
func (m *CommandGenerateSnippet_DataTable) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.DataTable != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.DataTable.Size()))
		n89, err := m.DataTable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	return i, nil
}
func (m *GeneratedExpression) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneratedExpression) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Text) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.ParameterTypeNames) > 0 {
		for _, s := range m.ParameterTypeNames {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintMessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Wrapper) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		n += m.Message.Size()
	}
	return n
}

func (m *Wrapper_Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_GherkinDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GherkinDocument != nil {
		l = m.GherkinDocument.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_Pickle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pickle != nil {
		l = m.Pickle.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_Attachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Attachment != nil {
		l = m.Attachment.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_TestCaseStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestCaseStarted != nil {
		l = m.TestCaseStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_TestStepStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestStepStarted != nil {
		l = m.TestStepStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_TestStepFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestStepFinished != nil {
		l = m.TestStepFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_TestCaseFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestCaseFinished != nil {
		l = m.TestCaseFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_TestHookStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestHookStarted != nil {
		l = m.TestHookStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_TestHookFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestHookFinished != nil {
		l = m.TestHookFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_PickleAccepted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PickleAccepted != nil {
		l = m.PickleAccepted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_PickleRejected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PickleRejected != nil {
		l = m.PickleRejected.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_TestCasePrepared) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestCasePrepared != nil {
		l = m.TestCasePrepared.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_TestRunStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestRunStarted != nil {
		l = m.TestRunStarted.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_TestRunFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestRunFinished != nil {
		l = m.TestRunFinished.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_CommandStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandStart != nil {
		l = m.CommandStart.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_CommandActionComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandActionComplete != nil {
		l = m.CommandActionComplete.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_CommandRunBeforeTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunBeforeTestRunHooks != nil {
		l = m.CommandRunBeforeTestRunHooks.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_CommandInitializeTestCase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandInitializeTestCase != nil {
		l = m.CommandInitializeTestCase.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_CommandRunBeforeTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunBeforeTestCaseHook != nil {
		l = m.CommandRunBeforeTestCaseHook.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_CommandRunTestStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunTestStep != nil {
		l = m.CommandRunTestStep.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_CommandRunAfterTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunAfterTestCaseHook != nil {
		l = m.CommandRunAfterTestCaseHook.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_CommandRunAfterTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandRunAfterTestRunHooks != nil {
		l = m.CommandRunAfterTestRunHooks.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_CommandGenerateSnippet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommandGenerateSnippet != nil {
		l = m.CommandGenerateSnippet.Size()
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Wrapper_CommandError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommandError)
	n += 2 + l + sovMessages(uint64(l))
	return n
}
func (m *SourceReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Line != 0 {
		n += 1 + sovMessages(uint64(m.Line))
	}
	if m.Column != 0 {
		n += 1 + sovMessages(uint64(m.Column))
	}
	return n
}

func (m *Attachment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Media) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GherkinDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Feature != nil {
		l = m.Feature.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Comments) > 0 {
		for _, e := range m.Comments {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *Feature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *FeatureChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *FeatureChild_Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rule != nil {
		l = m.Rule.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *FeatureChild_Background) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Background != nil {
		l = m.Background.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *FeatureChild_Scenario) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scenario != nil {
		l = m.Scenario.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Rule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *RuleChild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *RuleChild_Background) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Background != nil {
		l = m.Background.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *RuleChild_Scenario) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scenario != nil {
		l = m.Scenario.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Background) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *Scenario) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Examples) > 0 {
		for _, e := range m.Examples {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *Comment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Delimiter)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Examples) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.TableHeader != nil {
		l = m.TableHeader.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.TableBody) > 0 {
		for _, e := range m.TableBody {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *Step) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Argument != nil {
		n += m.Argument.Size()
	}
	return n
}

func (m *Step_DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *Step_DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *TableCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TableRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Cells) > 0 {
		for _, e := range m.Cells {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Pickle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Locations) > 0 {
		for _, e := range m.Locations {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.Argument != nil {
		n += m.Argument.Size()
	}
	return n
}

func (m *PickleStep_DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *PickleStep_DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *PickleDocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleTableCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleTableRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cells) > 0 {
		for _, e := range m.Cells {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PickleTag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleAccepted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *PickleRejected) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestRunStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TestCasePreparedStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceLocation != nil {
		l = m.SourceLocation.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ActionLocation != nil {
		l = m.ActionLocation.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCasePrepared) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestCaseStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestCaseFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestStepStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovMessages(uint64(m.Index))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestStepFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovMessages(uint64(m.Index))
	}
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestHookStarted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestHookFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PickleId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *TestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovMessages(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.DurationNanoseconds != 0 {
		n += 1 + sovMessages(uint64(m.DurationNanoseconds))
	}
	return n
}

func (m *TestRunFinished) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *CommandStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseDirectory)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.SourcesConfig != nil {
		l = m.SourcesConfig.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.RuntimeConfig != nil {
		l = m.RuntimeConfig.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.SupportCodeConfig != nil {
		l = m.SupportCodeConfig.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *SourcesConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AbsolutePaths) > 0 {
		for _, s := range m.AbsolutePaths {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Filters != nil {
		l = m.Filters.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *SourcesFilterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TagExpression)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.NameRegularExpressions) > 0 {
		for _, s := range m.NameRegularExpressions {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.UriToLinesMapping) > 0 {
		for _, e := range m.UriToLinesMapping {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *UriToLinesMapping) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AbsolutePath)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Lines) > 0 {
		l = 0
		for _, e := range m.Lines {
			l += sovMessages(uint64(e))
		}
		n += 1 + sovMessages(uint64(l)) + l
	}
	return n
}

func (m *SourcesOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	if m.Seed != 0 {
		n += 1 + sovMessages(uint64(m.Seed))
	}
	return n
}

func (m *RuntimeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsFailFast {
		n += 2
	}
	if m.IsDryRun {
		n += 2
	}
	if m.IsStrict {
		n += 2
	}
	if m.MaxParallel != 0 {
		n += 1 + sovMessages(uint64(m.MaxParallel))
	}
	return n
}

func (m *SupportCodeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BeforeTestCaseHookDefinitionConfigs) > 0 {
		for _, e := range m.BeforeTestCaseHookDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.AfterTestCaseHookDefinitionConfigs) > 0 {
		for _, e := range m.AfterTestCaseHookDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.StepDefinitionConfigs) > 0 {
		for _, e := range m.StepDefinitionConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.ParameterTypeConfigs) > 0 {
		for _, e := range m.ParameterTypeConfigs {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *TestCaseHookDefinitionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TagExpression)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *StepDefinitionConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *StepDefinitionPattern) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	return n
}

func (m *ParameterTypeConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.RegularExpressions) > 0 {
		for _, s := range m.RegularExpressions {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.PreferForRegularExpressionMatch {
		n += 2
	}
	if m.UseForSnippets {
		n += 2
	}
	return n
}

func (m *CommandActionComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CompletedId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Result != nil {
		n += m.Result.Size()
	}
	return n
}

func (m *CommandActionComplete_TestResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TestResult != nil {
		l = m.TestResult.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *CommandActionComplete_Snippet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Snippet)
	n += 1 + l + sovMessages(uint64(l))
	return n
}
func (m *CommandRunBeforeTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunAfterTestRunHooks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandInitializeTestCase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Pickle != nil {
		l = m.Pickle.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunBeforeTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseHookDefinitionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunAfterTestCaseHook) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseHookDefinitionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *CommandRunTestStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TestCaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.StepDefinitionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.PatternMatches) > 0 {
		for _, e := range m.PatternMatches {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *PatternMatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Captures) > 0 {
		for _, s := range m.Captures {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.ParameterTypeName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.PickleArgument != nil {
		n += m.PickleArgument.Size()
	}
	return n
}

func (m *PatternMatch_DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *PatternMatch_DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *CommandGenerateSnippet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActionId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.GeneratedExpressions) > 0 {
		for _, e := range m.GeneratedExpressions {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.PickleArgument != nil {
		n += m.PickleArgument.Size()
	}
	return n
}

func (m *CommandGenerateSnippet_DocString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocString != nil {
		l = m.DocString.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *CommandGenerateSnippet_DataTable) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DataTable != nil {
		l = m.DataTable.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}
func (m *GeneratedExpression) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.ParameterTypeNames) > 0 {
		for _, s := range m.ParameterTypeNames {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func sovMessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMessages(x uint64) (n int) {
	return sovMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Wrapper) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Wrapper: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Wrapper: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Source{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_Source{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GherkinDocument", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GherkinDocument{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_GherkinDocument{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pickle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Pickle{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_Pickle{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attachment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Attachment{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_Attachment{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCaseStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_TestCaseStarted{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestStepStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_TestStepStarted{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestStepFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestStepFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_TestStepFinished{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCaseFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_TestCaseFinished{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestHookStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestHookStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_TestHookStarted{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestHookFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestHookFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_TestHookFinished{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleAccepted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleAccepted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_PickleAccepted{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleRejected", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleRejected{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_PickleRejected{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCasePrepared", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestCasePrepared{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_TestCasePrepared{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestRunStarted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestRunStarted{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_TestRunStarted{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestRunFinished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestRunFinished{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_TestRunFinished{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandStart{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_CommandStart{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandActionComplete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandActionComplete{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_CommandActionComplete{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunBeforeTestRunHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunBeforeTestRunHooks{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_CommandRunBeforeTestRunHooks{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandInitializeTestCase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandInitializeTestCase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_CommandInitializeTestCase{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunBeforeTestCaseHook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunBeforeTestCaseHook{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_CommandRunBeforeTestCaseHook{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunTestStep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunTestStep{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_CommandRunTestStep{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunAfterTestCaseHook", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunAfterTestCaseHook{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_CommandRunAfterTestCaseHook{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandRunAfterTestRunHooks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandRunAfterTestRunHooks{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_CommandRunAfterTestRunHooks{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandGenerateSnippet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CommandGenerateSnippet{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Message = &Wrapper_CommandGenerateSnippet{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = &Wrapper_CommandError{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Line", wireType)
			}
			m.Line = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Line |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Attachment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Attachment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Attachment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &SourceReference{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &Media{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Media) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Media: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Media: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &Media{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GherkinDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GherkinDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GherkinDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Feature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Feature == nil {
				m.Feature = &Feature{}
			}
			if err := m.Feature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comments = append(m.Comments, &Comment{})
			if err := m.Comments[len(m.Comments)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Feature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Feature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Feature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &FeatureChild{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FeatureChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeatureChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeatureChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Rule{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &FeatureChild_Rule{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Background{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &FeatureChild_Background{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scenario", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Scenario{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &FeatureChild_Scenario{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Rule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Rule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Rule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &RuleChild{})
			if err := m.Children[len(m.Children)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuleChild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuleChild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuleChild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Background{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RuleChild_Background{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scenario", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Scenario{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &RuleChild_Scenario{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Background) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Background: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Background: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Scenario) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Scenario: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Scenario: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Examples", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Examples = append(m.Examples, &Examples{})
			if err := m.Examples[len(m.Examples)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Comment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Comment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Comment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &TableRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delimiter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delimiter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Examples) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Examples: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Examples: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &Tag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableHeader == nil {
				m.TableHeader = &TableRow{}
			}
			if err := m.TableHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableBody", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableBody = append(m.TableBody, &TableRow{})
			if err := m.TableBody[len(m.TableBody)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Argument = &Step_DocString{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DataTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Argument = &Step_DataTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, &TableCell{})
			if err := m.Cells[len(m.Cells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pickle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pickle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pickle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &PickleStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, &PickleTag{})
			if err := m.Tags[len(m.Tags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, &Location{})
			if err := m.Locations[len(m.Locations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locations = append(m.Locations, &Location{})
			if err := m.Locations[len(m.Locations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleDocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Argument = &PickleStep_DocString{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Argument = &PickleStep_DataTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleDocString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleDocString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleDocString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleTable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &PickleTableRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleTableCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTableCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTableCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleTableRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTableRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTableRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cells = append(m.Cells, &PickleTableCell{})
			if err := m.Cells[len(m.Cells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleAccepted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleAccepted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleAccepted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PickleRejected) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PickleRejected: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PickleRejected: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestRunStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestRunStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestRunStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCasePreparedStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCasePreparedStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCasePreparedStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceLocation == nil {
				m.SourceLocation = &SourceReference{}
			}
			if err := m.SourceLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActionLocation == nil {
				m.ActionLocation = &SourceReference{}
			}
			if err := m.ActionLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCasePrepared) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCasePrepared: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCasePrepared: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, &TestCasePreparedStep{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestResult == nil {
				m.TestResult = &TestResult{}
			}
			if err := m.TestResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestStepStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStepStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStepStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestStepFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestStepFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestStepFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestResult == nil {
				m.TestResult = &TestResult{}
			}
			if err := m.TestResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestHookStarted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestHookStarted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestHookStarted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestHookFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestHookFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestHookFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PickleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PickleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TestResult == nil {
				m.TestResult = &TestResult{}
			}
			if err := m.TestResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &types.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (Status(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DurationNanoseconds", wireType)
			}
			m.DurationNanoseconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DurationNanoseconds |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestRunFinished) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestRunFinished: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestRunFinished: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcesConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourcesConfig == nil {
				m.SourcesConfig = &SourcesConfig{}
			}
			if err := m.SourcesConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RuntimeConfig == nil {
				m.RuntimeConfig = &RuntimeConfig{}
			}
			if err := m.RuntimeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportCodeConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SupportCodeConfig == nil {
				m.SupportCodeConfig = &SupportCodeConfig{}
			}
			if err := m.SupportCodeConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourcesConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourcesConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourcesConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsolutePaths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsolutePaths = append(m.AbsolutePaths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filters == nil {
				m.Filters = &SourcesFilterConfig{}
			}
			if err := m.Filters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &SourcesOrder{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourcesFilterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourcesFilterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourcesFilterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameRegularExpressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameRegularExpressions = append(m.NameRegularExpressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UriToLinesMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UriToLinesMapping = append(m.UriToLinesMapping, &UriToLinesMapping{})
			if err := m.UriToLinesMapping[len(m.UriToLinesMapping)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UriToLinesMapping) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UriToLinesMapping: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UriToLinesMapping: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbsolutePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbsolutePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Lines = append(m.Lines, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessages
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Lines) == 0 {
					m.Lines = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessages
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Lines = append(m.Lines, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lines", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourcesOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourcesOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourcesOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (SourcesOrderType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFailFast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFailFast = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDryRun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDryRun = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStrict", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStrict = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxParallel", wireType)
			}
			m.MaxParallel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxParallel |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupportCodeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupportCodeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupportCodeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeforeTestCaseHookDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeforeTestCaseHookDefinitionConfigs = append(m.BeforeTestCaseHookDefinitionConfigs, &TestCaseHookDefinitionConfig{})
			if err := m.BeforeTestCaseHookDefinitionConfigs[len(m.BeforeTestCaseHookDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterTestCaseHookDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterTestCaseHookDefinitionConfigs = append(m.AfterTestCaseHookDefinitionConfigs, &TestCaseHookDefinitionConfig{})
			if err := m.AfterTestCaseHookDefinitionConfigs[len(m.AfterTestCaseHookDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepDefinitionConfigs = append(m.StepDefinitionConfigs, &StepDefinitionConfig{})
			if err := m.StepDefinitionConfigs[len(m.StepDefinitionConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeConfigs = append(m.ParameterTypeConfigs, &ParameterTypeConfig{})
			if err := m.ParameterTypeConfigs[len(m.ParameterTypeConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TestCaseHookDefinitionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestCaseHookDefinitionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestCaseHookDefinitionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &SourceReference{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepDefinitionConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepDefinitionConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepDefinitionConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &StepDefinitionPattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &SourceReference{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepDefinitionPattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepDefinitionPattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepDefinitionPattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (StepDefinitionPatternType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParameterTypeConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParameterTypeConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParameterTypeConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegularExpressions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegularExpressions = append(m.RegularExpressions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferForRegularExpressionMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PreferForRegularExpressionMatch = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseForSnippets", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseForSnippets = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandActionComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandActionComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandActionComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompletedId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TestResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &CommandActionComplete_TestResult{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = &CommandActionComplete_Snippet{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunBeforeTestRunHooks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunBeforeTestRunHooks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunBeforeTestRunHooks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunAfterTestRunHooks) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunAfterTestRunHooks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunAfterTestRunHooks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandInitializeTestCase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandInitializeTestCase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandInitializeTestCase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pickle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pickle == nil {
				m.Pickle = &Pickle{}
			}
			if err := m.Pickle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunBeforeTestCaseHook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunBeforeTestCaseHook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunBeforeTestCaseHook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseHookDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseHookDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunAfterTestCaseHook) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunAfterTestCaseHook: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunAfterTestCaseHook: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseHookDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseHookDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandRunTestStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandRunTestStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandRunTestStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TestCaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TestCaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepDefinitionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepDefinitionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatternMatches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternMatches = append(m.PatternMatches, &PatternMatch{})
			if err := m.PatternMatches[len(m.PatternMatches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatternMatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatternMatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatternMatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Captures", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Captures = append(m.Captures, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleDocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PickleArgument = &PatternMatch_DocString{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PickleArgument = &PatternMatch_DataTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommandGenerateSnippet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommandGenerateSnippet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommandGenerateSnippet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedExpressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeneratedExpressions = append(m.GeneratedExpressions, &GeneratedExpression{})
			if err := m.GeneratedExpressions[len(m.GeneratedExpressions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocString", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleDocString{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PickleArgument = &CommandGenerateSnippet_DocString{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PickleTable{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.PickleArgument = &CommandGenerateSnippet_DataTable{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneratedExpression) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneratedExpression: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneratedExpression: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParameterTypeNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParameterTypeNames = append(m.ParameterTypeNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessages   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("messages.proto", fileDescriptor_messages_623254d195b64710) }

var fileDescriptor_messages_623254d195b64710 = []byte{
	// 2923 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x5a, 0x4d, 0x73, 0xe4, 0x46,
	0xf9, 0x1f, 0xcd, 0x8c, 0xe7, 0xe5, 0xf1, 0xcb, 0x8e, 0x7b, 0xbd, 0xce, 0xec, 0x66, 0xff, 0x5e,
	0x47, 0xd9, 0xe4, 0x1f, 0x36, 0xc1, 0x9b, 0x6c, 0x60, 0x93, 0x6c, 0x12, 0x2a, 0x9e, 0x17, 0x7b,
	0x0c, 0xb6, 0xd7, 0xf4, 0xd8, 0x45, 0x12, 0x2a, 0x98, 0xb6, 0xd4, 0x1e, 0x8b, 0xd5, 0x48, 0x53,
	0x7a, 0x21, 0x6b, 0xa8, 0x54, 0x51, 0x14, 0x1c, 0x38, 0x40, 0x51, 0x54, 0x91, 0x1c, 0xb8, 0xf0,
	0x72, 0xe3, 0x04, 0x05, 0x1f, 0x80, 0x1b, 0xa9, 0xe4, 0x40, 0x8e, 0x1c, 0x53, 0xc9, 0x8d, 0x0f,
	0x90, 0x33, 0xd5, 0xad, 0x6e, 0x8d, 0x34, 0x23, 0x69, 0xec, 0x4c, 0x16, 0x96, 0x9b, 0xfa, 0xd1,
	0xf3, 0xfc, 0x9e, 0xd7, 0xee, 0x7e, 0xd4, 0x2d, 0x58, 0xe8, 0x53, 0xd7, 0x25, 0x3d, 0xea, 0xae,
	0x0d, 0x1c, 0xdb, 0xb3, 0xd1, 0x92, 0x61, 0xaf, 0x69, 0xbe, 0xe6, 0xf7, 0x8f, 0xa8, 0xb3, 0x26,
	0xdf, 0x5d, 0xb9, 0xd6, 0xb3, 0xed, 0x9e, 0x49, 0x6f, 0x72, 0x9e, 0x23, 0xff, 0xf8, 0xa6, 0x67,
	0xf4, 0xa9, 0xeb, 0x91, 0xfe, 0x20, 0x10, 0x53, 0x7f, 0xb3, 0x08, 0xe5, 0x6f, 0x39, 0x64, 0x30,
	0xa0, 0x0e, 0xba, 0x0d, 0x25, 0xd7, 0xf6, 0x1d, 0x8d, 0xd6, 0x95, 0x55, 0xe5, 0xa9, 0xd9, 0x5b,
	0x57, 0xd7, 0x92, 0x30, 0xd7, 0xba, 0x9c, 0xa7, 0x93, 0xc3, 0x82, 0x1b, 0x7d, 0x13, 0x2e, 0xf4,
	0x4e, 0xa8, 0x73, 0xcf, 0xb0, 0x5a, 0xb6, 0xe6, 0xf7, 0xa9, 0xe5, 0xd5, 0xf3, 0x1c, 0xe0, 0x89,
	0x64, 0x80, 0xcd, 0x38, 0x73, 0x27, 0x87, 0x47, 0xe5, 0x99, 0x29, 0x03, 0x43, 0xbb, 0x67, 0xd2,
	0x7a, 0x21, 0xcb, 0x94, 0x3d, 0xce, 0xc3, 0x4c, 0x09, 0xb8, 0x51, 0x03, 0x80, 0x78, 0x1e, 0xd1,
	0x4e, 0xb8, 0x15, 0x45, 0x2e, 0xbb, 0x9a, 0x2c, 0xbb, 0x1e, 0xf2, 0x75, 0x72, 0x38, 0x22, 0xc5,
	0xdc, 0xf1, 0xa8, 0xeb, 0x35, 0x89, 0x4b, 0xbb, 0x1e, 0x71, 0x3c, 0xaa, 0xd7, 0x67, 0xb2, 0xdc,
	0xd9, 0x8f, 0x33, 0x33, 0x77, 0x46, 0xe4, 0x25, 0x64, 0xd7, 0xa3, 0x03, 0x09, 0x59, 0x9a, 0x04,
	0x19, 0x61, 0x96, 0x90, 0x11, 0x12, 0xda, 0x87, 0x9a, 0x24, 0x6d, 0x18, 0x96, 0xe1, 0x9e, 0x50,
	0xbd, 0x5e, 0xe6, 0x98, 0x4f, 0x66, 0x63, 0x4a, 0xee, 0x4e, 0x0e, 0x8f, 0x21, 0x48, 0x54, 0x66,
	0x7b, 0x88, 0x5a, 0x99, 0x84, 0x1a, 0xe5, 0x96, 0xa8, 0x51, 0x9a, 0x74, 0xbf, 0x63, 0xdb, 0xf7,
	0xa4, 0xfb, 0xd5, 0x49, 0xee, 0x47, 0x98, 0xa5, 0xfb, 0x11, 0x92, 0x34, 0x94, 0x91, 0x42, 0x43,
	0x61, 0x92, 0xa1, 0x51, 0x6e, 0x69, 0x68, 0x94, 0x86, 0x76, 0x61, 0x21, 0x28, 0xa4, 0x75, 0x4d,
	0xa3, 0x03, 0x66, 0xe7, 0x2c, 0xc7, 0xbc, 0x9e, 0x55, 0x7e, 0x92, 0xb7, 0x93, 0xc3, 0x23, 0xd2,
	0x43, 0x3c, 0x4c, 0xbf, 0x47, 0x35, 0x86, 0x37, 0x37, 0x19, 0x4f, 0xf2, 0x0e, 0xf1, 0x24, 0x25,
	0x9a, 0x9e, 0x3d, 0x87, 0x0e, 0x88, 0x43, 0xf5, 0xfa, 0xfc, 0x59, 0xd2, 0x23, 0xb9, 0xa3, 0xe9,
	0x91, 0x34, 0x66, 0x25, 0xa3, 0x61, 0xdf, 0x92, 0xd9, 0x59, 0xc8, 0xb2, 0x72, 0x3f, 0xc6, 0xcb,
	0xac, 0x8c, 0x4b, 0xcb, 0x74, 0x63, 0xdf, 0x0a, 0x53, 0x73, 0x61, 0x52, 0xba, 0x23, 0xcc, 0x32,
	0xdd, 0x11, 0x12, 0xea, 0xc0, 0x9c, 0x66, 0xf7, 0xfb, 0xc4, 0xd2, 0xb9, 0x92, 0x7a, 0x8d, 0xe3,
	0xa9, 0xc9, 0x78, 0xcd, 0x08, 0x67, 0x27, 0x87, 0x63, 0x92, 0x48, 0x83, 0x4b, 0x62, 0xbc, 0xae,
	0x79, 0x86, 0x6d, 0x35, 0xed, 0xfe, 0xc0, 0xa4, 0x1e, 0xad, 0x2f, 0x72, 0xc8, 0xa7, 0x33, 0x21,
	0xe3, 0x22, 0x9d, 0x1c, 0x4e, 0xc6, 0x42, 0xf7, 0xe1, 0xaa, 0x78, 0x81, 0x7d, 0xab, 0x41, 0x8f,
	0x6d, 0x87, 0x0a, 0x27, 0x59, 0xb9, 0xb9, 0x75, 0xc4, 0x75, 0xdd, 0xca, 0xd4, 0x95, 0x28, 0xd9,
	0xc9, 0xe1, 0x4c, 0x64, 0x64, 0xc3, 0x65, 0xf1, 0x7e, 0xcb, 0x32, 0x3c, 0x83, 0x98, 0xc6, 0x0f,
	0xa8, 0x2c, 0x82, 0xfa, 0x45, 0xae, 0xf6, 0x66, 0xa6, 0xda, 0x71, 0xb1, 0x4e, 0x0e, 0xa7, 0x63,
	0xa6, 0xb9, 0xca, 0x05, 0x6d, 0xfb, 0x5e, 0x7d, 0xe9, 0xbc, 0xae, 0x4a, 0xc9, 0x34, 0x57, 0xe5,
	0x7b, 0xf4, 0x26, 0xa0, 0xe1, 0x7b, 0xb9, 0xba, 0xd5, 0x2f, 0x71, 0x7d, 0x4f, 0x4d, 0xd2, 0x27,
	0xf9, 0x3b, 0x39, 0x9c, 0x80, 0x82, 0x7c, 0x78, 0x74, 0x48, 0x5d, 0x3f, 0xf6, 0xa8, 0x13, 0x73,
	0x6a, 0x99, 0x2b, 0x79, 0x6e, 0x92, 0x92, 0x31, 0xc1, 0x4e, 0x0e, 0x67, 0xe1, 0xa6, 0xa8, 0x0d,
	0xcb, 0xe6, 0x91, 0x73, 0xaa, 0x8d, 0x54, 0x4d, 0x16, 0x2e, 0x3a, 0x86, 0x65, 0xf1, 0x7a, 0x93,
	0x5a, 0xd4, 0x21, 0x1e, 0xed, 0x5a, 0xc6, 0x60, 0x40, 0xbd, 0x7a, 0x9d, 0x6b, 0x7c, 0x26, 0x53,
	0xe3, 0x88, 0x4c, 0x27, 0x87, 0x53, 0xd0, 0xd0, 0xf5, 0x70, 0x16, 0xb7, 0x1d, 0xc7, 0x76, 0xea,
	0x97, 0x57, 0x95, 0xa7, 0xaa, 0x91, 0x19, 0xca, 0xa9, 0x8d, 0x2a, 0x94, 0x85, 0x0a, 0xf5, 0x10,
	0x2e, 0x04, 0xdd, 0x06, 0xa6, 0xc7, 0xd4, 0xa1, 0x96, 0x46, 0x51, 0x0d, 0x0a, 0xbe, 0x63, 0xf0,
	0x0e, 0xa5, 0x8a, 0xd9, 0x23, 0xba, 0x03, 0x15, 0xd3, 0xd6, 0x08, 0x9b, 0x80, 0xa2, 0xef, 0x58,
	0x49, 0xb6, 0x77, 0x5b, 0x70, 0xe1, 0x90, 0x5f, 0xbd, 0x0d, 0x15, 0x49, 0x45, 0x08, 0x8a, 0xa6,
	0x61, 0x05, 0xcd, 0xcf, 0x3c, 0xe6, 0xcf, 0x68, 0x19, 0x4a, 0x9a, 0x6d, 0xfa, 0xfd, 0x00, 0x79,
	0x1e, 0x8b, 0x91, 0xfa, 0x2b, 0x05, 0x60, 0xd8, 0x40, 0xa0, 0x57, 0x47, 0x3a, 0xa7, 0x27, 0xb2,
	0x3a, 0xa7, 0xd0, 0x97, 0xb0, 0x81, 0x42, 0x50, 0xd4, 0x89, 0x47, 0xb8, 0x8e, 0x2a, 0xe6, 0xcf,
	0xe8, 0x39, 0x98, 0xe9, 0x53, 0xdd, 0x20, 0xa2, 0x01, 0x7a, 0x34, 0x19, 0x71, 0x87, 0xb1, 0xe0,
	0x80, 0x53, 0xdd, 0x80, 0x19, 0x3e, 0x46, 0x57, 0xa0, 0x42, 0x2d, 0xcd, 0xd6, 0x0d, 0xab, 0x27,
	0x02, 0x15, 0x8e, 0xd1, 0x63, 0x2c, 0x07, 0x96, 0x47, 0x2d, 0xef, 0xd0, 0x3b, 0x1d, 0x50, 0xa1,
	0x73, 0x56, 0xd0, 0xf6, 0x4f, 0x07, 0x54, 0x25, 0x50, 0x0a, 0x2c, 0x4d, 0x08, 0xf6, 0x17, 0x64,
	0xea, 0x7b, 0x0a, 0x5c, 0x18, 0x69, 0x03, 0x13, 0x94, 0xbd, 0x00, 0xe5, 0x63, 0x4a, 0x3c, 0xdf,
	0xa1, 0x22, 0xb1, 0xff, 0x97, 0x0c, 0xbd, 0x11, 0x30, 0x61, 0xc9, 0x8d, 0x5e, 0x82, 0x0a, 0x2b,
	0x29, 0x6a, 0x79, 0x6e, 0xbd, 0xb0, 0x5a, 0x48, 0x97, 0x6c, 0x06, 0x5c, 0x38, 0x64, 0x57, 0x7f,
	0x9b, 0x87, 0xb2, 0xc0, 0x8b, 0x55, 0x96, 0x72, 0xbe, 0xca, 0x42, 0x5f, 0x86, 0xa2, 0x47, 0x7a,
	0x6e, 0x3d, 0xcf, 0xd5, 0x5f, 0x4e, 0xd9, 0xf9, 0x48, 0x0f, 0x73, 0x36, 0x96, 0x32, 0x93, 0x58,
	0x3d, 0x9f, 0xf4, 0x82, 0x96, 0xb7, 0x8a, 0xc3, 0x31, 0xaa, 0x43, 0xf9, 0x1e, 0x3d, 0x7d, 0xdb,
	0x76, 0x74, 0xde, 0xd1, 0x56, 0xb1, 0x1c, 0xb2, 0x6c, 0x58, 0xa4, 0x4f, 0x79, 0x7f, 0x5a, 0xc5,
	0xfc, 0x19, 0xad, 0xc2, 0xac, 0x4e, 0x5d, 0xcd, 0x31, 0x06, 0xdc, 0xee, 0x52, 0x90, 0xdf, 0x08,
	0x09, 0x7d, 0x0d, 0x2a, 0xda, 0x89, 0x61, 0xea, 0x0e, 0xb5, 0xea, 0x65, 0x6e, 0x9e, 0x9a, 0x19,
	0xd7, 0x26, 0x63, 0xc6, 0xa1, 0x8c, 0xfa, 0xa1, 0x02, 0x73, 0xd1, 0x57, 0xe8, 0x59, 0x28, 0x3a,
	0xbe, 0x29, 0x8b, 0xff, 0x4a, 0x32, 0x18, 0xf6, 0x79, 0xa7, 0xce, 0x39, 0x59, 0x9f, 0x7e, 0x44,
	0xb4, 0x7b, 0x3d, 0xc7, 0xf6, 0x2d, 0x5d, 0x24, 0x37, 0xa5, 0x4f, 0x6f, 0x84, 0x7c, 0xac, 0x4f,
	0x1f, 0x4a, 0xa1, 0x57, 0xa0, 0xe2, 0x6a, 0xd4, 0x22, 0x8e, 0x61, 0x8b, 0xca, 0x4b, 0xc9, 0x4e,
	0x57, 0x70, 0x75, 0x72, 0x38, 0x94, 0x68, 0x94, 0x61, 0xe6, 0xfb, 0xc4, 0xf4, 0xa9, 0xfa, 0x0f,
	0x05, 0x8a, 0xcc, 0xb6, 0xa9, 0xb2, 0x1d, 0x49, 0x51, 0x3e, 0x39, 0x45, 0x85, 0xf4, 0x14, 0x15,
	0xc7, 0x53, 0xf4, 0x72, 0x24, 0x45, 0x33, 0x3c, 0x45, 0xd7, 0xd2, 0xa3, 0x3a, 0x9a, 0x9f, 0x77,
	0x15, 0xa8, 0x86, 0xf4, 0x91, 0x50, 0x2b, 0x53, 0x87, 0x3a, 0xff, 0xf9, 0x43, 0xfd, 0x81, 0x02,
	0x30, 0xd4, 0xf1, 0x50, 0x05, 0xfc, 0x59, 0x98, 0x71, 0x3d, 0x3a, 0x70, 0x45, 0xb4, 0x53, 0x6a,
	0x98, 0xf5, 0x06, 0x38, 0x60, 0x54, 0xff, 0x92, 0x87, 0x8a, 0x74, 0xf7, 0x3f, 0xb9, 0x52, 0x44,
	0x3c, 0x2f, 0x24, 0x7b, 0x5e, 0x4c, 0xf7, 0x7c, 0x26, 0xc3, 0xf3, 0xd2, 0x19, 0x3d, 0x67, 0xce,
	0xd2, 0xfb, 0x84, 0xb5, 0xba, 0xae, 0x58, 0x3f, 0x52, 0x9c, 0x6d, 0x0b, 0x2e, 0x1c, 0xf2, 0xab,
	0x6f, 0x40, 0x59, 0xac, 0xb9, 0x53, 0xc5, 0x0c, 0x41, 0xd1, 0xa3, 0xf7, 0x3d, 0xb9, 0x0d, 0xb1,
	0x67, 0xf5, 0x87, 0x50, 0x6d, 0x11, 0x8f, 0xec, 0x93, 0xa3, 0x29, 0x27, 0xf3, 0x2d, 0x28, 0x3a,
	0xf6, 0xdb, 0x32, 0x21, 0x2b, 0x69, 0x09, 0x39, 0x32, 0x29, 0xb6, 0xdf, 0xc6, 0x9c, 0x57, 0xfd,
	0xbd, 0x02, 0xd5, 0x96, 0xad, 0x75, 0x3d, 0x87, 0x6d, 0xb2, 0xd3, 0x68, 0x9f, 0xbc, 0x41, 0xb3,
	0x12, 0x10, 0x43, 0x59, 0x02, 0x62, 0x88, 0xae, 0x42, 0x55, 0xa7, 0xa6, 0xd1, 0x37, 0x3c, 0xea,
	0x88, 0x3a, 0x18, 0x12, 0xd4, 0xbf, 0xe7, 0xa1, 0x22, 0x73, 0xf2, 0xbf, 0x5c, 0xb2, 0xeb, 0x30,
	0xe7, 0xb1, 0xf0, 0x1f, 0x9e, 0x50, 0xa2, 0x53, 0x47, 0x9c, 0xa5, 0x4c, 0x4a, 0xd4, 0x2c, 0x97,
	0xe9, 0x70, 0x11, 0xf4, 0x2a, 0x40, 0x00, 0x71, 0x64, 0xeb, 0xa7, 0xd9, 0x55, 0x1c, 0x02, 0x54,
	0xb9, 0x44, 0xc3, 0xd6, 0x4f, 0xd5, 0x1f, 0xe5, 0xa1, 0xc8, 0x3f, 0x14, 0x1e, 0xd8, 0x1a, 0xc6,
	0xcb, 0xbb, 0x30, 0x2c, 0x6f, 0xf4, 0x1a, 0x80, 0x6e, 0x6b, 0x87, 0x2e, 0xaf, 0x30, 0x71, 0x22,
	0x95, 0xb2, 0x29, 0x84, 0x85, 0xd8, 0xc9, 0xe1, 0xaa, 0x1e, 0x56, 0x25, 0x43, 0x20, 0x1e, 0x39,
	0xe4, 0x6e, 0x88, 0xa0, 0xa5, 0x21, 0xc8, 0x89, 0xc4, 0x11, 0xe4, 0xa0, 0x01, 0x50, 0x21, 0x4e,
	0x8f, 0xb7, 0x6b, 0xea, 0x5b, 0x50, 0xe5, 0xc4, 0x26, 0x35, 0xcd, 0xa9, 0xc2, 0xb0, 0x24, 0xb6,
	0x07, 0x11, 0x04, 0xb1, 0x57, 0xbc, 0x03, 0x15, 0x19, 0xf8, 0xa9, 0xd0, 0xbf, 0x0a, 0x33, 0x1a,
	0x35, 0x4d, 0x59, 0xab, 0xd7, 0x32, 0x72, 0xcc, 0x3c, 0xc1, 0x01, 0xb7, 0x7a, 0x00, 0x85, 0x7d,
	0xd2, 0x9b, 0x76, 0x8d, 0xe2, 0xb5, 0x9d, 0x1f, 0xd6, 0xb6, 0xfa, 0xd3, 0x3c, 0x94, 0x82, 0x53,
	0x1e, 0xb4, 0x00, 0x79, 0x43, 0x17, 0xdd, 0x6e, 0xde, 0xd0, 0x65, 0xfb, 0x9b, 0x8f, 0xf5, 0xda,
	0x63, 0x3b, 0x59, 0xb4, 0x4f, 0x2c, 0x8e, 0xf4, 0x89, 0xb7, 0xe3, 0x7b, 0xd8, 0x6a, 0xd6, 0x21,
	0x53, 0x74, 0x3d, 0x7f, 0x5e, 0xcc, 0xe6, 0x52, 0x56, 0x84, 0x02, 0xb1, 0xe1, 0x9c, 0x7e, 0x05,
	0xaa, 0xd2, 0xd3, 0x09, 0xbb, 0x40, 0x18, 0x9a, 0xa1, 0x80, 0xfa, 0x99, 0x02, 0x30, 0x34, 0x24,
	0xac, 0x77, 0x25, 0x52, 0xef, 0x31, 0x05, 0xf9, 0x73, 0x2a, 0x40, 0x1b, 0xb1, 0xd9, 0x52, 0xc8,
	0xfa, 0x2a, 0x0b, 0xec, 0x48, 0x99, 0x33, 0x8d, 0xd8, 0x9c, 0x09, 0x0e, 0x94, 0x1f, 0xcb, 0x8e,
	0x50, 0xe6, 0xac, 0xf9, 0x99, 0x02, 0x17, 0x46, 0x14, 0x4e, 0x55, 0x64, 0xab, 0x10, 0xdd, 0x19,
	0xce, 0xb5, 0x59, 0xa8, 0x9b, 0x30, 0x1b, 0xb1, 0x19, 0xbd, 0x28, 0xb6, 0x3d, 0x85, 0xc7, 0xfa,
	0xfa, 0x44, 0x27, 0x87, 0x9b, 0x9f, 0x26, 0x7d, 0x7a, 0x90, 0x0b, 0xc2, 0x0e, 0x2c, 0xc4, 0x95,
	0xa3, 0x97, 0xe5, 0xd4, 0x0e, 0x2c, 0x7e, 0x62, 0xa2, 0xc5, 0xd1, 0x09, 0xfe, 0x6d, 0xa8, 0x86,
	0x25, 0xfd, 0x85, 0x4f, 0xf3, 0x67, 0xa4, 0xad, 0xe1, 0x49, 0xf0, 0x15, 0xa8, 0x04, 0x67, 0xb9,
	0x5b, 0x72, 0xce, 0x87, 0xe3, 0x21, 0x77, 0x78, 0xce, 0x1b, 0xe5, 0xce, 0x8f, 0x70, 0xd7, 0x60,
	0x21, 0x7e, 0x02, 0xab, 0xfe, 0x55, 0x81, 0xa5, 0xd1, 0x83, 0x5e, 0x3e, 0xad, 0x76, 0x60, 0x21,
	0x38, 0x61, 0xd8, 0x8e, 0x3b, 0x77, 0xc6, 0xe3, 0x89, 0x11, 0x61, 0x06, 0x47, 0xf8, 0x39, 0xe7,
	0x76, 0xfc, 0xb8, 0xe5, 0xac, 0x70, 0x71, 0x61, 0x75, 0x00, 0xb5, 0x51, 0xab, 0xb3, 0xc2, 0x84,
	0x5e, 0x93, 0xcb, 0x5b, 0xb0, 0x18, 0xdc, 0x38, 0xdb, 0x89, 0x77, 0xb4, 0x65, 0xef, 0xc1, 0x85,
	0x91, 0xcb, 0x9a, 0x4c, 0x85, 0x2f, 0x42, 0x35, 0xbc, 0x2e, 0x13, 0xae, 0x5e, 0x59, 0x0b, 0x2e,
	0xd4, 0xd6, 0xe4, 0x85, 0xda, 0xda, 0xbe, 0xe4, 0xc0, 0x43, 0x66, 0xf5, 0x8f, 0xca, 0xd0, 0xb7,
	0xf0, 0x0c, 0xfb, 0x81, 0xa8, 0x62, 0x9b, 0x3a, 0x3f, 0x2c, 0xa7, 0xae, 0x6f, 0x7a, 0x62, 0xa1,
	0x5b, 0xcd, 0x38, 0x67, 0xe7, 0x7c, 0x38, 0x22, 0xa3, 0xbe, 0x13, 0x44, 0x25, 0x7a, 0xb9, 0x94,
	0x65, 0xea, 0x12, 0xcc, 0x18, 0x96, 0x4e, 0xef, 0x8b, 0x13, 0xb1, 0x60, 0x10, 0x77, 0xa0, 0x70,
	0x9e, 0x58, 0xfd, 0x4d, 0xc4, 0x2a, 0x76, 0x0f, 0x75, 0x7e, 0x03, 0xa6, 0x8e, 0x43, 0xdc, 0x85,
	0xe2, 0x79, 0x5c, 0x10, 0x75, 0x15, 0xbd, 0x9f, 0x7a, 0xb0, 0x75, 0x15, 0xbb, 0xb4, 0xca, 0x9e,
	0x33, 0xd1, 0xa8, 0xe4, 0xa7, 0x8d, 0xca, 0xb9, 0x12, 0xfb, 0x0b, 0x05, 0x60, 0x08, 0x8a, 0xbe,
	0x02, 0x25, 0xd7, 0x23, 0x9e, 0xef, 0x72, 0x23, 0x17, 0x52, 0x6f, 0x97, 0x39, 0x0f, 0x16, 0xbc,
	0x6c, 0xf7, 0x12, 0xaf, 0x64, 0x8f, 0x2c, 0x86, 0xe8, 0x59, 0xb8, 0xa8, 0xfb, 0x0e, 0x5f, 0x4a,
	0x76, 0x89, 0x65, 0xbb, 0x54, 0xb3, 0x2d, 0xdd, 0xe5, 0x26, 0x16, 0x71, 0xd2, 0x2b, 0xf5, 0xe9,
	0x20, 0x4d, 0xd1, 0x7b, 0xa5, 0x3a, 0x94, 0x5d, 0x5f, 0xd3, 0xa8, 0x1b, 0x58, 0x55, 0xc1, 0x72,
	0xa8, 0xfe, 0x2e, 0x0f, 0x73, 0xd1, 0x8b, 0x24, 0x74, 0x1d, 0xe6, 0x8f, 0x88, 0x4b, 0x5b, 0x86,
	0x43, 0x35, 0xcf, 0x76, 0x4e, 0x85, 0x3d, 0x71, 0x22, 0xda, 0x82, 0xf9, 0x60, 0xd5, 0x74, 0x9b,
	0xb6, 0x75, 0x6c, 0xc8, 0xd6, 0xe3, 0xf1, 0xac, 0x25, 0x52, 0xb0, 0xe2, 0xb8, 0x24, 0x83, 0x72,
	0x7c, 0x8b, 0xc5, 0x53, 0x40, 0x15, 0xb3, 0xa0, 0x70, 0x94, 0x15, 0xc7, 0x25, 0xd1, 0x01, 0x2c,
	0xba, 0xfe, 0x60, 0x60, 0x3b, 0x5e, 0xd3, 0xd6, 0x25, 0x5c, 0xf0, 0x09, 0xf1, 0xff, 0x29, 0x96,
	0x8d, 0xb2, 0xe3, 0x71, 0x04, 0xf5, 0x23, 0x05, 0xe6, 0x63, 0x2e, 0xb0, 0x20, 0x91, 0x23, 0xd7,
	0x36, 0x7d, 0x8f, 0xee, 0x11, 0xef, 0x24, 0xd8, 0x9a, 0xab, 0x38, 0x4e, 0x8c, 0x35, 0xb1, 0xf9,
	0x91, 0x26, 0xb6, 0x09, 0xe5, 0x63, 0xc3, 0xf4, 0xa8, 0xe3, 0x8a, 0xd0, 0x7d, 0x29, 0x33, 0x74,
	0x1b, 0x9c, 0x57, 0x98, 0x28, 0x25, 0xd1, 0x8b, 0x30, 0x63, 0x3b, 0xba, 0xf8, 0x04, 0x4e, 0x3d,
	0xde, 0x14, 0x10, 0x77, 0x19, 0x27, 0x0e, 0x04, 0xd4, 0x0f, 0x14, 0xb8, 0x98, 0x00, 0xcd, 0x1c,
	0xf3, 0x48, 0xaf, 0x7d, 0x7f, 0xe0, 0x50, 0xd7, 0x95, 0x3b, 0x69, 0x15, 0xc7, 0x89, 0xe8, 0x36,
	0x2c, 0xb3, 0xfd, 0x1f, 0xd3, 0x9e, 0x6f, 0x12, 0x67, 0xf8, 0x22, 0xd8, 0xb3, 0xaa, 0x38, 0xe5,
	0x2d, 0xcb, 0x8f, 0xef, 0x18, 0xfb, 0xf6, 0xb6, 0x61, 0x51, 0x77, 0x87, 0x0c, 0x06, 0x41, 0xd3,
	0x5a, 0x48, 0xcf, 0xcf, 0xc1, 0x28, 0x3b, 0x1e, 0x47, 0x50, 0x77, 0x60, 0x71, 0x8c, 0x0f, 0xa9,
	0x30, 0x17, 0xcd, 0x86, 0x70, 0x24, 0x46, 0x63, 0x4b, 0xac, 0xc9, 0x64, 0xb8, 0xd9, 0x45, 0x1c,
	0x0c, 0xd4, 0xef, 0xc0, 0x5c, 0x34, 0x64, 0xe8, 0x0e, 0x14, 0xf9, 0x09, 0x45, 0x30, 0x9f, 0x9f,
	0x9c, 0x1c, 0x64, 0xd6, 0x8f, 0x62, 0x2e, 0xc3, 0xba, 0x26, 0x97, 0xd2, 0xa0, 0xbb, 0x29, 0x62,
	0xfe, 0xcc, 0x7a, 0xe3, 0xf9, 0x58, 0x19, 0xa3, 0x15, 0x00, 0xc3, 0xdd, 0x20, 0x86, 0xb9, 0x41,
	0x5c, 0x4f, 0xcc, 0xd0, 0x08, 0x85, 0x15, 0x92, 0xe1, 0xb6, 0x9c, 0x53, 0xec, 0x07, 0xbd, 0x48,
	0x05, 0x87, 0xe3, 0xe0, 0x1d, 0xeb, 0xb0, 0xb5, 0x60, 0x3b, 0xe0, 0xef, 0x82, 0x31, 0xeb, 0x9a,
	0xfb, 0xe4, 0xfe, 0x1e, 0x71, 0x88, 0x69, 0x52, 0x93, 0x57, 0x49, 0x11, 0x47, 0x49, 0xea, 0xc7,
	0x05, 0x58, 0x1c, 0x9b, 0x03, 0xe8, 0x27, 0x0a, 0x3c, 0x7e, 0x34, 0x76, 0x13, 0xd9, 0xa2, 0xc7,
	0x86, 0x65, 0x04, 0x17, 0xc0, 0x8c, 0x4d, 0x36, 0xa4, 0xb7, 0xb2, 0x3b, 0x94, 0x24, 0x51, 0x7c,
	0x16, 0x78, 0xf4, 0x63, 0x05, 0x54, 0x32, 0x7a, 0x79, 0x38, 0x6e, 0x45, 0xfe, 0x73, 0x5b, 0x71,
	0x06, 0x74, 0xf4, 0x5d, 0xb8, 0xc4, 0xba, 0xaa, 0x71, 0xb5, 0x85, 0xac, 0xf6, 0xac, 0x9b, 0x20,
	0x82, 0x93, 0x81, 0xd0, 0x5b, 0xb0, 0x34, 0x20, 0x0e, 0xe9, 0x53, 0x2f, 0x28, 0x1d, 0xa9, 0xa0,
	0xc8, 0x15, 0xa4, 0xac, 0x0b, 0x7b, 0xe3, 0x12, 0x38, 0x11, 0x46, 0x7d, 0x4f, 0x81, 0xab, 0x59,
	0x2e, 0x8e, 0x7d, 0xa1, 0x8f, 0xad, 0x01, 0xf9, 0xa4, 0x35, 0x60, 0x3d, 0xf2, 0x2d, 0x51, 0x38,
	0x4f, 0x7f, 0x3c, 0xbc, 0x95, 0xfc, 0x93, 0x02, 0x4b, 0x49, 0x81, 0x1a, 0xb3, 0xa8, 0x0d, 0xe5,
	0x01, 0xf1, 0x3c, 0xea, 0xc8, 0x56, 0xfc, 0xe9, 0xb3, 0x44, 0x7d, 0x2f, 0x10, 0xc1, 0x52, 0xf6,
	0x8b, 0x30, 0xd9, 0x83, 0x4b, 0x89, 0x4a, 0xd0, 0x72, 0xec, 0x6a, 0xb4, 0x1a, 0xde, 0x79, 0x36,
	0xc5, 0xe2, 0x91, 0xe7, 0x8b, 0xc7, 0xcd, 0x73, 0xd8, 0x3d, 0x5c, 0x45, 0xd4, 0x0f, 0x15, 0xb8,
	0x98, 0x90, 0xf0, 0xf0, 0x9b, 0x4c, 0x89, 0x9c, 0x9c, 0xac, 0x01, 0x72, 0xd2, 0xd6, 0xe5, 0x84,
	0x37, 0xa8, 0x03, 0xd7, 0x06, 0x0e, 0xf3, 0x74, 0xc3, 0x76, 0xc6, 0x96, 0xec, 0x1d, 0xe2, 0x69,
	0x27, 0x62, 0x59, 0x99, 0xc4, 0x86, 0x9e, 0x84, 0x05, 0xdf, 0xa5, 0x1b, 0xb6, 0x23, 0xee, 0xc1,
	0x5d, 0xbe, 0xe0, 0x54, 0xf0, 0x08, 0x55, 0xfd, 0x83, 0x02, 0x97, 0x12, 0x7f, 0x34, 0x09, 0xbe,
	0xf2, 0x83, 0x67, 0x3d, 0xec, 0xf2, 0xa2, 0x24, 0xd4, 0xf8, 0x3c, 0x8d, 0x5e, 0x27, 0x17, 0x6b,
	0xf5, 0xae, 0x40, 0xd9, 0x15, 0xf7, 0xfe, 0x05, 0x71, 0x33, 0x2f, 0x09, 0x8d, 0x0a, 0x94, 0x9c,
	0xe0, 0x73, 0xe1, 0x0e, 0x5c, 0xcd, 0xfa, 0x43, 0x85, 0xad, 0xbb, 0xc1, 0x87, 0xde, 0xb0, 0x1d,
	0x95, 0x63, 0xf5, 0x25, 0x78, 0x34, 0xe3, 0x37, 0x85, 0x4c, 0xd1, 0x9f, 0x2b, 0x70, 0x39, 0xf5,
	0x17, 0x95, 0x2c, 0x49, 0xb6, 0x89, 0xc8, 0x5f, 0x9e, 0xc2, 0xcf, 0xe9, 0x08, 0x85, 0x35, 0xa6,
	0x67, 0xff, 0xd7, 0x50, 0xfe, 0x69, 0xa8, 0xbe, 0xab, 0x24, 0xc7, 0x21, 0xfc, 0x97, 0x63, 0x1a,
	0x93, 0xee, 0x40, 0xdd, 0x4b, 0x5c, 0x99, 0xb6, 0xe4, 0x09, 0x7a, 0xea, 0x7b, 0xf5, 0xd7, 0x4a,
	0x62, 0x90, 0xff, 0xeb, 0x76, 0xbd, 0xaf, 0x00, 0x1a, 0xff, 0xff, 0x66, 0x2a, 0x73, 0x6e, 0x40,
	0x2d, 0xbe, 0x73, 0x84, 0x66, 0x8c, 0xd1, 0xd1, 0xd7, 0x61, 0x41, 0x2c, 0x77, 0x7c, 0x52, 0x52,
	0xb9, 0x8d, 0xa8, 0x69, 0xdb, 0xc8, 0x90, 0x17, 0x8f, 0x48, 0xaa, 0x9f, 0x29, 0x30, 0x17, 0x65,
	0x60, 0x4e, 0x68, 0x64, 0xe0, 0xf9, 0x0e, 0x95, 0x1d, 0x6f, 0x38, 0x46, 0xcf, 0xc0, 0x62, 0x6c,
	0xfb, 0xd9, 0x1d, 0x1e, 0x16, 0x8d, 0xbf, 0x78, 0xa8, 0xce, 0x2d, 0x6b, 0xe1, 0xdf, 0x90, 0xf2,
	0xf4, 0xf2, 0xcf, 0x79, 0x58, 0x4e, 0xfe, 0xeb, 0x27, 0x33, 0x8f, 0x6f, 0xc1, 0x52, 0x4f, 0xb0,
	0xeb, 0xa3, 0x8b, 0x6f, 0xea, 0x46, 0xbe, 0x39, 0x2e, 0x81, 0x13, 0x61, 0x1e, 0xf2, 0x98, 0xbd,
	0x01, 0x17, 0x13, 0x5c, 0x49, 0x3c, 0xf2, 0x5e, 0x03, 0x34, 0x56, 0x11, 0xe1, 0x16, 0x35, 0xfe,
	0xe6, 0xc6, 0xeb, 0x50, 0x0a, 0x3e, 0x97, 0xd1, 0x3c, 0x54, 0xd7, 0x77, 0x1a, 0x5b, 0x9b, 0x07,
	0x77, 0x0f, 0xba, 0xb5, 0x1c, 0x02, 0x28, 0x6d, 0xac, 0x6f, 0x6d, 0xb7, 0x5b, 0x35, 0x85, 0x3d,
	0xef, 0xad, 0x77, 0xbb, 0xed, 0x56, 0x2d, 0x8f, 0x66, 0xa1, 0xbc, 0xd7, 0xde, 0x6d, 0x6d, 0xed,
	0x6e, 0xd6, 0x0a, 0x6c, 0xd0, 0xfd, 0xc6, 0xd6, 0xde, 0x5e, 0xbb, 0x55, 0x2b, 0x32, 0x80, 0x83,
	0xdd, 0x56, 0x7b, 0x63, 0x6b, 0xb7, 0xdd, 0xaa, 0xcd, 0xdc, 0x78, 0x01, 0x6a, 0xa3, 0x8d, 0x3b,
	0x7a, 0x04, 0x2e, 0xde, 0xc5, 0xad, 0x36, 0x3e, 0xbc, 0xbb, 0x71, 0xc8, 0x39, 0xb7, 0xf6, 0xb7,
	0xee, 0xee, 0x06, 0xda, 0xf0, 0xfa, 0x6e, 0xeb, 0xee, 0x4e, 0x4d, 0xb9, 0xb1, 0x0d, 0x97, 0x53,
	0x37, 0x6d, 0x86, 0xd0, 0x3c, 0x68, 0x1e, 0xec, 0x34, 0xda, 0xf8, 0xb0, 0xfd, 0xfa, 0x1e, 0x6e,
	0x77, 0xbb, 0x01, 0xc2, 0x32, 0x20, 0xdc, 0xde, 0x3c, 0xd8, 0x5e, 0x8f, 0xd1, 0x95, 0xc6, 0xed,
	0xf7, 0x3f, 0x59, 0x51, 0x3e, 0xfa, 0x64, 0x45, 0xf9, 0xf8, 0x93, 0x15, 0xe5, 0x97, 0x9f, 0xae,
	0xe4, 0x3e, 0xfa, 0x74, 0x25, 0xf7, 0xcf, 0x4f, 0x57, 0x72, 0x6f, 0x56, 0x64, 0x2a, 0xfe, 0x95,
	0x5f, 0x6c, 0xca, 0xf4, 0xec, 0x08, 0xda, 0x51, 0x89, 0x9f, 0x4c, 0x3c, 0xff, 0xef, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x83, 0xd4, 0x52, 0x05, 0x25, 0x2f, 0x00, 0x00,
}
